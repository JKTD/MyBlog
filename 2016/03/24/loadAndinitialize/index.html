<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.54.0" />



<link rel="canonical" href="http://blog.flywithme.top/2016/03/24/loadandinitialize/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>Objective-C 中 &#43;load 与 &#43;initialize - Fly With Bug</title>
    
<meta name="description" content="类的加载 在java语言里，可以通过如下代码来实现加载类的时候执行对类的操作，一般叫：类初始块，或者，类加载块。比如 Java代码 public class MyClass{ static{ …… } }   在objc语言里，对应的机制是，2个类初始化方法，&#43;(void)load和&#43;(void)initialize。 #import &amp;quot;Constants.h&amp;quot; @implementation Constants &#43; (void)initialize{ NSLog(@&amp;quot;init constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } &#43; (void)load{ NSLog(@&amp;quot;load constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } @end   两个方法有一些不同。load，是加载类的时候，这里是Constants类，就会调用。也就是说，iOS应用启动的时候，就会加载所有的类，就会调用这个方法这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动。这时候，就要考虑initialize方法了。这个方法可看作类加载的延时加载方法。类加载后并不执行该方法。只有当实例化该类的实例的时候，才会在第一个实例加载前执行该方法。比如： [Constants alloc];alloc将为Constants实例在堆上分配变量。这时调用一次initialize方法，而且仅调用一次，也就是说再次alloc操作的时候，不会再调用initialize方法了。initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。如果希望在类及其Categorgy中执行不同的初始化的话可以使用&#43;load&#43;(void)load; 在Objective-C运行时载入类或者Category时被调用这个方法对动态库和静态库中的类或(Category)都有效.  在Mac OS X 10.5及之后的版本，初始化的顺序如下： 调用所有的Framework中的初始化方法 调用所有的&#43;load方法 调用C&#43;&#43;的静态初始化方及C/C&#43;&#43;中的attribute(constructor)函数 调用所有链接到目标文件的framework中的初始化方法     另外  一个类的&#43;load方法在其父类的&#43;load方法后调用 一个Category的&#43;load方法在被其扩展的类的自有&#43;load方法后调用 在&#43;load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的&#43;load方法可能尚未被调用。    下面是一个load的顺序">

<meta property="og:title" content="Objective-C 中 &#43;load 与 &#43;initialize - Fly With Bug">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.flywithme.top/2016/03/24/loadandinitialize/">
<meta property="og:image" content="http://blog.flywithme.topimages/default.png">
<meta property="og:site_name" content="Fly With Bug">
<meta property="og:description" content="类的加载 在java语言里，可以通过如下代码来实现加载类的时候执行对类的操作，一般叫：类初始块，或者，类加载块。比如 Java代码 public class MyClass{ static{ …… } }   在objc语言里，对应的机制是，2个类初始化方法，&#43;(void)load和&#43;(void)initialize。 #import &amp;quot;Constants.h&amp;quot; @implementation Constants &#43; (void)initialize{ NSLog(@&amp;quot;init constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } &#43; (void)load{ NSLog(@&amp;quot;load constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } @end   两个方法有一些不同。load，是加载类的时候，这里是Constants类，就会调用。也就是说，iOS应用启动的时候，就会加载所有的类，就会调用这个方法这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动。这时候，就要考虑initialize方法了。这个方法可看作类加载的延时加载方法。类加载后并不执行该方法。只有当实例化该类的实例的时候，才会在第一个实例加载前执行该方法。比如： [Constants alloc];alloc将为Constants实例在堆上分配变量。这时调用一次initialize方法，而且仅调用一次，也就是说再次alloc操作的时候，不会再调用initialize方法了。initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。如果希望在类及其Categorgy中执行不同的初始化的话可以使用&#43;load&#43;(void)load; 在Objective-C运行时载入类或者Category时被调用这个方法对动态库和静态库中的类或(Category)都有效.  在Mac OS X 10.5及之后的版本，初始化的顺序如下： 调用所有的Framework中的初始化方法 调用所有的&#43;load方法 调用C&#43;&#43;的静态初始化方及C/C&#43;&#43;中的attribute(constructor)函数 调用所有链接到目标文件的framework中的初始化方法     另外  一个类的&#43;load方法在其父类的&#43;load方法后调用 一个Category的&#43;load方法在被其扩展的类的自有&#43;load方法后调用 在&#43;load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的&#43;load方法可能尚未被调用。    下面是一个load的顺序">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Fly With Bug">
<meta name="twitter:url" content="http://blog.flywithme.top/2016/03/24/loadandinitialize/">
<meta name="twitter:title" content="Objective-C 中 &#43;load 与 &#43;initialize - Fly With Bug">
<meta name="twitter:description" content="类的加载 在java语言里，可以通过如下代码来实现加载类的时候执行对类的操作，一般叫：类初始块，或者，类加载块。比如 Java代码 public class MyClass{ static{ …… } }   在objc语言里，对应的机制是，2个类初始化方法，&#43;(void)load和&#43;(void)initialize。 #import &amp;quot;Constants.h&amp;quot; @implementation Constants &#43; (void)initialize{ NSLog(@&amp;quot;init constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } &#43; (void)load{ NSLog(@&amp;quot;load constants &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;quot;); } @end   两个方法有一些不同。load，是加载类的时候，这里是Constants类，就会调用。也就是说，iOS应用启动的时候，就会加载所有的类，就会调用这个方法这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动。这时候，就要考虑initialize方法了。这个方法可看作类加载的延时加载方法。类加载后并不执行该方法。只有当实例化该类的实例的时候，才会在第一个实例加载前执行该方法。比如： [Constants alloc];alloc将为Constants实例在堆上分配变量。这时调用一次initialize方法，而且仅调用一次，也就是说再次alloc操作的时候，不会再调用initialize方法了。initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。如果希望在类及其Categorgy中执行不同的初始化的话可以使用&#43;load&#43;(void)load; 在Objective-C运行时载入类或者Category时被调用这个方法对动态库和静态库中的类或(Category)都有效.  在Mac OS X 10.5及之后的版本，初始化的顺序如下： 调用所有的Framework中的初始化方法 调用所有的&#43;load方法 调用C&#43;&#43;的静态初始化方及C/C&#43;&#43;中的attribute(constructor)函数 调用所有链接到目标文件的framework中的初始化方法     另外  一个类的&#43;load方法在其父类的&#43;load方法后调用 一个Category的&#43;load方法在被其扩展的类的自有&#43;load方法后调用 在&#43;load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的&#43;load方法可能尚未被调用。    下面是一个load的顺序">
<meta name="twitter:image" content="http://blog.flywithme.topimages/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"http://blog.flywithme.top"
    },
    "headline": "Objective-C 中 &#43;load 与 &#43;initialize - Fly With Bug",
    "image": {
      "@type": "ImageObject",
      "url": "http://blog.flywithme.topimages/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2016-03-24T19:20:35JST",
    "dateModified": "2016-03-24T19:20:35JST",
    "author": {
      "@type": "Person",
      "name": "Fly With Bug"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Fly With Bug",
      "logo": {
        "@type": "ImageObject",
        "url": "http://blog.flywithme.topimages/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "类的加载 在java语言里，可以通过如下代码来实现加载类的时候执行对类的操作，一般叫：类初始块，或者，类加载块。比如
 Java代码
 public class MyClass{ static{ …… } }   在objc语言里，对应的机制是，2个类初始化方法，+(void)load和+(void)initialize。
 #import &quot;Constants.h&quot; @implementation Constants + (void)initialize{ NSLog(@&quot;init constants &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } + (void)load{ NSLog(@&quot;load constants &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } @end   两个方法有一些不同。
load，是加载类的时候，这里是Constants类，就会调用。也就是说，iOS应用启动的时候，就会加载所有的类，就会调用这个方法
这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动。这时候，就要考虑initialize方法了。这个方法可看作类加载的延时加载方法。类加载后并不执行该方法。只有当实例化该类的实例的时候，才会在第一个实例加载前执行该方法。比如： [Constants alloc];
alloc将为Constants实例在堆上分配变量。这时调用一次initialize方法，而且仅调用一次，也就是说再次alloc操作的时候，不会再调用initialize方法了。
initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。
如果希望在类及其Categorgy中执行不同的初始化的话可以使用+load
+(void)load; 在Objective-C运行时载入类或者Category时被调用
这个方法对动态库和静态库中的类或(Category)都有效.
  在Mac OS X 10.5及之后的版本，初始化的顺序如下：
 调用所有的Framework中的初始化方法 调用所有的+load方法 调用C++的静态初始化方及C/C++中的attribute(constructor)函数 调用所有链接到目标文件的framework中的初始化方法     另外
  一个类的+load方法在其父类的+load方法后调用 一个Category的+load方法在被其扩展的类的自有+load方法后调用 在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。    下面是一个load的顺序"
  }
</script>


    <link href="http://blog.flywithme.topcss/styles.css" rel="stylesheet">
    

  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://blog.flywithme.top">Fly With Bug</a>
          </div>

          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="http://blog.flywithme.top"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="http://blog.flywithme.toppost/" itemprop="url"><span itemprop="title">post</span></a></li>
        
        <li class="active">Objective-C 中 &#43;load 与 &#43;initialize</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2016-03-24T19:20:35JST">Mar 24, 2016</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="http://blog.flywithme.toppost/">post</a></li>
      
    </ul>

    <h1 class="title">Objective-C 中 &#43;load 与 &#43;initialize</h1>
  </header>

  

  <div class="article-body"><p>类的加载
在java语言里，可以通过如下代码来实现加载类的时候执行对类的操作，一般叫：类初始块，或者，类加载块。比如</p>

<hr />

<blockquote>
<p><strong>Java</strong>代码</p>
</blockquote>

<pre><code>public class MyClass{    
    static{    
        ……    
    }    
}           
</code></pre>

<blockquote>
<p>在objc语言里，对应的机制是，2个类初始化方法，+(void)load和+(void)initialize。</p>
</blockquote>

<pre><code>#import &quot;Constants.h&quot; 
@implementation Constants    

+ (void)initialize{    
    NSLog(@&quot;init constants &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    
}    

+ (void)load{    
    NSLog(@&quot;load constants &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    
}    

@end 
</code></pre>

<blockquote>
<p>两个方法有一些不同。<br />
load，是加载类的时候，这里是Constants类，就会调用。也就是说，iOS应用启动的时候，就会加载所有的类，就会调用这个方法<br />
这样有个缺点，当加载类需要很昂贵的资源，或者比较耗时的时候，可能造成不良的用户体验，或者系统的抖动。这时候，就要考虑initialize方法了。这个方法可看作类加载的延时加载方法。类加载后并不执行该方法。只有当实例化该类的实例的时候，才会在第一个实例加载前执行该方法。比如：
[Constants alloc];</p>

<p>alloc将为Constants实例在堆上分配变量。这时调用一次initialize方法，而且仅调用一次，也就是说再次alloc操作的时候，不会再调用initialize方法了。</p>

<p>initialize 会在运行时仅被触发一次，如果没有向类发送消息的话，这个方法将不会被调用。这个方法的调用是线程安全的。父类会比子类先收到此消息。</p>

<p>如果希望在类及其Categorgy中执行不同的初始化的话可以使用+load<br />
+(void)load; 在Objective-C运行时载入类或者Category时被调用<br />
这个方法对动态库和静态库中的类或(Category)都有效.</p>
</blockquote>

<ul>
<li>在Mac OS X 10.5及之后的版本，初始化的顺序如下：<br />

<ol>
<li>调用所有的Framework中的初始化方法</li>
<li>调用所有的+load方法</li>
<li>调用C++的静态初始化方及C/C++中的<strong>attribute</strong>(constructor)函数</li>
<li>调用所有链接到目标文件的framework中的初始化方法
<br /></li>
</ol></li>
</ul>

<blockquote>
<p>另外</p>
</blockquote>

<ul>
<li>一个类的+load方法在其父类的+load方法后调用</li>
<li>一个Category的+load方法在被其扩展的类的自有+load方法后调用
在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。
<br />
<br /></li>
</ul>

<blockquote>
<p>下面是一个load的顺序</p>
</blockquote>

<pre><code>#import &lt;Foundation/Foundation.h&gt;    

#define LOAD +(void)load{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define INITIALIZE +(void)initialize{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define DEF_CLASS(clsName) @interface clsName : NSObject \    
@end \    
@implementation clsName \    
INITIALIZE \    
LOAD \    
@end    

DEF_CLASS(C1)   //1    
DEF_CLASS(C2)   //2    

@interface C1 (Hello)    
+ (void)hello;    
@end    
@implementation C1 (Hello)    
INITIALIZE       //   
LOAD            //3    
+ (void)hello    
{    
    NSLog(@&quot;Hello&quot;);    
}    
+ (void)hi    
{    
    NSLog(@&quot;hi&quot;);    
}    
@end    

@interface C2 (Hello)    
@end    
@implementation C2 (Hello)    
+ (void)load    //4   
{    
    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);    
}    

+ (void)initialize    //   
{    
    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);    
}    
@end    
int main (int argc, const char * argv[])    
{    

    @autoreleasepool {    
        // insert code here...    
        //        [[C1 alloc]init]; // 向C1发送消息    
        //       [[C2 alloc]init]; // 向C2发送消息    
    }    
    return 0;    
}    
</code></pre>

<blockquote>
<p>输出</p>
</blockquote>

<pre><code class="language-bash">   2012-08-1400:47:07.859 www[654:903] +[C1 load]
   2012-08-1400:47:07.862 www[654:903] +[C2 load]
   2012-08-14 00:47:07.863 www[654:903] +[C1(Hello) load]
   2012-08-14 00:47:07.863 www[654:903] +[C2(Hello) load]   
  
</code></pre>

<blockquote>
<p>以上只执行了load方法。<br />
load和initialize的顺序:</p>
</blockquote>

<pre><code>#import &lt;Foundation/Foundation.h&gt;    

#define LOAD +(void)load{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define INITIALIZE +(void)initialize{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define DEF_CLASS(clsName) @interface clsName : NSObject \    
@end \    
@implementation clsName \    
INITIALIZE \    
LOAD \    
@end    

DEF_CLASS(C1)   //1    
DEF_CLASS(C2)   //2    

@interface C1 (Hello)    
+ (void)hello;    
@end    
@implementation C1 (Hello)    
INITIALIZE       //4    
LOAD            //3    
+ (void)hello    
{    
    NSLog(@&quot;Hello&quot;);    
}    
+ (void)hi    
{    
    NSLog(@&quot;hi&quot;);    
}    
@end    

@interface C2 (Hello)    
@end    
@implementation C2 (Hello)    
+ (void)load    //5    
{    
    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);//[C1 hello];//NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);    
}    

+ (void)initialize    //6    
{    
    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);    
}    
@end    
int main (int argc, const char * argv[])    
{    

    @autoreleasepool {    
        // insert code here...    
        [[C1 alloc]init]; // 向C1发送消息    
        [[C2 alloc]init]; // 向C2发送消息    
    }    
    return 0;    
}
</code></pre>

<blockquote>
<p>输出</p>
</blockquote>

<pre><code class="language-bash">  2012-08-1400:55:26.769 www[741:903] +[C1 load]
  2012-08-1400:55:26.772 www[741:903] +[C2 load]
  2012-08-14 00:55:26.772 www[741:903] +[C1(Hello) load]
  2012-08-14 00:55:26.773 www[741:903] +[C2(Hello) load]
  2012-08-14 00:55:26.773 www[741:903] +[C1(Hello) initialize]
  2012-08-14 00:55:26.774 www[741:903] +[C2(Hello) initialize]
</code></pre>

<blockquote>
<p>貌似类中的initialize没有执行。alloc]init某个类就调用每个类的initialize方法。
假如只[[C2 alloc]init];就只执行C2类中的initialize方法 ，输出：</p>
</blockquote>

<pre><code class="language-bash">  2012-08-1400:55:26.769 www[741:903] +[C1 load]
  2012-08-1400:55:26.772 www[741:903] +[C2 load]
  2012-08-14 00:55:26.772 www[741:903] +[C1(Hello) load]
  2012-08-14 00:55:26.773 www[741:903] +[C2(Hello) load]
  2012-08-14 00:55:26.774 www[741:903] +[C2(Hello) initialize]
</code></pre>

<blockquote>
<p>再看下面代码：<br />
    #import <Foundation/Foundation.h></p>
</blockquote>

<pre><code>#define LOAD +(void)load{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define INITIALIZE +(void)initialize{NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);}    
#define DEF_CLASS(clsName) @interface clsName : NSObject \    
@end \    
@implementation clsName \    
INITIALIZE \    
LOAD \    
@end    

DEF_CLASS(C1)   //1    
DEF_CLASS(C2)   //2    

@interface C1 (Hello)    
+ (void)hello;    
@end    
@implementation C1 (Hello)    
INITIALIZE       //4    
LOAD            //3    
+ (void)hello    
{    
    NSLog(@&quot;Hello&quot;);    
}    
+ (void)hi    
{    
    NSLog(@&quot;hi&quot;);    
}    
@end    

@interface C2 (Hello)    
@end    
@implementation C2 (Hello)    
+ (void)load    //5    
{    
    [C1 hello];//NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__); //这里做了修改，调用了C1的静态方法，导致执行了C1的+initialize   
}    

+ (void)initialize    //6    
{    
    NSLog(@&quot;%s&quot;, __PRETTY_FUNCTION__);    
}    
@end    
int main (int argc, const char * argv[])    
{    

    @autoreleasepool {    
        // insert code here...    
        //                [[C1 alloc]init]; // 向C1发送消息    
        [[C2 alloc]init]; // 向C2发送消息    
    }    
    return 0;    
}  
</code></pre>

<blockquote>
<p>输出</p>
</blockquote>

<pre><code class="language-bash"> 2012-08-1423:31:28.834 www[14975:903] +[C1 load]
 2012-08-1423:31:28.837 www[14975:903] +[C2 load]
 2012-08-14 23:31:28.837 www[14975:903] +[C1(Hello) load]
 2012-08-14 23:31:28.838 www[14975:903] +[C1(Hello) initialize]
 2012-08-1423:31:28.838 www[14975:903] Hello
 2012-08-14 23:31:28.839 www[14975:903] +[C2(Hello) initialize]
</code></pre>

<ul>
<li><p>问题：</p>

<ol>
<li>在倒数第二个代码中，为什么没有执行类中的initialize而是执行Category中的initialize方法？？（Category覆盖方法时优先级更高）
<br /></li>
</ol></li>

<li><p>要点：</p>

<ol>
<li>initialize和load，我们并不需要在这两个方法的实现中使用super调用父类的方法。</li>
<li>load和initialize被调用一次是相对runtime而言 ，你可以当作普通类方法多次调用。</li>
<li>类加载到系统的时候就用调用load方法，类首次使用的时候调用initialize方法。</li>

<li><p>load不像普通方法一样遵从那套继承规则，当每个类没有实现 load方法，不管各级超类是否实现，系统都不会调用此类的load方法。initialize与其他方法一样，如果每个类没有实现initialize方法，而超类实现了，那么就会执行超类的这个方法，所以通常会：</p>

<pre><code>+(void)initialize{  
      if(self == [XXXClass clasee])  
      //todo  
}
</code></pre>

<blockquote>
<p>加了这个检测后，只会在期望的那个类被加载的时候执行。</p>
</blockquote></li>

<li><p>initialize和load的方法必须写的精简。</p></li>

<li><p>initialize中可以实现无法在编译期初始化的全局变量，load的方法中可以实现swizzling的逻辑。</p></li>

<li><p>load的调用并不视为类的第一个方法完成，因为load中调用了当前类中的方法，就先去执行initialize方法了。</p></li>

<li><p>Runtime调用+(void)load时没有autorelease pool，</p>

<p>@interface MainClass : NSObject<br />
@end</p>

<p>@implementation MainClass</p>

<ul>
<li>(void) load {<br />
NSArray *array = [NSArray array];<br />
NSLog(@&ldquo;%@ %s&rdquo;, array, <strong>FUNCTION</strong>);<br />
}<br />
<br /></li>
</ul>

<p>@end</p>

<blockquote>
<p>objc[84934]: Object 0x10a512930 of class __NSArrayI autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug 2012-09-28 18:07:39.042 ClassMethod[84934:403] ( ) +[MainClass load]
  其原因是runtime调用+(void)load的时候，程序还没有建立其autorelease pool，所以那些会需要使用到autorelease pool的代码，都会出现异常。这一点是非常需要注意的，也就是说放在+(void)load中的对象都应该是alloc出来并且不能使用autorelease来释放。</p>
</blockquote></li>

<li><p>load方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。</p></li>

<li><p>所有类别(Category)中的load方法都会执行。</p></li>

<li><p>最后一个类别(Category)中的initialize方法会覆盖之前类别和类中的initialize方法。</p></li>
</ol></li>
</ul>
</div>

  <footer class="article-footer">
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">CATEGORIES</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="http://blog.flywithme.topcategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    
  </footer>

</article>


    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="http://blog.flywithme.top/2019/02/24/gobin/" class="list-group-item">go bin执行问题记录</a>
      
      <a href="http://blog.flywithme.top/2019/01/15/nginx/" class="list-group-item">Nginx 配置 HTTPS 服务器</a>
      
      <a href="http://blog.flywithme.top/2019/01/13/mongodump/" class="list-group-item">mongodb 维护小记</a>
      
      <a href="http://blog.flywithme.top/2018/12/24/vue_webserver/" class="list-group-item">Vue上线后，history页面点击刷新按钮报错404问题</a>
      
      <a href="http://blog.flywithme.top/2018/12/24/vue-element02/" class="list-group-item">vue 路由重载之后导致history页面刷新空白问题fix</a>
      
      <a href="http://blog.flywithme.top/2018/12/22/vue-element-admin01/" class="list-group-item">vue-element-admin 踩坑日记 01</a>
      
      <a href="http://blog.flywithme.top/2018/12/18/blocked-by-cors-policy/" class="list-group-item">gin api 跨域问题,cors</a>
      
      <a href="http://blog.flywithme.top/2018/12/10/mongodb/" class="list-group-item">MongoDB 用户名密码登录</a>
      
      <a href="http://blog.flywithme.top/2018/08/31/nat/" class="list-group-item">nat</a>
      
      <a href="http://blog.flywithme.top/2018/04/02/note_28/" class="list-group-item">Elasticsearch 入门</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
      <a href="http://blog.flywithme.topcategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0" class="list-group-item">技术文章</a>
      
      <a href="http://blog.flywithme.topcategories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" class="list-group-item">学习笔记</a>
      
      <a href="http://blog.flywithme.topcategories/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F" class="list-group-item">思考感悟</a>
      
      <a href="http://blog.flywithme.topcategories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="list-group-item">读书笔记</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p><span class="h-logo">&copy; Fly With Bug</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

