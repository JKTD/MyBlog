<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Bug on Fly With Bug</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sat, 22 Dec 2018 06:57:21 CST</updated>
        
        <item>
            <title>vue-element-admin 踩坑日记</title>
            <link>http://blog.flywithme.top/2018/12/22/vue-element-admin/</link>
            <pubDate>Sat, 22 Dec 2018 06:57:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/22/vue-element-admin/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://panjiachen.github.io/vue-element-admin&#34;&gt;vue-element-admin&lt;/a&gt; 是一个后台集成解决方案，
它基于 vue 和 element。它使用了最新的前端技术栈，
内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，
提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。&lt;/p&gt;

&lt;p&gt;通过vue-element-admin 的源代码学习掌握Vue的一些基础知识&lt;/p&gt;

&lt;h5 id=&#34;svg-图片加载&#34;&gt;SVG 图片加载&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;src/components目录下创建文件夹结构如下
  &lt;img src=&#34;sources/vue/1458ED9C-2172-42AE-B350-131FDD080B19.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;br /&gt;
SvgIcon下创建index.vue文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;svg :class=&amp;quot;svgClass&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;use :xlink:href=&amp;quot;iconName&amp;quot;/&amp;gt;
  &amp;lt;/svg&amp;gt;
&amp;lt;/template&amp;gt;
    
&amp;lt;script&amp;gt;
export default {
  name: &#39;SvgIcon&#39;,
  props: {
    iconClass: {
      type: String,
      required: true
    },
    className: {
      type: String,
      default: &#39;&#39;
    }
  },
  computed: {
    iconName() {
      return `#icon-${this.iconClass}`
    },
    svgClass() {
      if (this.className) {
        return &#39;svg-icon &#39; + this.className
      } else {
        return &#39;svg-icon&#39;
      }
    }
  }
}
&amp;lt;/script&amp;gt;
    
&amp;lt;style scoped&amp;gt;
.svg-icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在src目录下创建文件夹结构如图&lt;br /&gt;
 &lt;img src=&#34;sources/vue/C4C47129-A335-4E5C-B076-2C1167B78492.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;br /&gt;
svg 文件夹下放icon表情文件(.svg格式的文件)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;index.js文件内容如下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    import Vue from &#39;vue&#39;
    import SvgIcon from &#39;@/components/SvgIcon&#39;// svg组件
    
    // register globally
    Vue.component(&#39;svg-icon&#39;, SvgIcon)
    
    const req = require.context(&#39;./svg&#39;, false, /\.svg$/)
    const requireAll = requireContext =&amp;gt; requireContext.keys().map(requireContext)
    requireAll(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;svgo.yml文件内容如下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# replace default config

# multipass: true
# full: true

plugins:

  # - name
  #
  # or:
  # - name: false
  # - name: true
  #
  # or:
  # - name:
  #     param1: 1
  #     param2: 2

- removeAttrs:
    attrs:
      - &#39;fill&#39;
      - &#39;fill-rule&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改配置文件 package.json文件
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;在scriptes 属性下添加一行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;svgo&amp;quot;: &amp;quot;svgo -f src/icons/svg --config=src/icons/svgo.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改build目录下webpack.base.conf.js文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;修改module-&amp;gt;rules下元素&lt;/strong&gt;
  如图示修改
 &lt;img src=&#34;sources/vue/90A23CD9-00AD-4A94-A9E6-7F0C088E7B16.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      test: /\.svg$/,
      loader: &#39;svg-sprite-loader&#39;,
      include: [resolve(&#39;src/icons&#39;)],
      options: {
        symbolId: &#39;icon-[name]&#39;
      }
    },
    {
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
      loader: &#39;url-loader&#39;,
      exclude: [resolve(&#39;src/icons&#39;)],
      options: {
        limit: 10000,
        name: utils.assetsPath(&#39;img/[name].[hash:7].[ext]&#39;)
      }
    },
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>gin api 跨域问题,cors</title>
            <link>http://blog.flywithme.top/2018/12/18/blocked-by-CORS-policy/</link>
            <pubDate>Tue, 18 Dec 2018 03:35:24 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/18/blocked-by-CORS-policy/</guid>
            <description>&lt;p&gt;当一个资源从与该资源本身所在的服务器&lt;strong&gt;不同的域或端口&lt;/strong&gt;请求一个资源时，资源会发起一个跨域 HTTP 请求。&lt;/p&gt;

&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨域 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循&lt;strong&gt;同源策略&lt;/strong&gt;。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件。&lt;/p&gt;

&lt;p&gt;跨域资源共享标准：规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-contrib/cors&amp;quot;
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
)

func main() {
	router := gin.Default()
	// CORS for https://foo.com and https://github.com origins, allowing:
	// - PUT and PATCH methods
	// - Origin header
	// - Credentials share
	// - Preflight requests cached for 12 hours
	router.Use(cors.New(cors.Config{
		AllowOrigins:     []string{&amp;quot;https://foo.com&amp;quot;},
		AllowMethods:     []string{&amp;quot;PUT&amp;quot;, &amp;quot;PATCH&amp;quot;},
		AllowHeaders:     []string{&amp;quot;Origin&amp;quot;},
		ExposeHeaders:    []string{&amp;quot;Content-Length&amp;quot;},
		AllowCredentials: true,
		AllowOriginFunc: func(origin string) bool {
			return origin == &amp;quot;https://github.com&amp;quot;
		},
		MaxAge: 12 * time.Hour,
	}))
	router.Run()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>MongoDB 用户名密码登录</title>
            <link>http://blog.flywithme.top/2018/12/10/mongodb/</link>
            <pubDate>Mon, 10 Dec 2018 06:53:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/10/mongodb/</guid>
            <description>

&lt;h5 id=&#34;mongodb-authentication&#34;&gt;MongoDB authentication&lt;/h5&gt;

&lt;p&gt;MongoDB 默认直接连接，无须身份验证，如果当前机器可以公网访问，且不注意Mongodb 端口（默认 27017）的开放状态，那么Mongodb就会产生安全风险，被利用此配置漏洞，入侵数据库。&lt;/p&gt;

&lt;h5 id=&#34;容易遭受入侵的环境&#34;&gt;容易遭受入侵的环境&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用默认 mongod 命令启动 Mongodb&lt;/li&gt;
&lt;li&gt;机器可以被公网访问&lt;/li&gt;
&lt;li&gt;在公网上开放了 Mongodb 端口
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;开启用户名和密码验证&#34;&gt;开启用户名和密码验证&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;终端启动数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//参数默认可以不加，若有自定义参数，才要加上，下同
mongod --port 27017 --dbpath /data/db1  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;连接 mongo后创建用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongo --port 27017
use admin
db.createUser(
  {
    user: &amp;quot;adminUser&amp;quot;,
    pwd: &amp;quot;adminPass&amp;quot;,
    roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ]
  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启 mongod 数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --auth --port 27017 --dbpath /data/db1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;连接数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongo --port 27017 -u &amp;quot;adminUser&amp;quot; -p &amp;quot;adminPass&amp;quot; --authenticationDatabase &amp;quot;admin&amp;quot;

mongo --port 27017
    
use admin
db.auth(&amp;quot;adminUser&amp;quot;, &amp;quot;adminPass&amp;quot;)
    
// 输出 1 表示验证成功
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建普通用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use foo
    
db.createUser(
  {
    user: &amp;quot;simpleUser&amp;quot;,
    pwd: &amp;quot;simplePass&amp;quot;,
    roles: [ { role: &amp;quot;readWrite&amp;quot;, db: &amp;quot;foo&amp;quot; },
             { role: &amp;quot;read&amp;quot;, db: &amp;quot;bar&amp;quot; } ]
  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用普通用户连接数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>nat</title>
            <link>http://blog.flywithme.top/2018/08/31/nat/</link>
            <pubDate>Fri, 31 Aug 2018 15:30:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/08/31/nat/</guid>
            <description></description>
        </item>
        
        <item>
            <title>Elasticsearch 入门</title>
            <link>http://blog.flywithme.top/2018/04/02/note_28/</link>
            <pubDate>Mon, 02 Apr 2018 18:30:28 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/04/02/note_28/</guid>
            <description>

&lt;h5 id=&#34;简介-为什么要使用elasticsearch&#34;&gt;简介 为什么要使用Elasticsearch&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、
 可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安装方便&lt;/strong&gt;： 没有其他依赖，下载后安装很方便，只需修改几个参数就可以搭建一个集群&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSON&lt;/strong&gt;: 输入\输出格式为JSON,不需要定义Schema,快捷方便&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESTful&lt;/strong&gt;：基本所有操作（索引，查询，甚至配置）都可以通过HTTP接口进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式&lt;/strong&gt;：节点对外表现对等（每个节点都可以用来做入口）；加入节点，自动均衡&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多租户&lt;/strong&gt;：可以根据不同的用途分索引；可以同时操作多个索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;准实时&lt;/strong&gt;：从文档索引到可以被检索只有轻微延时，约1s&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;上一节使用docker run elasticsearch
docker run -d -p 9200:9200 elasticsearch&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;使用测试&#34;&gt;使用测试&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/elasticsearch/1522727510567.jpg&#34;  /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开idea -&amp;gt; tools -&amp;gt; testRESTful Web Service 工具&lt;/p&gt;

&lt;p&gt;&lt;image  src=&#34;sources/elasticsearch/1522668735966.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求：请求参数及说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;server&gt;:9200/index/type/id&lt;/li&gt;
&lt;li&gt;index -&amp;gt; database&lt;/li&gt;
&lt;li&gt;type -&amp;gt; table&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GET
&lt;image  src=&#34;sources/elasticsearch/1522726889411.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;插入
&lt;image  src=&#34;sources/elasticsearch/1522727255830.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查询
&lt;image  src=&#34;sources/elasticsearch/1522727299952.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package persist

import (
	&amp;quot;context&amp;quot;
	&amp;quot;errors&amp;quot;
	&amp;quot;log&amp;quot;

	&amp;quot;imooc/craw/engine&amp;quot;

	&amp;quot;gopkg.in/olivere/elastic.v5&amp;quot;
)

func ItemSaver(index string) (chan engine.Item, error) {
	client, err := elastic.NewClient(
		//Must turn off sniff in docker
		elastic.SetSniff(false),
	)
	if err != nil {
		return nil, err
	}

	out := make(chan engine.Item)
	go func() {
		itemCount := 0
		for {
			itemCount++
			item := &amp;lt;-out
			log.Printf(&amp;quot;ItemSaver got Item: #%d:%v&amp;quot;, itemCount, item)
			err := save(client, index, item)
			if err != nil {
				log.Printf(&amp;quot;Item saver :error saving item %v:%v&amp;quot;, item, err)
			}

		}
	}()
	return out, nil
}

func save(client *elastic.Client, index string, item engine.Item) error {

	if item.Type == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;must suplly type&amp;quot;)
	}
	indexService := client.Index().Index(index).Type(item.Type).BodyJson(item)
	if item.Id != &amp;quot;&amp;quot; {
		indexService.Id(item.Id)
	}
	_, err := indexService.Do(context.Background())
	if err != nil {
		return err
	}
	//fmt.Printf(&amp;quot;%+v&amp;quot;, resp)
	return nil
}


&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Docker 入门</title>
            <link>http://blog.flywithme.top/2018/04/02/note_27/</link>
            <pubDate>Mon, 02 Apr 2018 17:33:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/04/02/note_27/</guid>
            <description>

&lt;h5 id=&#34;什么是docker&#34;&gt;什么是Docker&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker是一个用来打包，装载和运行应用程序的一个轻量级容器的开源项目。
 它的工作方式非常像虚拟机，包裹所有的东西（文件系统，进程管理，环境变量等）
 在一个容器内。跟虚拟机有所不同，它是使用LXC（Linux kernel container）
 来替代虚拟层。 LXC没有自己的内核，但是与主机和其他容器一起共享Linux内核的。
 基于LXC，因此Docker是非常轻量级的，
 因此在运行应用程序的时候几乎没有性能损失。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;安装方式&#34;&gt;安装方式&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;brew install docker&lt;/li&gt;
&lt;li&gt;官网下载 Docker for mac 下载 &lt;a href=&#34;https://store.docker.com/editions/community/docker-ce-desktop-mac&#34;&gt;docker 下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;加速器-配置地址-http-www-daocloud-io-mirror-accelerator-doc&#34;&gt;加速器 &lt;a href=&#34;http://www.daocloud.io/mirror#accelerator-doc&#34;&gt;配置地址&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择对应的配置，按照提示，添加镜像地址
&lt;image  src=&#34;sources/docker/1522665847954.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看docker info
&lt;image  src=&#34;sources/docker/1522665979813.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行命令 &lt;code&gt;docker run hello-world&lt;/code&gt;  下载使用镜像&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动docker nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//把里面的端口映射到外面物理机的80端口
docker run -d -p 80:80 nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;docker run -d -p 9200:9200 nginx&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-3 多任务版爬虫</title>
            <link>http://blog.flywithme.top/2018/03/16/note_26/</link>
            <pubDate>Fri, 16 Mar 2018 16:02:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/16/note_26/</guid>
            <description>

&lt;h5 id=&#34;并发调度器&#34;&gt;并发调度器&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521197187281.jpg&#34;  /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//engine 
package engine

import (
	&amp;quot;log&amp;quot;
)

type ConcurrentEngine struct {
	Scheduler   Scheduler
	WorkerCount int
}

type Scheduler interface {
	ReadyNotifier
	Submit(Request)
	WorkerChan() chan Request
	Run()
}

type ReadyNotifier interface {
	WokerReady(chan Request)
}

func (e *ConcurrentEngine) Run(seeds ...Request) {
	out := make(chan ParseResult)
	e.Scheduler.Run()
	for i := 0; i &amp;lt; e.WorkerCount; i++ {
		createWorker(e.Scheduler.WorkerChan(), out, e.Scheduler)
	}

	for _, r := range seeds {
		e.Scheduler.Submit(r)
	}
	itemCount := 0
	for {
		result := &amp;lt;-out
		for _, item := range result.Items {
			itemCount++
			log.Printf(&amp;quot;Got item #%d: %v&amp;quot;, itemCount, item)
		}
		for _, request := range result.Requests {
			e.Scheduler.Submit(request)
		}
	}
}

func createWorker(in chan Request, out chan ParseResult, ready ReadyNotifier) {
	go func() {
		for {
			ready.WokerReady(in)
			request := &amp;lt;-in
			result, err := worker(request)
			if err != nil {
				continue
			}
			out &amp;lt;- result
		}
	}()
}

--------------------------------------
//scheduler queued

package scheduler

import (
	&amp;quot;imooc/craw/engine&amp;quot;
)

type QueuedScheduler struct {
	requestChan chan engine.Request
	workerChan  chan chan engine.Request
}

func (s *QueuedScheduler) WorkerChan() chan engine.Request {
	return make(chan engine.Request)
}

func (s *QueuedScheduler) Submit(r engine.Request) {
	s.requestChan &amp;lt;- r
}

func (s *QueuedScheduler) WokerReady(w chan engine.Request) {
	s.workerChan &amp;lt;- w
}

func (s *QueuedScheduler) Run() {
	s.workerChan = make(chan chan engine.Request)
	s.requestChan = make(chan engine.Request)
	go func() {
		var requestQ []engine.Request
		var workerQ []chan engine.Request
		for {
			var activeRequest engine.Request
			var activeWorker chan engine.Request
			if len(requestQ) &amp;gt; 0 &amp;amp;&amp;amp; len(workerQ) &amp;gt; 0 {
				activeWorker = workerQ[0]
				activeRequest = requestQ[0]
			}

			select {
			case r := &amp;lt;-s.requestChan:
				requestQ = append(requestQ, r)
			case w := &amp;lt;-s.workerChan:
				workerQ = append(workerQ, w)
			case activeWorker &amp;lt;- activeRequest:
				workerQ = workerQ[1:]
				requestQ = requestQ[1:]
			}
		}

	}()

}


&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-2 单任务版爬虫</title>
            <link>http://blog.flywithme.top/2018/03/14/note_25/</link>
            <pubDate>Wed, 14 Mar 2018 16:54:13 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/14/note_25/</guid>
            <description>

&lt;h5 id=&#34;总体的算法步骤&#34;&gt;总体的算法步骤&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521017696913.jpg&#34;  /&gt;&lt;/p&gt;

&lt;h5 id=&#34;解析器-parser&#34;&gt;解析器 Parser&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;输入： utf-8 编码的文本&lt;/li&gt;
&lt;li&gt;输出： Request{URL,对应的Parser} 列表，Item列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;单任务版爬虫架构&#34;&gt;单任务版爬虫架构&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521018347601.jpg&#34;  /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取并打印所有城市第一页用户的详细信息

&lt;ul&gt;
&lt;li&gt;使用http.Get获取内容&lt;/li&gt;
&lt;li&gt;使用Encodeing来转换编码：gbk-&amp;gt;utf-8&lt;/li&gt;
&lt;li&gt;使用charset.DetermineEncoding来判断编码&lt;/li&gt;
&lt;li&gt;使用正则表达式筛选需要的内容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code &lt;a href=&#34;https://github.com/flywithbug/imooc/tree/release/0.0.1/craw&#34;&gt;单任务爬虫分支&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-1 爬虫实现</title>
            <link>http://blog.flywithme.top/2018/03/09/note_24/</link>
            <pubDate>Fri, 09 Mar 2018 16:05:38 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/09/note_24/</guid>
            <description>

&lt;h5 id=&#34;获取初始页面内容&#34;&gt;获取初始页面内容&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用相亲网站做目标&lt;/li&gt;
&lt;li&gt;编码格式自动识别转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;获取有价值信息&#34;&gt;获取有价值信息&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;获取城市名称和链接

&lt;ul&gt;
&lt;li&gt;使用css选择器&lt;/li&gt;
&lt;li&gt;使用xpath&lt;/li&gt;
&lt;li&gt;使用正则表达式
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net/http&amp;quot;

	&amp;quot;bufio&amp;quot;
	&amp;quot;io&amp;quot;

	&amp;quot;regexp&amp;quot;

	&amp;quot;golang.org/x/net/html/charset&amp;quot;
	&amp;quot;golang.org/x/text/encoding&amp;quot;
	&amp;quot;golang.org/x/text/transform&amp;quot;
)

//网站编码识别转换
func determineEncoder(r io.Reader) encoding.Encoding {
	bytes, err := bufio.NewReader(r).Peek(1024)
	if err != nil {
		panic(err)
	}
	e, _, _ := charset.DetermineEncoding(bytes, &amp;quot;&amp;quot;)
	return e
}

const regextstr = `&amp;lt;a href=&amp;quot;http://www.zhenai.com/zhenghun/[0-9a-z]+&amp;quot;[^&amp;gt;]*&amp;gt;[^&amp;lt;]+&amp;lt;/a&amp;gt;`

const regextstr1 = `&amp;lt;a href=&amp;quot;(http://www.zhenai.com/zhenghun/[0-9a-z]+)&amp;quot;[^&amp;gt;]*&amp;gt;([^&amp;lt;]+)&amp;lt;/a&amp;gt;`

func printCityList(contents []byte) {
	re := regexp.MustCompile(regextstr1)
	//matchs := re.FindAll(contents, -1)
	amtch := re.FindAllSubmatch(contents, -1)

	for _, m := range amtch {
		fmt.Printf(&amp;quot;%s\n %s \n&amp;quot;, m[1], m[2])
	}
}

func main() {
	resp, err := http.Get(&amp;quot;http://www.zhenai.com/zhenghun&amp;quot;)

	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Println(&amp;quot;Error: status code &amp;quot;, resp.StatusCode)
		return
	}
	e := determineEncoder(resp.Body)
	utf8Reader := transform.NewReader(resp.Body, e.NewDecoder())
	result, err := ioutil.ReadAll(utf8Reader)
	if err != nil {
		panic(err)
	}
	printCityList(result)
	//fmt.Printf(&amp;quot;%s\n&amp;quot;, result)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 13-1 爬虫简介</title>
            <link>http://blog.flywithme.top/2018/03/08/note_23/</link>
            <pubDate>Thu, 08 Mar 2018 17:13:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/08/note_23/</guid>
            <description>

&lt;h5 id=&#34;网络爬虫分类&#34;&gt;网络爬虫分类&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通用爬虫：如baidu,google&lt;/li&gt;
&lt;li&gt;聚焦爬虫：从互联网获取结构化数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;项目总体结构&#34;&gt;项目总体结构&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1517564741602.jpg&#34;  /&gt;&lt;/p&gt;

&lt;h5 id=&#34;go语言的爬虫库-框架&#34;&gt;go语言的爬虫库/框架&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;henrylee2cn/pholcus&lt;/li&gt;
&lt;li&gt;gocrawl&lt;/li&gt;
&lt;li&gt;colly&lt;/li&gt;
&lt;li&gt;hu17889/go_spider&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;重新开发一个爬虫库&#34;&gt;重新开发一个爬虫库&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;不适用现成的爬虫库/框架&lt;/li&gt;
&lt;li&gt;使用ElasticSearch作为数据存储&lt;/li&gt;
&lt;li&gt;使用Go语言标准模板库实现http数据展示部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;实现步骤&#34;&gt;实现步骤&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;单任务&lt;/li&gt;
&lt;li&gt;并发版&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 12-1 迷宫的广度优先搜索</title>
            <link>http://blog.flywithme.top/2018/03/07/note_22/</link>
            <pubDate>Wed, 07 Mar 2018 17:21:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_22/</guid>
            <description>

&lt;h5 id=&#34;示例-广度优先算法&#34;&gt;示例：广度优先算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;为爬虫实战做准备&lt;/li&gt;
&lt;li&gt;应用广泛，综合性强&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-广度优先搜索走迷宫&#34;&gt;示例：广度优先搜索走迷宫&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广度优先算法示意图&lt;br /&gt;
&lt;image  src=&#34;sources/go/1520162909021.gif&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用循环创建二维slice&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用slice来实现队列&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用Fscanf读取文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对point的抽象&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//file
6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0


--------------- 
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func readMaze(filename string) [][]int {
	file, err := os.Open(filename)
	defer file.Close()
	if err != nil {
		panic(err)
	}
	var row, col int
	fmt.Fscanf(file, &amp;quot;%d %d&amp;quot;, &amp;amp;row, &amp;amp;col)
	maze := make([][]int, row)
	for i := range maze {
		maze[i] = make([]int, col)
		for j := range maze[i] {
			fmt.Fscanf(file, &amp;quot;%d&amp;quot;, &amp;amp;maze[i][j])
		}
	}
	return maze
}

type point struct {
	i, j int
}

var dirs = [4]point{
	{-1, 0}, {0, -1}, {1, 0}, {0, 1}}

func (p point) add(r point) point {
	return point{p.i + r.i, p.j + r.j}
}

func (p point) at(grid [][]int) (int, bool) {
	if p.i &amp;lt; 0 || p.i &amp;gt;= len(grid) {
		return 0, false
	}
	if p.j &amp;lt; 0 || p.j &amp;gt;= len(grid[p.i]) {
		return 0, false
	}
	return grid[p.i][p.j], true
}

func walk(maze [][]int, start, end point) [][]int {
	steps := make([][]int, len(maze))
	for i := range steps {
		steps[i] = make([]int, len(maze[i]))
	}
	Q := []point{start}
	for len(Q) &amp;gt; 0 {
		cur := Q[0]
		Q = Q[1:]
		if cur == end {
			break
		}
		for _, dir := range dirs {
			next := cur.add(dir)
			//maze att next is 0
			//and steps at next is 0
			//and next != start
			value, ok := next.at(maze)
			if !ok || value == 1 {
				continue
			}
			value, ok = next.at(steps)
			if !ok || value != 0 {
				continue
			}
			if next == start {
				continue
			}
			curSteps, _ := cur.at(steps)
			steps[next.i][next.j] = curSteps + 1
			Q = append(Q, next)
		}

	}
	return steps
}

func main() {
	maze := readMaze(&amp;quot;maze/maze.in&amp;quot;)
	for _, row := range maze {
		for _, val := range row {
			fmt.Printf(&amp;quot;%d &amp;quot;, val)
		}
		fmt.Println()
	}
	steps := walk(maze, point{0, 0}, point{len(maze) - 1, len(maze[0]) - 1})
	for _, row := range steps {
		for _, val := range row {
			fmt.Printf(&amp;quot;%3d &amp;quot;, val)
		}
		fmt.Println()
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 11-2 其他标准库</title>
            <link>http://blog.flywithme.top/2018/03/07/note_21/</link>
            <pubDate>Wed, 07 Mar 2018 16:54:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_21/</guid>
            <description>

&lt;h5 id=&#34;其他标准库&#34;&gt;其他标准库&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;bufio&lt;/li&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;li&gt;encoding/json&lt;/li&gt;
&lt;li&gt;regexp&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;stings/math/rand&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;查看库文档&#34;&gt;查看库文档&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;godoc -http :8888 (启用本地文档服务器)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://studygolang.com/pkgdoc&#34;&gt;https://studygolang.com/pkgdoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 11-1 http标准库</title>
            <link>http://blog.flywithme.top/2018/03/07/note_20/</link>
            <pubDate>Wed, 07 Mar 2018 13:24:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_20/</guid>
            <description>

&lt;h5 id=&#34;server&#34;&gt;Server&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, &amp;quot;Hello, world!&amp;quot;)
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, handler)
	http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;client&#34;&gt;Client&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用http客户端发送请求&lt;/li&gt;
&lt;li&gt;使用http.Client 控制请求头部等&lt;/li&gt;
&lt;li&gt;使用httputil简化工作
```
package main&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;import (
	&amp;ldquo;fmt&amp;rdquo;
	&amp;ldquo;net/http&amp;rdquo;
	&amp;ldquo;net/http/httputil&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;func main() {
	request, err := http.NewRequest(http.MethodGet, &amp;ldquo;&lt;a href=&#34;http://www.imooc.com&amp;quot;&#34;&gt;http://www.imooc.com&amp;quot;&lt;/a&gt;, nil)
	if err != nil {
		panic(err)
	}
	request.Header.Add(&amp;ldquo;User-Agent&amp;rdquo;, &amp;ldquo;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1&amp;rdquo;)
	client := http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			fmt.Println(&amp;ldquo;Redirect:&amp;ldquo;, req)
			return nil
		},
	}
	resp, err := client.Do(request)&lt;/p&gt;

&lt;p&gt;	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	s, err := httputil.DumpResponse(resp, true)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&amp;ldquo;%s\n&amp;rdquo;, s)
}
```&lt;/p&gt;

&lt;h5 id=&#34;http服务器的性能分析&#34;&gt;http服务器的性能分析&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;import _ &amp;ldquo;net/http/pprof&amp;rdquo;&lt;/li&gt;
&lt;li&gt;访问/debug/pprof&lt;/li&gt;
&lt;li&gt;使用go tool pprof分析性能&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 10-2 传统同步机制</title>
            <link>http://blog.flywithme.top/2018/03/07/note_19/</link>
            <pubDate>Wed, 07 Mar 2018 11:53:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_19/</guid>
            <description>

&lt;h5 id=&#34;检测数据冲突&#34;&gt;检测数据冲突&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;未加锁时使用 go run -race atomic.go 时检测会发现数据访问冲突&lt;/li&gt;
&lt;li&gt;加锁之后 运行-race 数据访问冲突就没了&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;传统同步机制&#34;&gt;传统同步机制&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;WaitGroup&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; package main
 
 import (
 	&amp;quot;fmt&amp;quot;
 	&amp;quot;sync&amp;quot;
 )
 
 func doWork(id int,
 	w worker) {
 	for n := range w.in {
 		fmt.Printf(&amp;quot;Worker %d received %c\n&amp;quot;,
 			id, n)
 		w.done()
 	}
 }
 
 type worker struct {
 	in   chan int
 	done func()
 }
 
 func createWorker(
 	id int, wg *sync.WaitGroup) worker {
 	w := worker{
 		in: make(chan int),
 		done: func() {
 			wg.Done()
 		},
 	}
 	go doWork(id, w)
 	return w
 }
 
 func chanDemo() {
 	var wg sync.WaitGroup
 
 	var workers [10]worker
 	for i := 0; i &amp;lt; 10; i++ {
 		workers[i] = createWorker(i, &amp;amp;wg)
 	}
 
 	wg.Add(20)
 	for i, worker := range workers {
 		worker.in &amp;lt;- &#39;a&#39; + i
 	}
 	for i, worker := range workers {
 		worker.in &amp;lt;- &#39;A&#39; + i
 	}
 
 	wg.Wait()
 }
 
 func main() {
 	chanDemo()
 }
 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Mutex&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
//加锁之前
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

type atomicInt int

func (a *atomicInt) increment() {
	*a++
}

func (a *atomicInt) get() int {
	return int(*a)
}

func main() {
	var a atomicInt
	a.increment()
	go func() {
		a.increment()
	}()
	time.Sleep(time.Millisecond)
	fmt.Println(a)
}
----------------------------------------------------------------------------------------
//加锁之后
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

type atomicInt struct {
	value int
	lock  sync.Mutex
}

func (a *atomicInt) increment() {
	a.lock.Lock()
	defer a.lock.Unlock()
	a.value++
}

func (a *atomicInt) get() int {
	a.lock.Lock()
	defer a.lock.Unlock()
	return a.value
}

func main() {
	var a atomicInt
	a.increment()
	go func() {
		a.increment()
	}()
	time.Sleep(time.Millisecond)
	fmt.Println(a.get())
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Cond&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 10-1 channel</title>
            <link>http://blog.flywithme.top/2018/03/04/note_18/</link>
            <pubDate>Sun, 04 Mar 2018 19:59:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/04/note_18/</guid>
            <description>

&lt;h5 id=&#34;channel的用法&#34;&gt;channel的用法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;channel&lt;/li&gt;
&lt;li&gt;buffered channel&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;li&gt;理论基础：Communication Sequential Process(CSP)&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t communicate by sharing memory;share memory by communicating(不要通过共享内存来通信，
通过通信来共享内存)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func worker(id int, c chan int) {
	for n := range c {
		fmt.Printf(&amp;quot;Worker %d received %c\n&amp;quot;,
			id, n)
	}
}

func createWorker(id int) chan&amp;lt;- int {
	c := make(chan int)
	go worker(id, c)
	return c
}

func chanDemo() {
	var channels [10]chan&amp;lt;- int
	for i := 0; i &amp;lt; 10; i++ {
		channels[i] = createWorker(i)
	}

	for i := 0; i &amp;lt; 10; i++ {
		channels[i] &amp;lt;- &#39;a&#39; + i
	}

	for i := 0; i &amp;lt; 10; i++ {
		channels[i] &amp;lt;- &#39;A&#39; + i
	}

	time.Sleep(time.Millisecond)
}

func bufferedChannel() {
	c := make(chan int, 3)
	go worker(0, c)
	c &amp;lt;- &#39;a&#39;
	c &amp;lt;- &#39;b&#39;
	c &amp;lt;- &#39;c&#39;
	c &amp;lt;- &#39;d&#39;
	time.Sleep(time.Millisecond)
}

func channelClose() {
	c := make(chan int)
	go worker(0, c)
	c &amp;lt;- &#39;a&#39;
	c &amp;lt;- &#39;b&#39;
	c &amp;lt;- &#39;c&#39;
	c &amp;lt;- &#39;d&#39;
	close(c)
	time.Sleep(time.Millisecond)
}

func main() {
	fmt.Println(&amp;quot;Channel as first-class citizen&amp;quot;)
	chanDemo()
	fmt.Println(&amp;quot;Buffered channel&amp;quot;)
	bufferedChannel()
	fmt.Println(&amp;quot;Channel close and range&amp;quot;)
	channelClose()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-使用channel来等待goroutine-结束-waitgroup的使用&#34;&gt;示例： 使用channel来等待goroutine 结束 （waitGroup的使用）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
)

func doWork(id int,
	w worker) {
	for n := range w.in {
		fmt.Printf(&amp;quot;Worker %d received %c\n&amp;quot;,
			id, n)
		w.done()
	}
}

type worker struct {
	in   chan int
	done func()
}

func createWorker(
	id int, wg *sync.WaitGroup) worker {
	w := worker{
		in: make(chan int),
		done: func() {
			wg.Done()
		},
	}
	go doWork(id, w)
	return w
}

func chanDemo() {
	var wg sync.WaitGroup

	var workers [10]worker
	for i := 0; i &amp;lt; 10; i++ {
		workers[i] = createWorker(i, &amp;amp;wg)
	}

	wg.Add(20)
	for i, worker := range workers {
		worker.in &amp;lt;- &#39;a&#39; + i
	}
	for i, worker := range workers {
		worker.in &amp;lt;- &#39;A&#39; + i
	}

	wg.Wait()
}

func main() {
	chanDemo()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例二-使用channel来实现叔的遍历&#34;&gt;示例二：使用channel来实现叔的遍历&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; 
func (node *Node) TraverseFunc(f func(*Node)) {
	if node == nil {
		return
	}

	node.Left.TraverseFunc(f)
	f(node)
	node.Right.TraverseFunc(f)
}

func (node *Node) TraverseWithChannel() chan *Node {
	out := make(chan *Node)
	go func() {
		node.TraverseFunc(func(node *Node) {
			out &amp;lt;- node
		})
		close(out)
	}()
	return out
}


---------------------
	c := root.TraverseWithChannel()
	maxValue := 0
	for node := range c {
		if node.Value &amp;gt; maxValue {
			maxValue = node.Value
		}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例三-使用select来进行调度&#34;&gt;示例三：使用Select来进行调度&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Select 的使用&lt;/li&gt;
&lt;li&gt;定时器的使用&lt;/li&gt;
&lt;li&gt;在select中可以使用Nil channel&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

func generator() chan int {
	out := make(chan int)
	go func() {
		i := 0
		for {
			time.Sleep(
				time.Duration(rand.Intn(1500)) *
					time.Millisecond)
			out &amp;lt;- i
			i++
		}
	}()
	return out
}

func worker(id int, c chan int) {
	for n := range c {
		time.Sleep(time.Second)
		fmt.Printf(&amp;quot;Worker %d received %d\n&amp;quot;,
			id, n)
	}
}

func createWorker(id int) chan&amp;lt;- int {
	c := make(chan int)
	go worker(id, c)
	return c
}

func main() {
	var c1, c2 = generator(), generator()
	var worker = createWorker(0)

	var values []int
	tm := time.After(10 * time.Second)
	tick := time.Tick(time.Second)
	for {
		var activeWorker chan&amp;lt;- int
		var activeValue int
		if len(values) &amp;gt; 0 {
			activeWorker = worker
			activeValue = values[0]
		}

		select {
		case n := &amp;lt;-c1:
			values = append(values, n)
		case n := &amp;lt;-c2:
			values = append(values, n)
		case activeWorker &amp;lt;- activeValue:
			values = values[1:]

		case &amp;lt;-time.After(800 * time.Millisecond):
			fmt.Println(&amp;quot;timeout&amp;quot;)
		case &amp;lt;-tick:
			fmt.Println(
				&amp;quot;queue len =&amp;quot;, len(values))
		case &amp;lt;-tm:
			fmt.Println(&amp;quot;bye&amp;quot;)
			return
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
