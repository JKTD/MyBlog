<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Bug on Fly With Bug</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 02 Apr 2018 18:30:28 CST</updated>
        
        <item>
            <title>Elasticsearch 入门</title>
            <link>http://blog.flywithme.top/2018/04/02/note_28/</link>
            <pubDate>Mon, 02 Apr 2018 18:30:28 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/04/02/note_28/</guid>
            <description>

&lt;h5 id=&#34;简介-为什么要使用elasticsearch&#34;&gt;简介 为什么要使用Elasticsearch&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、
 可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安装方便&lt;/strong&gt;： 没有其他依赖，下载后安装很方便，只需修改几个参数就可以搭建一个集群&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSON&lt;/strong&gt;: 输入\输出格式为JSON,不需要定义Schema,快捷方便&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESTful&lt;/strong&gt;：基本所有操作（索引，查询，甚至配置）都可以通过HTTP接口进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式&lt;/strong&gt;：节点对外表现对等（每个节点都可以用来做入口）；加入节点，自动均衡&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多租户&lt;/strong&gt;：可以根据不同的用途分索引；可以同时操作多个索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;准实时&lt;/strong&gt;：从文档索引到可以被检索只有轻微延时，约1s&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;上一节使用docker run elasticsearch&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;使用测试&#34;&gt;使用测试&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开idea -&amp;gt; tools -&amp;gt; testRESTful Web Service 工具&lt;/p&gt;

&lt;p&gt;&lt;image  src=&#34;sources/elasticsearch/1522668735966.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Docker 入门</title>
            <link>http://blog.flywithme.top/2018/04/02/note_27/</link>
            <pubDate>Mon, 02 Apr 2018 17:33:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/04/02/note_27/</guid>
            <description>

&lt;h5 id=&#34;什么是docker&#34;&gt;什么是Docker&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker是一个用来打包，装载和运行应用程序的一个轻量级容器的开源项目。
 它的工作方式非常像虚拟机，包裹所有的东西（文件系统，进程管理，环境变量等）
 在一个容器内。跟虚拟机有所不同，它是使用LXC（Linux kernel container）
 来替代虚拟层。 LXC没有自己的内核，但是与主机和其他容器一起共享Linux内核的。
 基于LXC，因此Docker是非常轻量级的，
 因此在运行应用程序的时候几乎没有性能损失。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;安装方式&#34;&gt;安装方式&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;brew install docker&lt;/li&gt;
&lt;li&gt;官网下载 Docker for mac 下载 &lt;a href=&#34;https://store.docker.com/editions/community/docker-ce-desktop-mac&#34;&gt;docker 下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;加速器-配置地址-http-www-daocloud-io-mirror-accelerator-doc&#34;&gt;加速器 &lt;a href=&#34;http://www.daocloud.io/mirror#accelerator-doc&#34;&gt;配置地址&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择对应的配置，按照提示，添加镜像地址
&lt;image  src=&#34;sources/docker/1522665847954.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看docker info
&lt;image  src=&#34;sources/docker/1522665979813.jpg&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行命令 &lt;code&gt;docker run hello-world&lt;/code&gt;  下载使用镜像&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动docker nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//把里面的端口映射到外面物理机的80端口
docker run -d -p 80:80 nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;docker run -d -p 9200:9200 nginx&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-3 多任务版爬虫</title>
            <link>http://blog.flywithme.top/2018/03/16/note_26/</link>
            <pubDate>Fri, 16 Mar 2018 16:02:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/16/note_26/</guid>
            <description>

&lt;h5 id=&#34;并发调度器&#34;&gt;并发调度器&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521197187281.jpg&#34;  /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//engine 
package engine

import (
	&amp;quot;log&amp;quot;
)

type ConcurrentEngine struct {
	Scheduler   Scheduler
	WorkerCount int
}

type Scheduler interface {
	ReadyNotifier
	Submit(Request)
	WorkerChan() chan Request
	Run()
}

type ReadyNotifier interface {
	WokerReady(chan Request)
}

func (e *ConcurrentEngine) Run(seeds ...Request) {
	out := make(chan ParseResult)
	e.Scheduler.Run()
	for i := 0; i &amp;lt; e.WorkerCount; i++ {
		createWorker(e.Scheduler.WorkerChan(), out, e.Scheduler)
	}

	for _, r := range seeds {
		e.Scheduler.Submit(r)
	}
	itemCount := 0
	for {
		result := &amp;lt;-out
		for _, item := range result.Items {
			itemCount++
			log.Printf(&amp;quot;Got item #%d: %v&amp;quot;, itemCount, item)
		}
		for _, request := range result.Requests {
			e.Scheduler.Submit(request)
		}
	}
}

func createWorker(in chan Request, out chan ParseResult, ready ReadyNotifier) {
	go func() {
		for {
			ready.WokerReady(in)
			request := &amp;lt;-in
			result, err := worker(request)
			if err != nil {
				continue
			}
			out &amp;lt;- result
		}
	}()
}

--------------------------------------
//scheduler queued

package scheduler

import (
	&amp;quot;imooc/craw/engine&amp;quot;
)

type QueuedScheduler struct {
	requestChan chan engine.Request
	workerChan  chan chan engine.Request
}

func (s *QueuedScheduler) WorkerChan() chan engine.Request {
	return make(chan engine.Request)
}

func (s *QueuedScheduler) Submit(r engine.Request) {
	s.requestChan &amp;lt;- r
}

func (s *QueuedScheduler) WokerReady(w chan engine.Request) {
	s.workerChan &amp;lt;- w
}

func (s *QueuedScheduler) Run() {
	s.workerChan = make(chan chan engine.Request)
	s.requestChan = make(chan engine.Request)
	go func() {
		var requestQ []engine.Request
		var workerQ []chan engine.Request
		for {
			var activeRequest engine.Request
			var activeWorker chan engine.Request
			if len(requestQ) &amp;gt; 0 &amp;amp;&amp;amp; len(workerQ) &amp;gt; 0 {
				activeWorker = workerQ[0]
				activeRequest = requestQ[0]
			}

			select {
			case r := &amp;lt;-s.requestChan:
				requestQ = append(requestQ, r)
			case w := &amp;lt;-s.workerChan:
				workerQ = append(workerQ, w)
			case activeWorker &amp;lt;- activeRequest:
				workerQ = workerQ[1:]
				requestQ = requestQ[1:]
			}
		}

	}()

}


&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-2 单任务版爬虫</title>
            <link>http://blog.flywithme.top/2018/03/14/note_25/</link>
            <pubDate>Wed, 14 Mar 2018 16:54:13 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/14/note_25/</guid>
            <description>

&lt;h5 id=&#34;总体的算法步骤&#34;&gt;总体的算法步骤&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521017696913.jpg&#34;  /&gt;&lt;/p&gt;

&lt;h5 id=&#34;解析器-parser&#34;&gt;解析器 Parser&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;输入： utf-8 编码的文本&lt;/li&gt;
&lt;li&gt;输出： Request{URL,对应的Parser} 列表，Item列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;单任务版爬虫架构&#34;&gt;单任务版爬虫架构&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1521018347601.jpg&#34;  /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;获取并打印所有城市第一页用户的详细信息

&lt;ul&gt;
&lt;li&gt;使用http.Get获取内容&lt;/li&gt;
&lt;li&gt;使用Encodeing来转换编码：gbk-&amp;gt;utf-8&lt;/li&gt;
&lt;li&gt;使用charset.DetermineEncoding来判断编码&lt;/li&gt;
&lt;li&gt;使用正则表达式筛选需要的内容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code &lt;a href=&#34;https://github.com/flywithbug/imooc/tree/release/0.0.1/craw&#34;&gt;单任务爬虫分支&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go: 14-1 爬虫实现</title>
            <link>http://blog.flywithme.top/2018/03/09/note_24/</link>
            <pubDate>Fri, 09 Mar 2018 16:05:38 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/09/note_24/</guid>
            <description>

&lt;h5 id=&#34;获取初始页面内容&#34;&gt;获取初始页面内容&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用相亲网站做目标&lt;/li&gt;
&lt;li&gt;编码格式自动识别转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;获取有价值信息&#34;&gt;获取有价值信息&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;获取城市名称和链接

&lt;ul&gt;
&lt;li&gt;使用css选择器&lt;/li&gt;
&lt;li&gt;使用xpath&lt;/li&gt;
&lt;li&gt;使用正则表达式
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net/http&amp;quot;

	&amp;quot;bufio&amp;quot;
	&amp;quot;io&amp;quot;

	&amp;quot;regexp&amp;quot;

	&amp;quot;golang.org/x/net/html/charset&amp;quot;
	&amp;quot;golang.org/x/text/encoding&amp;quot;
	&amp;quot;golang.org/x/text/transform&amp;quot;
)

//网站编码识别转换
func determineEncoder(r io.Reader) encoding.Encoding {
	bytes, err := bufio.NewReader(r).Peek(1024)
	if err != nil {
		panic(err)
	}
	e, _, _ := charset.DetermineEncoding(bytes, &amp;quot;&amp;quot;)
	return e
}

const regextstr = `&amp;lt;a href=&amp;quot;http://www.zhenai.com/zhenghun/[0-9a-z]+&amp;quot;[^&amp;gt;]*&amp;gt;[^&amp;lt;]+&amp;lt;/a&amp;gt;`

const regextstr1 = `&amp;lt;a href=&amp;quot;(http://www.zhenai.com/zhenghun/[0-9a-z]+)&amp;quot;[^&amp;gt;]*&amp;gt;([^&amp;lt;]+)&amp;lt;/a&amp;gt;`

func printCityList(contents []byte) {
	re := regexp.MustCompile(regextstr1)
	//matchs := re.FindAll(contents, -1)
	amtch := re.FindAllSubmatch(contents, -1)

	for _, m := range amtch {
		fmt.Printf(&amp;quot;%s\n %s \n&amp;quot;, m[1], m[2])
	}
}

func main() {
	resp, err := http.Get(&amp;quot;http://www.zhenai.com/zhenghun&amp;quot;)

	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Println(&amp;quot;Error: status code &amp;quot;, resp.StatusCode)
		return
	}
	e := determineEncoder(resp.Body)
	utf8Reader := transform.NewReader(resp.Body, e.NewDecoder())
	result, err := ioutil.ReadAll(utf8Reader)
	if err != nil {
		panic(err)
	}
	printCityList(result)
	//fmt.Printf(&amp;quot;%s\n&amp;quot;, result)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 13-1 爬虫简介</title>
            <link>http://blog.flywithme.top/2018/03/08/note_23/</link>
            <pubDate>Thu, 08 Mar 2018 17:13:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/08/note_23/</guid>
            <description>

&lt;h5 id=&#34;网络爬虫分类&#34;&gt;网络爬虫分类&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通用爬虫：如baidu,google&lt;/li&gt;
&lt;li&gt;聚焦爬虫：从互联网获取结构化数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;项目总体结构&#34;&gt;项目总体结构&lt;/h5&gt;

&lt;p&gt;&lt;image  src=&#34;sources/go/1517564741602.jpg&#34;  /&gt;&lt;/p&gt;

&lt;h5 id=&#34;go语言的爬虫库-框架&#34;&gt;go语言的爬虫库/框架&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;henrylee2cn/pholcus&lt;/li&gt;
&lt;li&gt;gocrawl&lt;/li&gt;
&lt;li&gt;colly&lt;/li&gt;
&lt;li&gt;hu17889/go_spider&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;重新开发一个爬虫库&#34;&gt;重新开发一个爬虫库&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;不适用现成的爬虫库/框架&lt;/li&gt;
&lt;li&gt;使用ElasticSearch作为数据存储&lt;/li&gt;
&lt;li&gt;使用Go语言标准模板库实现http数据展示部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;实现步骤&#34;&gt;实现步骤&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;单任务&lt;/li&gt;
&lt;li&gt;并发版&lt;/li&gt;
&lt;li&gt;分布式&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 12-1 迷宫的广度优先搜索</title>
            <link>http://blog.flywithme.top/2018/03/07/note_22/</link>
            <pubDate>Wed, 07 Mar 2018 17:21:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_22/</guid>
            <description>

&lt;h5 id=&#34;示例-广度优先算法&#34;&gt;示例：广度优先算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;为爬虫实战做准备&lt;/li&gt;
&lt;li&gt;应用广泛，综合性强&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;示例-广度优先搜索走迷宫&#34;&gt;示例：广度优先搜索走迷宫&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广度优先算法示意图&lt;br /&gt;
&lt;image  src=&#34;sources/go/1520162909021.gif&#34;  /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用循环创建二维slice&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用slice来实现队列&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用Fscanf读取文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对point的抽象&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//file
6 5
0 1 0 0 0
0 0 0 1 0
0 1 0 1 0
1 1 1 0 0
0 1 0 0 1
0 1 0 0 0


--------------- 
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func readMaze(filename string) [][]int {
	file, err := os.Open(filename)
	defer file.Close()
	if err != nil {
		panic(err)
	}
	var row, col int
	fmt.Fscanf(file, &amp;quot;%d %d&amp;quot;, &amp;amp;row, &amp;amp;col)
	maze := make([][]int, row)
	for i := range maze {
		maze[i] = make([]int, col)
		for j := range maze[i] {
			fmt.Fscanf(file, &amp;quot;%d&amp;quot;, &amp;amp;maze[i][j])
		}
	}
	return maze
}

type point struct {
	i, j int
}

var dirs = [4]point{
	{-1, 0}, {0, -1}, {1, 0}, {0, 1}}

func (p point) add(r point) point {
	return point{p.i + r.i, p.j + r.j}
}

func (p point) at(grid [][]int) (int, bool) {
	if p.i &amp;lt; 0 || p.i &amp;gt;= len(grid) {
		return 0, false
	}
	if p.j &amp;lt; 0 || p.j &amp;gt;= len(grid[p.i]) {
		return 0, false
	}
	return grid[p.i][p.j], true
}

func walk(maze [][]int, start, end point) [][]int {
	steps := make([][]int, len(maze))
	for i := range steps {
		steps[i] = make([]int, len(maze[i]))
	}
	Q := []point{start}
	for len(Q) &amp;gt; 0 {
		cur := Q[0]
		Q = Q[1:]
		if cur == end {
			break
		}
		for _, dir := range dirs {
			next := cur.add(dir)
			//maze att next is 0
			//and steps at next is 0
			//and next != start
			value, ok := next.at(maze)
			if !ok || value == 1 {
				continue
			}
			value, ok = next.at(steps)
			if !ok || value != 0 {
				continue
			}
			if next == start {
				continue
			}
			curSteps, _ := cur.at(steps)
			steps[next.i][next.j] = curSteps + 1
			Q = append(Q, next)
		}

	}
	return steps
}

func main() {
	maze := readMaze(&amp;quot;maze/maze.in&amp;quot;)
	for _, row := range maze {
		for _, val := range row {
			fmt.Printf(&amp;quot;%d &amp;quot;, val)
		}
		fmt.Println()
	}
	steps := walk(maze, point{0, 0}, point{len(maze) - 1, len(maze[0]) - 1})
	for _, row := range steps {
		for _, val := range row {
			fmt.Printf(&amp;quot;%3d &amp;quot;, val)
		}
		fmt.Println()
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 11-2 其他标准库</title>
            <link>http://blog.flywithme.top/2018/03/07/note_21/</link>
            <pubDate>Wed, 07 Mar 2018 16:54:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_21/</guid>
            <description>

&lt;h5 id=&#34;其他标准库&#34;&gt;其他标准库&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;bufio&lt;/li&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;li&gt;encoding/json&lt;/li&gt;
&lt;li&gt;regexp&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;stings/math/rand&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;查看库文档&#34;&gt;查看库文档&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;godoc -http :8888 (启用本地文档服务器)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://studygolang.com/pkgdoc&#34;&gt;https://studygolang.com/pkgdoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 11-1 http标准库</title>
            <link>http://blog.flywithme.top/2018/03/07/note_20/</link>
            <pubDate>Wed, 07 Mar 2018 13:24:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_20/</guid>
            <description>

&lt;h5 id=&#34;server&#34;&gt;Server&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, &amp;quot;Hello, world!&amp;quot;)
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, handler)
	http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;client&#34;&gt;Client&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用http客户端发送请求&lt;/li&gt;
&lt;li&gt;使用http.Client 控制请求头部等&lt;/li&gt;
&lt;li&gt;使用httputil简化工作
```
package main&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;import (
	&amp;ldquo;fmt&amp;rdquo;
	&amp;ldquo;net/http&amp;rdquo;
	&amp;ldquo;net/http/httputil&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;func main() {
	request, err := http.NewRequest(http.MethodGet, &amp;ldquo;&lt;a href=&#34;http://www.imooc.com&amp;quot;&#34;&gt;http://www.imooc.com&amp;quot;&lt;/a&gt;, nil)
	if err != nil {
		panic(err)
	}
	request.Header.Add(&amp;ldquo;User-Agent&amp;rdquo;, &amp;ldquo;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1&amp;rdquo;)
	client := http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			fmt.Println(&amp;ldquo;Redirect:&amp;ldquo;, req)
			return nil
		},
	}
	resp, err := client.Do(request)&lt;/p&gt;

&lt;p&gt;	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	s, err := httputil.DumpResponse(resp, true)
	if err != nil {
		panic(err)
	}
	fmt.Printf(&amp;ldquo;%s\n&amp;rdquo;, s)
}
```&lt;/p&gt;

&lt;h5 id=&#34;http服务器的性能分析&#34;&gt;http服务器的性能分析&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;import _ &amp;ldquo;net/http/pprof&amp;rdquo;&lt;/li&gt;
&lt;li&gt;访问/debug/pprof&lt;/li&gt;
&lt;li&gt;使用go tool pprof分析性能&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 10-2 传统同步机制</title>
            <link>http://blog.flywithme.top/2018/03/07/note_19/</link>
            <pubDate>Wed, 07 Mar 2018 11:53:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/07/note_19/</guid>
            <description>

&lt;h5 id=&#34;检测数据冲突&#34;&gt;检测数据冲突&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;未加锁时使用 go run -race atomic.go 时检测会发现数据访问冲突&lt;/li&gt;
&lt;li&gt;加锁之后 运行-race 数据访问冲突就没了&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;传统同步机制&#34;&gt;传统同步机制&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;WaitGroup
```
package main&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;import (
 	&amp;ldquo;fmt&amp;rdquo;
 	&amp;ldquo;sync&amp;rdquo;
 )&lt;/p&gt;

&lt;p&gt;func doWork(id int,
 	w worker) {
 	for n := range w.in {
 		fmt.Printf(&amp;ldquo;Worker %d received %c\n&amp;rdquo;,
 			id, n)
 		w.done()
 	}
 }&lt;/p&gt;

&lt;p&gt;type worker struct {
 	in   chan int
 	done func()
 }&lt;/p&gt;

&lt;p&gt;func createWorker(
 	id int, wg *sync.WaitGroup) worker {
 	w := worker{
 		in: make(chan int),
 		done: func() {
 			wg.Done()
 		},
 	}
 	go doWork(id, w)
 	return w
 }&lt;/p&gt;

&lt;p&gt;func chanDemo() {
 	var wg sync.WaitGroup&lt;/p&gt;

&lt;p&gt;	var workers [10]worker
 	for i := 0; i &amp;lt; 10; i++ {
 		workers[i] = createWorker(i, &amp;amp;wg)
 	}&lt;/p&gt;

&lt;p&gt;	wg.Add(20)
 	for i, worker := range workers {
 		worker.in &amp;lt;- &amp;lsquo;a&amp;rsquo; + i
 	}
 	for i, worker := range workers {
 		worker.in &amp;lt;- &amp;lsquo;A&amp;rsquo; + i
 	}&lt;/p&gt;

&lt;p&gt;	wg.Wait()
 }&lt;/p&gt;

&lt;p&gt;func main() {
 	chanDemo()
 }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  
  - Mutex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//加锁之前
package main&lt;/p&gt;

&lt;p&gt;import (
	&amp;ldquo;fmt&amp;rdquo;
	&amp;ldquo;time&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;type atomicInt int&lt;/p&gt;

&lt;p&gt;func (a *atomicInt) increment() {
	*a++
}&lt;/p&gt;

&lt;p&gt;func (a *atomicInt) get() int {
	return int(*a)
}&lt;/p&gt;

&lt;p&gt;func main() {
	var a atomicInt
	a.increment()
	go func() {
		a.increment()
	}()
	time.Sleep(time.Millisecond)
	fmt.Println(a)&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;}&lt;/h2&gt;

&lt;p&gt;//加锁之后
package main&lt;/p&gt;

&lt;p&gt;import (
	&amp;ldquo;fmt&amp;rdquo;
	&amp;ldquo;sync&amp;rdquo;
	&amp;ldquo;time&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;type atomicInt struct {
	value int
	lock  sync.Mutex
}&lt;/p&gt;

&lt;p&gt;func (a *atomicInt) increment() {
	a.lock.Lock()
	defer a.lock.Unlock()
	a.value++
}&lt;/p&gt;

&lt;p&gt;func (a *atomicInt) get() int {
	a.lock.Lock()
	defer a.lock.Unlock()
	return a.value
}&lt;/p&gt;

&lt;p&gt;func main() {
	var a atomicInt
	a.increment()
	go func() {
		a.increment()
	}()
	time.Sleep(time.Millisecond)
	fmt.Println(a.get())
}&lt;/p&gt;

&lt;p&gt;```
  - Cond&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go: 10-1 channel</title>
            <link>http://blog.flywithme.top/2018/03/04/note_18/</link>
            <pubDate>Sun, 04 Mar 2018 19:59:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/04/note_18/</guid>
            <description>

&lt;h5 id=&#34;channel的用法&#34;&gt;channel的用法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;channel&lt;/li&gt;
&lt;li&gt;buffered channel&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;li&gt;理论基础：Communication Sequential Process(CSP)&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t communicate by sharing memory;share memory by communicating(不要通过共享内存来通信，
通过通信来共享内存)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func worker(id int, c chan int) {
	for n := range c {
		fmt.Printf(&amp;quot;Worker %d received %c\n&amp;quot;,
			id, n)
	}
}

func createWorker(id int) chan&amp;lt;- int {
	c := make(chan int)
	go worker(id, c)
	return c
}

func chanDemo() {
	var channels [10]chan&amp;lt;- int
	for i := 0; i &amp;lt; 10; i++ {
		channels[i] = createWorker(i)
	}

	for i := 0; i &amp;lt; 10; i++ {
		channels[i] &amp;lt;- &#39;a&#39; + i
	}

	for i := 0; i &amp;lt; 10; i++ {
		channels[i] &amp;lt;- &#39;A&#39; + i
	}

	time.Sleep(time.Millisecond)
}

func bufferedChannel() {
	c := make(chan int, 3)
	go worker(0, c)
	c &amp;lt;- &#39;a&#39;
	c &amp;lt;- &#39;b&#39;
	c &amp;lt;- &#39;c&#39;
	c &amp;lt;- &#39;d&#39;
	time.Sleep(time.Millisecond)
}

func channelClose() {
	c := make(chan int)
	go worker(0, c)
	c &amp;lt;- &#39;a&#39;
	c &amp;lt;- &#39;b&#39;
	c &amp;lt;- &#39;c&#39;
	c &amp;lt;- &#39;d&#39;
	close(c)
	time.Sleep(time.Millisecond)
}

func main() {
	fmt.Println(&amp;quot;Channel as first-class citizen&amp;quot;)
	chanDemo()
	fmt.Println(&amp;quot;Buffered channel&amp;quot;)
	bufferedChannel()
	fmt.Println(&amp;quot;Channel close and range&amp;quot;)
	channelClose()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例-使用channel来等待goroutine-结束-waitgroup的使用&#34;&gt;示例： 使用channel来等待goroutine 结束 （waitGroup的使用）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;
)

func doWork(id int,
	w worker) {
	for n := range w.in {
		fmt.Printf(&amp;quot;Worker %d received %c\n&amp;quot;,
			id, n)
		w.done()
	}
}

type worker struct {
	in   chan int
	done func()
}

func createWorker(
	id int, wg *sync.WaitGroup) worker {
	w := worker{
		in: make(chan int),
		done: func() {
			wg.Done()
		},
	}
	go doWork(id, w)
	return w
}

func chanDemo() {
	var wg sync.WaitGroup

	var workers [10]worker
	for i := 0; i &amp;lt; 10; i++ {
		workers[i] = createWorker(i, &amp;amp;wg)
	}

	wg.Add(20)
	for i, worker := range workers {
		worker.in &amp;lt;- &#39;a&#39; + i
	}
	for i, worker := range workers {
		worker.in &amp;lt;- &#39;A&#39; + i
	}

	wg.Wait()
}

func main() {
	chanDemo()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例二-使用channel来实现叔的遍历&#34;&gt;示例二：使用channel来实现叔的遍历&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt; 
func (node *Node) TraverseFunc(f func(*Node)) {
	if node == nil {
		return
	}

	node.Left.TraverseFunc(f)
	f(node)
	node.Right.TraverseFunc(f)
}

func (node *Node) TraverseWithChannel() chan *Node {
	out := make(chan *Node)
	go func() {
		node.TraverseFunc(func(node *Node) {
			out &amp;lt;- node
		})
		close(out)
	}()
	return out
}


---------------------
	c := root.TraverseWithChannel()
	maxValue := 0
	for node := range c {
		if node.Value &amp;gt; maxValue {
			maxValue = node.Value
		}
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;示例三-使用select来进行调度&#34;&gt;示例三：使用Select来进行调度&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Select 的使用&lt;/li&gt;
&lt;li&gt;定时器的使用&lt;/li&gt;
&lt;li&gt;在select中可以使用Nil channel&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

func generator() chan int {
	out := make(chan int)
	go func() {
		i := 0
		for {
			time.Sleep(
				time.Duration(rand.Intn(1500)) *
					time.Millisecond)
			out &amp;lt;- i
			i++
		}
	}()
	return out
}

func worker(id int, c chan int) {
	for n := range c {
		time.Sleep(time.Second)
		fmt.Printf(&amp;quot;Worker %d received %d\n&amp;quot;,
			id, n)
	}
}

func createWorker(id int) chan&amp;lt;- int {
	c := make(chan int)
	go worker(id, c)
	return c
}

func main() {
	var c1, c2 = generator(), generator()
	var worker = createWorker(0)

	var values []int
	tm := time.After(10 * time.Second)
	tick := time.Tick(time.Second)
	for {
		var activeWorker chan&amp;lt;- int
		var activeValue int
		if len(values) &amp;gt; 0 {
			activeWorker = worker
			activeValue = values[0]
		}

		select {
		case n := &amp;lt;-c1:
			values = append(values, n)
		case n := &amp;lt;-c2:
			values = append(values, n)
		case activeWorker &amp;lt;- activeValue:
			values = values[1:]

		case &amp;lt;-time.After(800 * time.Millisecond):
			fmt.Println(&amp;quot;timeout&amp;quot;)
		case &amp;lt;-tick:
			fmt.Println(
				&amp;quot;queue len =&amp;quot;, len(values))
		case &amp;lt;-tm:
			fmt.Println(&amp;quot;bye&amp;quot;)
			return
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 9-1 goroutine 并发编程</title>
            <link>http://blog.flywithme.top/2018/03/04/note_17/</link>
            <pubDate>Sun, 04 Mar 2018 18:02:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/04/note_17/</guid>
            <description>

&lt;h5 id=&#34;示例&#34;&gt;示例&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	for i := 0; i &amp;lt; 1000; i++ {
		go func(i int) {
			for {
				fmt.Printf(&amp;quot;Hello form goroutine %d \n&amp;quot;, i)
			}
		}(i)
	}
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;协程-coroutine&#34;&gt;协程 Coroutine&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;轻量级&amp;rdquo;线程&amp;rdquo;&lt;/li&gt;
&lt;li&gt;非抢占式多任务处理，由协程主动交出控制权 （runtime.Gosched()）
&lt;code&gt;
func main() {
	var a [10]int
	for i := 0; i &amp;lt; 10; i++ {
		go func(i int) {
			for {
				//fmt.Printf(&amp;quot;Hello form goroutine %d \n&amp;quot;, i)
				a[i]++
				runtime.Gosched() //交出控制权
			}
		}(i)
	}
	time.Sleep(time.Second)
	fmt.Println(a)
}
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译器/解释器/虚拟机层面的多任务&lt;/li&gt;
&lt;li&gt;多个协程可能在一个或多个线程上运行&lt;/li&gt;
&lt;li&gt;子程序是协程的一个特例
&lt;img src=&#34;sources/go/1520161869947.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;其他语言的协程&#34;&gt;其他语言的协程&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;C++ :Boost.Coroutine&lt;/li&gt;
&lt;li&gt;Java:原生不支持，第三方的有支持&lt;/li&gt;
&lt;li&gt;Python 3.5之前使用yield关键字实现协程。 3.5之后加入了async def对协程原生支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;goroutine的调度器&#34;&gt;goroutine的调度器&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1520162129021.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;goroutine的定义&#34;&gt;goroutine的定义&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;任何函数只需要加上go就能送给调度器运行&lt;/li&gt;
&lt;li&gt;不需要再定义时区分是否异步函数&lt;/li&gt;
&lt;li&gt;调度器会在合适的点进行切换&lt;/li&gt;
&lt;li&gt;使用 -race来检测数据访问的冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;goroutine可能的切换点&#34;&gt;goroutine可能的切换点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;I/O,select&lt;/li&gt;
&lt;li&gt;channel&lt;/li&gt;
&lt;li&gt;等待锁&lt;/li&gt;
&lt;li&gt;函数调用（有时）&lt;/li&gt;
&lt;li&gt;runtime.Gosched()&lt;/li&gt;
&lt;li&gt;只是参考，不能保证切换，不能保证在其他地方不切换&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 8-2 生成文档和示例代码</title>
            <link>http://blog.flywithme.top/2018/03/04/note_16/</link>
            <pubDate>Sun, 04 Mar 2018 13:05:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/04/note_16/</guid>
            <description>

&lt;h5 id=&#34;文档&#34;&gt;文档&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;用注释写文档&lt;/li&gt;
&lt;li&gt;在测试中加入Example&lt;/li&gt;
&lt;li&gt;使用go doc/godoc 生成文档&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-//queue.go&#34;&gt;package queue

import (
	&amp;quot;fmt&amp;quot;
)

//A FIFO queue.
type Queue []interface{}

func (q *Queue) Push(v int) {
	fmt.Println(q)

	*q = append(*q, v)

}

// Pops element from head.
func (q *Queue) Pop() int {
	head := (*q)[0]
	*q = (*q)[1:]
	return head.(int)
}

// Returns if the queue is empty or not.
func (q *Queue) IsEmpty() bool {
	return len(*q) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-queue_test.go&#34;&gt;package queue

import &amp;quot;fmt&amp;quot;

func ExampleQueue_Pop() {
	q := Queue{1}
	q.Push(2)
	q.Push(3)
	fmt.Println(q.Pop())
	fmt.Println(q.Pop())
	fmt.Println(q.IsEmpty())

	fmt.Println(q.Pop())
	fmt.Println(q.IsEmpty())

	// Output:
	// &amp;amp;[1]
	// &amp;amp;[1 2]
	// 1
	// 2
	// false
	// 3
	// true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。

一般用法：
go doc package 获取包的文档注释，例如：go doc fmt 会显示使用 godoc 生成的 fmt 包的文档注释。
go doc package/subpackage 获取子包的文档注释，例如：go doc container/list。
go doc package function 获取某个函数在某个包中的文档注释，例如：go doc fmt Printf 会显示有关 fmt.Printf() 的使用说明。
在命令行输入 godoc -http=:6060，然后使用浏览器打开 http://localhost:6060 后，你就可以看到本地文档浏览服务器提供的页面。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;测试总结&#34;&gt;测试总结&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;表格驱动测试&lt;/li&gt;
&lt;li&gt;代码覆盖率&lt;/li&gt;
&lt;li&gt;性能优化工具&lt;/li&gt;
&lt;li&gt;http测试&lt;/li&gt;
&lt;li&gt;文档以及示例代码&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 8-1 测试http服务器</title>
            <link>http://blog.flywithme.top/2018/03/02/note_15/</link>
            <pubDate>Fri, 02 Mar 2018 15:57:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/02/note_15/</guid>
            <description>

&lt;h5 id=&#34;针对7-2章节中的errorwapper的测试-示例代码在-imooc-errorhandler&#34;&gt;针对7-2章节中的errorWapper的测试 （示例代码在 imooc/errorHandler）&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通过虚拟Request/Response来测试 （TestErrWrapper）&lt;/li&gt;
&lt;li&gt;通过启服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//errorWapper
func errorWrapper(handlerrr appHandler) func(w http.ResponseWriter, r *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		defer func() {
			r := recover()
			if r != nil {
				log.Printf(&amp;quot;Panic:%v&amp;quot;, r)
				http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()
		err := handlerrr(writer, request)
		if err != nil {
			log.Printf(&amp;quot;Error handling request: %s&amp;quot;, err.Error())
			if userErr, ok := err.(userError); ok {
				http.Error(writer, userErr.Message(), http.StatusBadRequest)
				return
			}

			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
func errPanic(_ http.ResponseWriter,
	_ *http.Request) error {
	panic(123)
}

type testingUserError string

func (e testingUserError) Error() string {
	return e.Message()
}

func (e testingUserError) Message() string {
	return string(e)
}

func errUserError(_ http.ResponseWriter,
	_ *http.Request) error {
	return testingUserError(&amp;quot;user error&amp;quot;)
}

func errNotFound(_ http.ResponseWriter,
	_ *http.Request) error {
	return os.ErrNotExist
}

func errNoPermission(_ http.ResponseWriter,
	_ *http.Request) error {
	return os.ErrPermission
}

func errUnknown(_ http.ResponseWriter,
	_ *http.Request) error {
	return errors.New(&amp;quot;unknown error&amp;quot;)
}

func noError(writer http.ResponseWriter,
	_ *http.Request) error {
	fmt.Fprintln(writer, &amp;quot;no error&amp;quot;)
	return nil
}

var tests = []struct {
	h       appHandler
	code    int
	message string
}{
	{errPanic, 500, &amp;quot;Internal Server Error&amp;quot;},
	{errUserError, 400, &amp;quot;user error&amp;quot;},
	{errNotFound, 404, &amp;quot;Not Found&amp;quot;},
	{errNoPermission, 403, &amp;quot;Forbidden&amp;quot;},
	{errUnknown, 500, &amp;quot;Internal Server Error&amp;quot;},
	{noError, 200, &amp;quot;no error&amp;quot;},
}

func TestErrWrapper(t *testing.T) {
	for _, tt := range tests {
		f := errorWrapper(tt.h)
		response := httptest.NewRecorder()
		request := httptest.NewRequest(
			http.MethodGet,
			&amp;quot;http://www.imooc.com&amp;quot;, nil)
		f(response, request)

		verifyResponse(response.Result(),
			tt.code, tt.message, t)
	}
}

func TestErrWrapperInServer(t *testing.T) {
	for _, tt := range tests {
		f := errorWrapper(tt.h)
		server := httptest.NewServer(
			http.HandlerFunc(f))
		resp, _ := http.Get(server.URL)

		verifyResponse(
			resp, tt.code, tt.message, t)
	}
}

func verifyResponse(resp *http.Response,
	expectedCode int, expectedMsg string,
	t *testing.T) {
	b, _ := ioutil.ReadAll(resp.Body)
	body := strings.Trim(string(b), &amp;quot;\n&amp;quot;)
	if resp.StatusCode != expectedCode ||
		body != expectedMsg {
		t.Errorf(&amp;quot;expect (%d, %s); &amp;quot;+
			&amp;quot;got (%d, %s)&amp;quot;,
			expectedCode, expectedMsg,
			resp.StatusCode, body)
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 8-1 测试</title>
            <link>http://blog.flywithme.top/2018/03/01/note_14/</link>
            <pubDate>Thu, 01 Mar 2018 16:01:31 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/01/note_14/</guid>
            <description>

&lt;h5 id=&#34;传统测试&#34;&gt;传统测试&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;测试数据和测试逻辑混在一起&lt;/li&gt;
&lt;li&gt;出错信息不明确&lt;/li&gt;
&lt;li&gt;一旦一个数据出错，测试全部结束
&lt;code&gt;
@Test public void testAdd(){
    assertEquals(3,add(1,2));
    assertEquals(2,add(0,2));
    assertEquals(0,add(0,0));
    assertEquals(0,add(1,-1));
    assertEquals(Integer.MIN_VALUE,add(1,Integer.MAX_VALUE));
}
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;表格驱动测试&#34;&gt;表格驱动测试&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;分离了测试数据和测试逻辑&lt;/li&gt;
&lt;li&gt;明确的出错信息&lt;/li&gt;
&lt;li&gt;可以部分失败&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;tests := []struct{
    a,b,c int32
}{
    {1,2,3},
    {0,2,2},
    {0,0,0},
    {-1,1,0},
    {Integer.MaxInt32,1,Integer.MinInt32},
}
for _,test := range tests{
    if actual := add(test.a,test.b);actual != text.c{
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;测试代码覆盖率和性能测试&#34;&gt;测试代码覆盖率和性能测试&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
func lengthOfNonRepeatingSubStr(s string) int {
	lastOccurred := make(map[rune]int)
	start := 0
	maxLength := 0

	for i, ch := range []rune(s) {
		if lastI, ok := lastOccurred[ch]; ok &amp;amp;&amp;amp; lastI &amp;gt;= start {
			start = lastI + 1
		}
		if i-start+1 &amp;gt; maxLength {
			maxLength = i - start + 1
		}
		lastOccurred[ch] = i
	}

	return maxLength
}
------------------------------------------------------------

//在package目录下 执行命令 可以执行当前包下的所有测试用例
go test .

//测试代码覆盖率
go test -coverprofile=c.out


func TestSubstr(t *testing.T) {
	tests := []struct {
		s   string
		ans int
	}{
		// Normal cases
		{&amp;quot;abcabcbb&amp;quot;, 3},
		{&amp;quot;pwwkew&amp;quot;, 4},

		// Edge cases
		{&amp;quot;&amp;quot;, 0},
		{&amp;quot;b&amp;quot;, 1},
		{&amp;quot;bbbbbbbbb&amp;quot;, 1},
		{&amp;quot;abcabcabcd&amp;quot;, 4},

		// Chinese support
		{&amp;quot;这里是慕课网&amp;quot;, 6},
		{&amp;quot;一二三二一&amp;quot;, 3},
		{&amp;quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&amp;quot;, 9},
	}
	for _, tt := range tests {
		actual := lengthOfNonRepeatingSubStr(tt.s)
		if actual != tt.ans {
			t.Errorf(&amp;quot;got %d for input %s; &amp;quot;+
				&amp;quot;expected %d&amp;quot;,
				actual, tt.s, tt.ans)
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;//性能测试
go test -bench .
func BenchmarkSubstr(b *testing.B) {
	s := &amp;quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&amp;quot;
	for i := 0; i &amp;lt; 13; i++ {
		s = s + s
	}
	b.Logf(&amp;quot;len(s) = %d&amp;quot;, len(s))
	ans := 9
	b.ResetTimer()

	for i := 0; i &amp;lt; b.N; i++ {
		actual := lengthOfNonRepeatingSubStr(s)
		if actual != ans {
			b.Errorf(&amp;quot;got %d for input %s; &amp;quot;+
				&amp;quot;expected %d&amp;quot;,
				actual, s, ans)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用pprof进行性能调优&#34;&gt;使用pprof进行性能调优&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//生成cpu.out 二进制文件，无法直接查看
go test -bench . -cpuprofile cpu.out 
//可以使用
go tool pprof cpu.out 
//进入pprof 工具命令行解码

$ go tool pprof cpu.out 
Type: cpu
Time: Mar 2, 2018 at 12:06pm (CST)
Duration: 2.52s, Total samples = 2.09s (83.09%)
Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)
(pprof) web  // 若没有安装graphviz 需要 安装 brew install graphviz  

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;调优流程
&lt;img src=&#34;sources/go/1519977293908.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//打开web页面
&lt;img src=&#34;sources/go/1519975114264.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
