<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sun, 04 Mar 2018 13:05:35 CST</updated>
        
        <item>
            <title>Go: 8-2 生成文档和示例代码</title>
            <link>http://blog.flywithme.top/2018/03/04/note_16/</link>
            <pubDate>Sun, 04 Mar 2018 13:05:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/04/note_16/</guid>
            <description>

&lt;h5 id=&#34;文档&#34;&gt;文档&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;用注释写文档&lt;/li&gt;
&lt;li&gt;在测试中加入Example&lt;/li&gt;
&lt;li&gt;使用go doc/godoc 生成文档&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-//queue.go&#34;&gt;package queue

import (
	&amp;quot;fmt&amp;quot;
)

//A FIFO queue.
type Queue []interface{}

func (q *Queue) Push(v int) {
	fmt.Println(q)

	*q = append(*q, v)

}

// Pops element from head.
func (q *Queue) Pop() int {
	head := (*q)[0]
	*q = (*q)[1:]
	return head.(int)
}

// Returns if the queue is empty or not.
func (q *Queue) IsEmpty() bool {
	return len(*q) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-queue_test.go&#34;&gt;package queue

import &amp;quot;fmt&amp;quot;

func ExampleQueue_Pop() {
	q := Queue{1}
	q.Push(2)
	q.Push(3)
	fmt.Println(q.Pop())
	fmt.Println(q.Pop())
	fmt.Println(q.IsEmpty())

	fmt.Println(q.Pop())
	fmt.Println(q.IsEmpty())

	// Output:
	// &amp;amp;[1]
	// &amp;amp;[1 2]
	// 1
	// 2
	// false
	// 3
	// true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。

一般用法：
go doc package 获取包的文档注释，例如：go doc fmt 会显示使用 godoc 生成的 fmt 包的文档注释。
go doc package/subpackage 获取子包的文档注释，例如：go doc container/list。
go doc package function 获取某个函数在某个包中的文档注释，例如：go doc fmt Printf 会显示有关 fmt.Printf() 的使用说明。
在命令行输入 godoc -http=:6060，然后使用浏览器打开 http://localhost:6060 后，你就可以看到本地文档浏览服务器提供的页面。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;测试总结&#34;&gt;测试总结&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;表格驱动测试&lt;/li&gt;
&lt;li&gt;代码覆盖率&lt;/li&gt;
&lt;li&gt;性能优化工具&lt;/li&gt;
&lt;li&gt;http测试&lt;/li&gt;
&lt;li&gt;文档以及示例代码&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 8-1 测试http服务器</title>
            <link>http://blog.flywithme.top/2018/03/02/note_15/</link>
            <pubDate>Fri, 02 Mar 2018 15:57:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/02/note_15/</guid>
            <description>

&lt;h5 id=&#34;针对7-2章节中的errorwapper的测试-示例代码在-imooc-errorhandler&#34;&gt;针对7-2章节中的errorWapper的测试 （示例代码在 imooc/errorHandler）&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通过虚拟Request/Response来测试 （TestErrWrapper）&lt;/li&gt;
&lt;li&gt;通过启服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//errorWapper
func errorWrapper(handlerrr appHandler) func(w http.ResponseWriter, r *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		defer func() {
			r := recover()
			if r != nil {
				log.Printf(&amp;quot;Panic:%v&amp;quot;, r)
				http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()
		err := handlerrr(writer, request)
		if err != nil {
			log.Printf(&amp;quot;Error handling request: %s&amp;quot;, err.Error())
			if userErr, ok := err.(userError); ok {
				http.Error(writer, userErr.Message(), http.StatusBadRequest)
				return
			}

			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
func errPanic(_ http.ResponseWriter,
	_ *http.Request) error {
	panic(123)
}

type testingUserError string

func (e testingUserError) Error() string {
	return e.Message()
}

func (e testingUserError) Message() string {
	return string(e)
}

func errUserError(_ http.ResponseWriter,
	_ *http.Request) error {
	return testingUserError(&amp;quot;user error&amp;quot;)
}

func errNotFound(_ http.ResponseWriter,
	_ *http.Request) error {
	return os.ErrNotExist
}

func errNoPermission(_ http.ResponseWriter,
	_ *http.Request) error {
	return os.ErrPermission
}

func errUnknown(_ http.ResponseWriter,
	_ *http.Request) error {
	return errors.New(&amp;quot;unknown error&amp;quot;)
}

func noError(writer http.ResponseWriter,
	_ *http.Request) error {
	fmt.Fprintln(writer, &amp;quot;no error&amp;quot;)
	return nil
}

var tests = []struct {
	h       appHandler
	code    int
	message string
}{
	{errPanic, 500, &amp;quot;Internal Server Error&amp;quot;},
	{errUserError, 400, &amp;quot;user error&amp;quot;},
	{errNotFound, 404, &amp;quot;Not Found&amp;quot;},
	{errNoPermission, 403, &amp;quot;Forbidden&amp;quot;},
	{errUnknown, 500, &amp;quot;Internal Server Error&amp;quot;},
	{noError, 200, &amp;quot;no error&amp;quot;},
}

func TestErrWrapper(t *testing.T) {
	for _, tt := range tests {
		f := errorWrapper(tt.h)
		response := httptest.NewRecorder()
		request := httptest.NewRequest(
			http.MethodGet,
			&amp;quot;http://www.imooc.com&amp;quot;, nil)
		f(response, request)

		verifyResponse(response.Result(),
			tt.code, tt.message, t)
	}
}

func TestErrWrapperInServer(t *testing.T) {
	for _, tt := range tests {
		f := errorWrapper(tt.h)
		server := httptest.NewServer(
			http.HandlerFunc(f))
		resp, _ := http.Get(server.URL)

		verifyResponse(
			resp, tt.code, tt.message, t)
	}
}

func verifyResponse(resp *http.Response,
	expectedCode int, expectedMsg string,
	t *testing.T) {
	b, _ := ioutil.ReadAll(resp.Body)
	body := strings.Trim(string(b), &amp;quot;\n&amp;quot;)
	if resp.StatusCode != expectedCode ||
		body != expectedMsg {
		t.Errorf(&amp;quot;expect (%d, %s); &amp;quot;+
			&amp;quot;got (%d, %s)&amp;quot;,
			expectedCode, expectedMsg,
			resp.StatusCode, body)
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 8-1 测试</title>
            <link>http://blog.flywithme.top/2018/03/01/note_14/</link>
            <pubDate>Thu, 01 Mar 2018 16:01:31 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/03/01/note_14/</guid>
            <description>

&lt;h5 id=&#34;传统测试&#34;&gt;传统测试&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;测试数据和测试逻辑混在一起&lt;/li&gt;
&lt;li&gt;出错信息不明确&lt;/li&gt;
&lt;li&gt;一旦一个数据出错，测试全部结束
&lt;code&gt;
@Test public void testAdd(){
    assertEquals(3,add(1,2));
    assertEquals(2,add(0,2));
    assertEquals(0,add(0,0));
    assertEquals(0,add(1,-1));
    assertEquals(Integer.MIN_VALUE,add(1,Integer.MAX_VALUE));
}
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;表格驱动测试&#34;&gt;表格驱动测试&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;分离了测试数据和测试逻辑&lt;/li&gt;
&lt;li&gt;明确的出错信息&lt;/li&gt;
&lt;li&gt;可以部分失败&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;tests := []struct{
    a,b,c int32
}{
    {1,2,3},
    {0,2,2},
    {0,0,0},
    {-1,1,0},
    {Integer.MaxInt32,1,Integer.MinInt32},
}
for _,test := range tests{
    if actual := add(test.a,test.b);actual != text.c{
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;测试代码覆盖率和性能测试&#34;&gt;测试代码覆盖率和性能测试&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;
func lengthOfNonRepeatingSubStr(s string) int {
	lastOccurred := make(map[rune]int)
	start := 0
	maxLength := 0

	for i, ch := range []rune(s) {
		if lastI, ok := lastOccurred[ch]; ok &amp;amp;&amp;amp; lastI &amp;gt;= start {
			start = lastI + 1
		}
		if i-start+1 &amp;gt; maxLength {
			maxLength = i - start + 1
		}
		lastOccurred[ch] = i
	}

	return maxLength
}
------------------------------------------------------------

//在package目录下 执行命令 可以执行当前包下的所有测试用例
go test .

//测试代码覆盖率
go test -coverprofile=c.out


func TestSubstr(t *testing.T) {
	tests := []struct {
		s   string
		ans int
	}{
		// Normal cases
		{&amp;quot;abcabcbb&amp;quot;, 3},
		{&amp;quot;pwwkew&amp;quot;, 4},

		// Edge cases
		{&amp;quot;&amp;quot;, 0},
		{&amp;quot;b&amp;quot;, 1},
		{&amp;quot;bbbbbbbbb&amp;quot;, 1},
		{&amp;quot;abcabcabcd&amp;quot;, 4},

		// Chinese support
		{&amp;quot;这里是慕课网&amp;quot;, 6},
		{&amp;quot;一二三二一&amp;quot;, 3},
		{&amp;quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&amp;quot;, 9},
	}
	for _, tt := range tests {
		actual := lengthOfNonRepeatingSubStr(tt.s)
		if actual != tt.ans {
			t.Errorf(&amp;quot;got %d for input %s; &amp;quot;+
				&amp;quot;expected %d&amp;quot;,
				actual, tt.s, tt.ans)
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;//性能测试
go test -bench .
func BenchmarkSubstr(b *testing.B) {
	s := &amp;quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&amp;quot;
	for i := 0; i &amp;lt; 13; i++ {
		s = s + s
	}
	b.Logf(&amp;quot;len(s) = %d&amp;quot;, len(s))
	ans := 9
	b.ResetTimer()

	for i := 0; i &amp;lt; b.N; i++ {
		actual := lengthOfNonRepeatingSubStr(s)
		if actual != ans {
			b.Errorf(&amp;quot;got %d for input %s; &amp;quot;+
				&amp;quot;expected %d&amp;quot;,
				actual, s, ans)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用pprof进行性能调优&#34;&gt;使用pprof进行性能调优&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//生成cpu.out 二进制文件，无法直接查看
go test -bench . -cpuprofile cpu.out 
//可以使用
go tool pprof cpu.out 
//进入pprof 工具命令行解码

$ go tool pprof cpu.out 
Type: cpu
Time: Mar 2, 2018 at 12:06pm (CST)
Duration: 2.52s, Total samples = 2.09s (83.09%)
Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)
(pprof) web  // 若没有安装graphviz 需要 安装 brew install graphviz  

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;调优流程
&lt;img src=&#34;sources/go/1519977293908.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//打开web页面
&lt;img src=&#34;sources/go/1519975114264.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go: 7-2 服务器统一出错处理</title>
            <link>http://blog.flywithme.top/2018/02/24/note_13/</link>
            <pubDate>Sat, 24 Feb 2018 17:43:08 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/24/note_13/</guid>
            <description>

&lt;h5 id=&#34;如何实现统一的错误处理逻辑-error部分&#34;&gt;如何实现统一的错误处理逻辑 Error部分&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;在业务部分只处理正确的返回，error部分返回给调用部分&lt;/li&gt;
&lt;li&gt;在函数输入部分做一个包装，然后再输出一个函数，同时处理输入函数的错误部分&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
func HandleFileList(writer http.ResponseWriter, request *http.Request) error {
	path := request.URL.Path[len(&amp;quot;/list/&amp;quot;):]
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()
	all, err := ioutil.ReadAll(file)
	if err != nil {
		return err
	}
	writer.Write(all)
	return nil
}

----------------------------------
type appHandler func(writer http.ResponseWriter, request *http.Request) error

func errorWrapper(handlerrr appHandler) func(w http.ResponseWriter, r *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		err := handlerrr(writer, request)
		if err != nil {
			logs.Warn(&amp;quot;Error handling request: %s&amp;quot;, err.Error())
			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}

	}
}

func main() {
	http.HandleFunc(&amp;quot;/list/&amp;quot;, errorWrapper(handler.HandleFileList))
	err := http.ListenAndServe(&amp;quot;:8888&amp;quot;, nil)
	if err != nil {
		panic(err)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;panic-recover&#34;&gt;panic &amp;amp; recover&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;停止当前函数执行&lt;/li&gt;
&lt;li&gt;一直向上返回，执行每一层的defer&lt;/li&gt;
&lt;li&gt;如果没有遇到recover，程序退出&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;recover&#34;&gt;recover&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;仅在defer中调用&lt;/li&gt;
&lt;li&gt;获取panic值&lt;/li&gt;
&lt;li&gt;如果无法处理，可重新panic&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
func tryRecover() {
	defer func() {
		r := recover()
		if err, ok := r.(error); ok {
			log.Println(&amp;quot;Error occured:&amp;quot;, err)
		} else {
			panic(r)
		}
	}()

	//panic(errors.New(&amp;quot;this is an error&amp;quot;))
	b := 0
	a := 5 / b
	fmt.Println(a)

}

func main() {
	tryRecover()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;error-vs-panic&#34;&gt;error vs panic&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;意料之中的：使用error.如文件出错，主动错误判断等可以预料到的错误&lt;/li&gt;
&lt;li&gt;意料之外的：使用panic.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;错误处理的综合示例&#34;&gt;错误处理的综合示例&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;defer + panic + recover&lt;/li&gt;
&lt;li&gt;Type Assertion&lt;/li&gt;
&lt;li&gt;函数式编程应用&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;type appHandler func(writer http.ResponseWriter, request *http.Request) error
type userError interface {
	error
	Message() string
}

func errorWrapper(handlerrr appHandler) func(w http.ResponseWriter, r *http.Request) {
	return func(writer http.ResponseWriter, request *http.Request) {
		defer func() {
			r := recover()
			if r != nil {
				log.Printf(&amp;quot;Panic:%v&amp;quot;, r)
				http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			}
		}()
		err := handlerrr(writer, request)
		if err != nil {
			log.Printf(&amp;quot;Error handling request: %s&amp;quot;, err.Error())
			if userErr, ok := err.(userError); ok {
				http.Error(writer, userErr.Message(), http.StatusBadRequest)
				return
			}

			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(writer, http.StatusText(code), code)
		}

	}
}
---------------------------------------------------------

const prefix = &amp;quot;/list/&amp;quot;

func HandleFileList(writer http.ResponseWriter, request *http.Request) error {
	fmt.Println(request.URL.Path)
	if !strings.HasPrefix(request.URL.Path, prefix) {
		return userError(fmt.Sprintf(&amp;quot;path %s must start with %s&amp;quot;, request.URL.Path, prefix))
	}
	path := request.URL.Path[len(&amp;quot;/list/&amp;quot;):]
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()
	all, err := ioutil.ReadAll(file)
	if err != nil {
		return err
	}
	writer.Write(all)
	return nil
}

type userError string

func (e userError) Error() string {
	return e.Message()
}
func (e userError) Message() string {
	return string(e)
}


&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 7-1 资源管理与出错处理</title>
            <link>http://blog.flywithme.top/2018/02/24/note_12/</link>
            <pubDate>Sat, 24 Feb 2018 17:06:34 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/24/note_12/</guid>
            <description>

&lt;h5 id=&#34;defer的调用&#34;&gt;defer的调用&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;确保调用在函数结束时发生 (Open/Close,Lock/Unlock,PrintHeader/PrintFooter)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func a() int {
defer b()
return 0
}
//b 的执行是发生在 return 0 之后，注意 defer 的语法，关键字 defer 之后是函数的调用。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;defer 的作用就是把关键字之后的函数执行压入一个栈中延迟执行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个 defer 的执行顺序是后进先出 LIFO&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defer func() { fmt.Println(&amp;quot;1&amp;quot;) }()
defer func() { fmt.Println(&amp;quot;2&amp;quot;) }()
defer func() { fmt.Println(&amp;quot;3&amp;quot;) }()
//输出顺序是 321
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常用在函数调用结束之后清理相关的资源&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行 recover&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;被 deferred 函数的参数在 defer 时确定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func a() {
	i := 0
	defer fmt.Println(i)
	i++
	return
}
//a 执行输出的是 0 而不是 1，因为 defer 时，i 的值是 0，
//此时被 defer 的函数参数已经进行执行计算并确定了
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;被 defer 的函数可以读取和修改带名称的返回值
```
func c() (i int) {
defer func() { i++ }()
return 1
}
//被 defer 的函数是在 return 之后执行，可以修改带名称的返回值，上面的函数 c 返回的是 2。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; 
 ##### Error处理
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
 	&amp;ldquo;fmt&amp;rdquo;
 	&amp;ldquo;os&amp;rdquo;&lt;/p&gt;

&lt;p&gt;	&amp;ldquo;bufio&amp;rdquo;&lt;/p&gt;

&lt;p&gt;	&amp;ldquo;imooc/function/fib&amp;rdquo;
 )&lt;/p&gt;

&lt;p&gt;func tryDefer() {
 	for i := 0; i &amp;lt; 100; i++ {
 		defer fmt.Println(i)
 		if i == 30 {
 			// Uncomment panic to see
 			// how it works with defer
 			// panic(&amp;ldquo;printed too many&amp;rdquo;)
 		}
 	}
 }&lt;/p&gt;

&lt;p&gt;func writeFile(filename string) {
 	file, err := os.OpenFile(filename,
 		os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666)
    //错误处理
 	if err != nil {
 		if pathError, ok := err.(*os.PathError); !ok {
 			panic(err)
 		} else {
 			fmt.Printf(&amp;ldquo;%s, %s, %s\n&amp;rdquo;,
 				pathError.Op,
 				pathError.Path,
 				pathError.Err)
 		}
 		return
 	}
 	defer file.Close()&lt;/p&gt;

&lt;p&gt;	writer := bufio.NewWriter(file)
 	defer writer.Flush()&lt;/p&gt;

&lt;p&gt;	f := fib.Fibonacci()
 	for i := 0; i &amp;lt; 20; i++ {
 		fmt.Fprintln(writer, f())
 	}
 }&lt;/p&gt;

&lt;p&gt;func main() {
 	tryDefer()
 	writeFile(&amp;ldquo;fib1.txt&amp;rdquo;)
 }
 ```&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go: 6-2 函数式编程</title>
            <link>http://blog.flywithme.top/2018/02/24/note_11/</link>
            <pubDate>Sat, 24 Feb 2018 14:35:09 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/24/note_11/</guid>
            <description>

&lt;h5 id=&#34;go语言闭包的应用&#34;&gt;go语言闭包的应用&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;更为自然，不需要修饰如何访问自由变量&lt;/li&gt;
&lt;li&gt;没有Lambda表达式，但是有匿名函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package fib
//斐波那契数列 
// 1, 1, 2, 3, 5, 8, 13, ...
func Fibonacci() func() int {
	a, b := 0, 1
	return func() int {
		a, b = b, a+b
		return a
	}
}

---------------------------------------------

package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;strings&amp;quot;

	&amp;quot;imooc/fib&amp;quot;
)

//为函数实现接口
type intGen func() int

func (g intGen) Read(
	p []byte) (n int, err error) {
	next := g()
	if next &amp;gt; 10000 {
		return 0, io.EOF
	}
	s := fmt.Sprintf(&amp;quot;%d\n&amp;quot;, next)

	return strings.NewReader(s).Read(p)
}

func printFileContents(reader io.Reader) {
	scanner := bufio.NewScanner(reader)

	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
}

func main() {
	var f intGen = fib.Fibonacci()
	printFileContents(f)
}



&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 6-1 函数式编程</title>
            <link>http://blog.flywithme.top/2018/02/12/note_10/</link>
            <pubDate>Mon, 12 Feb 2018 13:32:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/12/note_10/</guid>
            <description>

&lt;h5 id=&#34;特点&#34;&gt;特点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;函数可以作为参数，变量，返回值&lt;/li&gt;
&lt;li&gt;高阶函数&lt;/li&gt;
&lt;li&gt;函数-&amp;gt;闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//golang 
func adder() func(int) int {
	sum := 0 //自由变量
	return func(v int) int {
		sum += v
		return sum
	}
}

//python
def adder();
    sum = 0
    def f(value):
        nonlocal sum
        sum += value
        return sum
    return f    
    
    
// c++ 14中的闭包    
auto adder(){
    auto sum = 0;
    return [=] (int value)mutable{
        sum += value;
        return sum;
    };
}

//java中的闭包
Function&amp;lt;Integer,Integer&amp;gt;adder(){
    final Holder&amp;lt;Integer&amp;gt; sum = new Holder&amp;lt;&amp;gt;(0);
    return (Integer value) -&amp;gt; {
        sum.value += value;
        return sum.value;
    }
}



&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 5-1 接口</title>
            <link>http://blog.flywithme.top/2018/02/09/note_09/</link>
            <pubDate>Fri, 09 Feb 2018 15:16:41 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/09/note_09/</guid>
            <description>

&lt;h5 id=&#34;duck-typing&#34;&gt;duck typing&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;基于特征，而不是基于类型&lt;/li&gt;
&lt;li&gt;描述的事物的外部行为，而不是内部结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;pythn中的duck-typing&#34;&gt;pythn中的duck typing&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;def download(retriever):
    return retriever.get(&amp;quot;www.downloadurl.com&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;运行时才知道传入的retriever有没有get方法&lt;/li&gt;
&lt;li&gt;需要给download注释来说明接口需要实现get方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;c-中的duck-typing&#34;&gt;c++ 中的duck typing&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class R&amp;gt;
string download(const R&amp;amp; retriever){
    return retriever.get(&amp;quot;www.downloadur..com&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编译时才可以知道传入的retriever有么有get方法&lt;/li&gt;
&lt;li&gt;需要注释来说明接口需求&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;java-中的类似代码&#34;&gt;java 中的类似代码&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;R extends Retriever&amp;gt;
String download(R r){
    return r.get(&amp;quot;www.downloadurl.com&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;传入的参数必须实现Retriever接口&lt;/li&gt;
&lt;li&gt;不是duck typing&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;go-语言的duck-typing&#34;&gt;go 语言的duck typing&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;同时需要Readable,Appendable怎么做？（apache polygene）&lt;/li&gt;
&lt;li&gt;同时具有python,c++的duck typing的灵活性&lt;/li&gt;
&lt;li&gt;具有java的类型检查&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;接口的定义&#34;&gt;接口的定义&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用者&amp;mdash;&amp;gt;实现者&lt;/li&gt;
&lt;li&gt;接口由&lt;strong&gt;使用者&lt;/strong&gt;定义&lt;/li&gt;
&lt;li&gt;接口的实现是隐式的&lt;/li&gt;
&lt;li&gt;只需要实现接口里的方法即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;接口遍历里有什么东西&#34;&gt;接口遍历里有什么东西&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;实现者的类型&lt;/li&gt;
&lt;li&gt;实现者的值/指针&lt;/li&gt;
&lt;li&gt;接口变量自带指针&lt;/li&gt;
&lt;li&gt;接口变量采用值传递，几乎不需要使用接口的指针&lt;/li&gt;
&lt;li&gt;指针接收者实现只能以指针的方式使用;值接受者都可以&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;查看接口变量&#34;&gt;查看接口变量&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;表示任何类型：interface{}&lt;/li&gt;
&lt;li&gt;Type Assertion&lt;/li&gt;
&lt;li&gt;Type Switch&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
	//Type assertion
	if mockRetriver, ok := r.(*mock.Retriever); ok {
		fmt.Println(mockRetriver.Contents)
	} else {
		fmt.Println(&amp;quot;not mock retriver&amp;quot;)

	}
	
    fmt.Printf(&amp;quot;%T %v\n&amp;quot;, r, r)
	fmt.Println(r)
	switch v := r.(type) {
	case mock.Retriever:
		fmt.Println(&amp;quot;contents:&amp;quot;, v.Contents)
	case *real.Retriever:
		fmt.Println(&amp;quot;UserAgent:&amp;quot;, v.UserAgent)

	}	

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;接口的组合&#34;&gt;接口的组合&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//interface 1
type Retriever interface {
	Get(url string) string
}
//interface 2
type Poster interface {
	Post(url string, form map[string]string) string
}

//interface  combination
type RetrieverPoster interface {
	Retriever
	Poster
}

//go lib  readWriter

// ReadWriter is the interface that groups the basic Read and Write methods.
type ReadWriter interface {
	Reader
	Writer
}

// ReadCloser is the interface that groups the basic Read and Close methods.
type ReadCloser interface {
	Reader
	Closer
}

// WriteCloser is the interface that groups the basic Write and Close methods.
type WriteCloser interface {
	Writer
	Closer
}

// ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.
type ReadWriteCloser interface {
	Reader
	Writer
	Closer
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;常用系统接口&#34;&gt;常用系统接口&lt;/h5&gt;
</description>
        </item>
        
        <item>
            <title>Go: 4-1 面向对象</title>
            <link>http://blog.flywithme.top/2018/02/08/note_08/</link>
            <pubDate>Thu, 08 Feb 2018 11:34:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/08/note_08/</guid>
            <description>

&lt;h4 id=&#34;go语言的面向对象&#34;&gt;&lt;strong&gt;Go语言的面向对象&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Go语言仅支持封装，不支持继承和多态&lt;/li&gt;
&lt;li&gt;Go语言没有class，只有struct&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;结构的创建&#34;&gt;结构的创建&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用自定义工厂函数，需要返回局部变量的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; type treeNode struct {
 	value int
 	left,right *treeNode
 }
 
 func CreatNode(value int)*treeNode  {
 	return &amp;amp;treeNode{value:value}
 }
 
 root := treeNode{value:3}
 root.right = CreatNode(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;结构创建位置是在编译阶段由编译器决定，最后由go的GC垃圾回收器回收&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从正确性的角度，用户不用关心内存在哪里分配的就是了。一般来说，如果有地方用到了那个地址，那么变量就会在堆上分配了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量ret的内存会在堆上分配的，Go的编译器会决定在哪(堆or栈)分配内存，保证程序的正确性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;type struct T { xxx}
func f() *T {
    var ret T
    return &amp;amp;ret
}
	
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Go的编译器很聪明(自作聪明)，它还会做逃逸分析(escape analysis)，如果它发现变量的作用域没有跑出太远，它就可以在栈上分配空间而不是堆&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const Width, Height = 640, 480
type Cursor struct {
    X, Y int
}

func Center(c *Cursor) {
    c.X += Width / 2
    c.Y += Height / 2
}

func CenterCursor() {
    c := new(Cursor)
    Center(c)
    fmt.Println(c.X, c.Y)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用指针作为方法的接受者才可以改变结构内容&lt;/li&gt;
&lt;li&gt;nil指针也可以调用方法，但是在使用时一样需要判断是否nill，以免panic&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;值接收者-vs-指针接收者&#34;&gt;值接收者 VS 指针接收者&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;要改变内容必须使用指针接收者&lt;/li&gt;
&lt;li&gt;结构过大也考虑使用指针接收者（）&lt;/li&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;值接收者是go语言特有&lt;/li&gt;
&lt;li&gt;值/指针接收者均可接收值/指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;封装&#34;&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;名字一般使用CamelCase(驼峰命名)&lt;/li&gt;
&lt;li&gt;首字母大写：Public&lt;/li&gt;
&lt;li&gt;首字母小写：private&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Public和private是针对包来说的，包外可以访问Public方法，&lt;/p&gt;

&lt;h6 id=&#34;包&#34;&gt;包&lt;/h6&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个目录一个包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;main包 包含可执行入口只能有一个main方法入口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为结构定义的方法必须放在同一个包内&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以是不同的文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;扩充系统类型或者第三方库类型&#34;&gt;扩充系统类型或者第三方库类型&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;定义别名&lt;/li&gt;
&lt;li&gt;使用组合&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 3-2 Map 和字符串的一些操作</title>
            <link>http://blog.flywithme.top/2018/02/07/note_07/</link>
            <pubDate>Wed, 07 Feb 2018 17:52:33 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/07/note_07/</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#map&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rune-相当于go的char&#34;&gt;rune 相当于go的char&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strings&#34;&gt;strings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;h6 id=&#34;map&#34;&gt;Map&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;Map 是一种无序的键值对的集合。最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。&lt;/li&gt;
&lt;li&gt;Map 是一种集合，可以像迭代数组和切片那样迭代它。Map 是无序的，我们无法决定它的返回顺序，因为 Map 是使用 hash 表来实现的。
```
	m := map[string]string{
		&amp;ldquo;name&amp;rdquo;:    &amp;ldquo;jack&amp;rdquo;,
		&amp;ldquo;course&amp;rdquo;:  &amp;ldquo;golang&amp;rdquo;,
		&amp;ldquo;site&amp;rdquo;:    &amp;ldquo;imooc&amp;rdquo;,
		&amp;ldquo;quality&amp;rdquo;: &amp;ldquo;notbad&amp;rdquo;,
	}
	&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;	m2 := make(map[string]int) // m2 == empty map
    var m3 map[string]int // m3 == nil
	fmt.Println(&amp;ldquo;m, m2, m3:&amp;ldquo;)
    fmt.Println(m, m2, m3)
	fmt.Println(&amp;ldquo;Traversing map m&amp;rdquo;)
	for k, v := range m {
		fmt.Println(k, v)
	}&lt;/p&gt;

&lt;p&gt;	fmt.Println(&amp;ldquo;Getting values&amp;rdquo;)
	courseName := m[&amp;ldquo;course&amp;rdquo;]
	fmt.Println(&lt;code&gt;m[&amp;quot;course&amp;quot;] =&lt;/code&gt;, courseName)
	if causeName, ok := m[&amp;ldquo;cause&amp;rdquo;]; ok {
		fmt.Println(causeName)
	} else {
		fmt.Println(&amp;ldquo;key &amp;lsquo;cause&amp;rsquo; does not exist&amp;rdquo;)
	}&lt;/p&gt;

&lt;p&gt;	fmt.Println(&amp;ldquo;Deleting values&amp;rdquo;)
	name, ok := m[&amp;ldquo;name&amp;rdquo;]
	fmt.Printf(&amp;ldquo;m[%q] before delete: %q, %v\n&amp;rdquo;,
		&amp;ldquo;name&amp;rdquo;, name, ok)&lt;/p&gt;

&lt;p&gt;	delete(m, &amp;ldquo;name&amp;rdquo;)
	name, ok = m[&amp;ldquo;name&amp;rdquo;]
	fmt.Printf(&amp;ldquo;m[%q] after delete: %q, %v\n&amp;rdquo;,
		&amp;ldquo;name&amp;rdquo;, name, ok)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### map的key
 - map使用hash表，必须可以比较相等
 - 除了slice，map和fuction的內建类型都可以做key
 - Struct类型不包含上述字段，也可以做key
 - 会在编译时检查
 
 
###### 寻找最长不含有重复字符的子串 (abcabcbb -&amp;gt; abc) rune
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//视频提供的方法 比较繁琐，逻辑复杂，此方法更简洁
func lengthOfNonRepeatingSubStr(s string)int  {
	lastOccured := make(map[rune]rune)
	for _ , ch := range []rune(s) {
		lastOccured[ch] = ch
	}
	return len(lastOccured)
}
```&lt;/p&gt;

&lt;h5 id=&#34;rune-相当于go的char&#34;&gt;rune 相当于go的char&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用range遍历pos,rune&lt;/li&gt;
&lt;li&gt;使用utf8.RuneCountInString获得字符数量&lt;/li&gt;
&lt;li&gt;len()获取的是字节长度&lt;/li&gt;
&lt;li&gt;使用[]byte获得字节内容&lt;/li&gt;
&lt;li&gt;[]rune&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;strings&#34;&gt;strings&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;string到int&lt;br /&gt;
&lt;code&gt;int, err := strconv.Atoi(string)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;string到int64&lt;br /&gt;
&lt;code&gt;int64, err := string.ParseInt(string, 10, 64)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int到string&lt;br /&gt;
&lt;code&gt;string := strconv.Itoa(int)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int64到string&lt;br /&gt;
&lt;code&gt;string := strconv.FormatInt(int64, 10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hasprefix判断字符串s是否以prefix开头&lt;br /&gt;
&lt;code&gt;strings.HasPrefix(s, prefix string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HasSuffix判断字符串s是否以suffix结尾&lt;br /&gt;
&lt;code&gt;strings.HasSuffix(s, suffix string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Contains判断字符串s是否包含substr&lt;br /&gt;
&lt;code&gt;strings.Contains(s, substr string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Index返回字符串str在字符串s中的索引(str的第一个字符的索引)，-1表示字符串s不包含字符串str&lt;br /&gt;
&lt;code&gt;strings.Index(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LastIndex返回字符串str在字符串s中最后出现的位置&lt;br /&gt;
&lt;code&gt;strings.LastIndex(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非ASCII编码的字符定位&lt;br /&gt;
&lt;code&gt;strings.IndexRune(s string, ch int)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace用于将str中前n个字符串old替换为字符串new，如果为-1则替换所有字符串old为new&lt;br /&gt;
&lt;code&gt;strings.Replace(str, old, new, n) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Count用于计算str在s中出现的非重叠次数&lt;br /&gt;
&lt;code&gt;strings.Count(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Repeat用于重复count次字符串s并返回一个新的字符串&lt;br /&gt;
&lt;code&gt;strings.Repeat(s, count int) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ToLower将字符串中Unicode字符全部转换为小写字符&lt;br /&gt;
&lt;code&gt;strings.ToLower(s) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ToUpper将字符串中Unicode字符全部转换为大写字符&lt;br /&gt;
&lt;code&gt;strings.ToUpper(s) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TrimSpace剔除字符串开头和结尾的空白符号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Trim剔除开头和结尾的字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;TrimLeft,TrimRight剔除开头或结尾字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Fields利用一个或多个空白符号来作为动态长度的分隔符将字符串分割，返回slice&lt;br /&gt;
&lt;code&gt;strings.Fields(s) slice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Split用自定义分割符号来对指定字符串进行分割&lt;br /&gt;
&lt;code&gt;strings.Split(s, sep) slice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Join用于将元素类型为string的slice使用分割符号来拼接组成一个字符串&lt;br /&gt;
&lt;code&gt;strings.Join(sl []string, sep string)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 3-1 数组、切片和容器</title>
            <link>http://blog.flywithme.top/2018/02/05/note_06/</link>
            <pubDate>Mon, 05 Feb 2018 16:44:58 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/05/note_06/</guid>
            <description>

&lt;h5 id=&#34;数组-值类型&#34;&gt;数组 (值类型)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;[10]int 和 [5]int 是不同的类型&lt;/li&gt;
&lt;li&gt;调用func f(arr [5]int)会&lt;strong&gt;拷贝&lt;/strong&gt;数组&lt;/li&gt;
&lt;li&gt;调用func f1(arr *[5]int)可以在方法里修改arr&lt;/li&gt;
&lt;li&gt;Go中一般不直接使用数组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;   //数组初始化
    var arr1 [5]int
   	arr2 :=[3]int{2,4,6}
   	arr3 :=[...]int{2,4,5,6,78,0}
   
   	fmt.Println(arr1,arr2,arr3)
   
   	var grid[4][2][1]int
   	fmt.Println(grid)
   
   	//元素遍历
   	for i :=0;i &amp;lt; len(arr3) ;i ++  {
   		fmt.Println(arr3[i])
   	}
   	
   	
//指针传递   	
func printArray(arr *[5]int) {
	arr[0] = 100
	for i, v := range arr {
		fmt.Println(i, v)
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;range-关键字-还会有很多其他地方用到&#34;&gt;&lt;code&gt;range&lt;/code&gt; 关键字 (还会有很多其他地方用到)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;   	for i,v := range arr3  {
   		fmt.Println(i,v)
   	}
   	for _,v := range arr3  {
   		fmt.Println(v)
   	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;切片-slice&#34;&gt;切片 Slice&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}

	fmt.Println(&amp;quot;arr[2:6] =&amp;quot;, arr[2:6])
	fmt.Println(&amp;quot;arr[:6] =&amp;quot;, arr[:6])
	s1 := arr[2:]
	fmt.Println(&amp;quot;s1 =&amp;quot;, s1)
	s2 := arr[:]
	fmt.Println(&amp;quot;s2 =&amp;quot;, s2)

	fmt.Println(&amp;quot;After updateSlice(s1)&amp;quot;)
	updateSlice(s1)
	fmt.Println(s1)
	fmt.Println(arr)

	fmt.Println(&amp;quot;After updateSlice(s2)&amp;quot;)
	updateSlice(s2)
	fmt.Println(s2)
	fmt.Println(arr)

	fmt.Println(&amp;quot;Reslice&amp;quot;)
	fmt.Println(s2)
	s2 = s2[:5]
	fmt.Println(s2)
	s2 = s2[2:]
	fmt.Println(s2)

	fmt.Println(&amp;quot;Extending slice&amp;quot;)
	arr[0], arr[2] = 0, 2
	fmt.Println(&amp;quot;arr =&amp;quot;, arr)
	s1 = arr[2:6]
	fmt.Println(arr[0:1])
	s2 = s1[3:6] // [s1[3], s1[4]]
	fmt.Printf(&amp;quot;s1=%v, len(s1)=%d, cap(s1)=%d\n&amp;quot;,
		s1, len(s1), cap(s1))
		
		
	fmt.Printf(&amp;quot;s2=%v, len(s2)=%d, cap(s2)=%d\n&amp;quot;,
		s2, len(s2), cap(s2))

	s3 := append(s2, 10)
	s4 := append(s3, 11)
	s5 := append(s4, 12)
	fmt.Println(&amp;quot;s3, s4, s5 =&amp;quot;, s3, s4, s5)
	// s4 and s5 no longer view arr.
	fmt.Println(&amp;quot;arr =&amp;quot;, arr)

	// Uncomment to run sliceOps demo.
	// If we see undefined: sliceOps
	// please try go run slices.go sliceops.go
	fmt.Println(&amp;quot;Uncomment to see sliceOps demo&amp;quot;)
	// sliceOps()

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;slice的向后扩展&#34;&gt;Slice的向后扩展&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    s1 = arr[2:6]
	s2 = s1[3:5]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;s1的值为[2,3,4,5],s2的值为[5,6]&lt;/li&gt;
&lt;li&gt;slice可以向后扩展，不可以向前扩展&lt;/li&gt;
&lt;li&gt;s[i] 不可以超越len(s),向后扩展不可以超越底层数组cap(s)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517845264648.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;向slice添加元素&#34;&gt;向slice添加元素&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;添加元素时如果超越cap长度，系统会重新分配更大的底层数组&lt;/li&gt;
&lt;li&gt;由于值传递的关系，必须接受append的返回值&lt;/li&gt;
&lt;li&gt;s = append(s,val)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-4 指针</title>
            <link>http://blog.flywithme.top/2018/02/05/note_05/</link>
            <pubDate>Mon, 05 Feb 2018 15:29:31 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/05/note_05/</guid>
            <description>

&lt;h5 id=&#34;什么是指针&#34;&gt;什么是指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类似于变量和常量，在使用指针前你需要声明指针
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;如何使用指针&#34;&gt;如何使用指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;定义指针变量。&lt;/li&gt;
&lt;li&gt;为指针变量赋值。&lt;/li&gt;
&lt;li&gt;访问指针变量中指向地址的值。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    var a int = 2
	var pa *int = &amp;amp;a
	*pa = 3
	fmt.Println(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;空指针&#34;&gt;空指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;当一个指针被定义后没有分配到任何变量时，它的值为 nil。&lt;/li&gt;
&lt;li&gt;nil 指针也称为空指针。&lt;/li&gt;
&lt;li&gt;nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。&lt;/li&gt;
&lt;li&gt;一个指针变量通常缩写为 ptr&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    var  ptr *int
    fmt.Printf(&amp;quot;ptr 的值为 : %x\n&amp;quot;, ptr  )
    
    if(ptr != nil)     /* ptr 不是空指针 */
    if(ptr == nil)    /* ptr 是空指针 */
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;参数传递的几种形式&#34;&gt;参数传递的几种形式&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818417658.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818442412.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818481871.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main()  {
	var a int = 2
	var pa *int = &amp;amp;a
	*pa = 3
	fmt.Println(a)

	var  ptr *int
	fmt.Printf(&amp;quot;ptr 的值为 : %x\n&amp;quot;, ptr  )
	a,b := 3,4
	swap(&amp;amp;a,&amp;amp;b)
	fmt.Println(a,b)
	a,b = swap1(a,b)
	fmt.Println(a,b)


}

func swap(a,b *int)  {
	*b,*a = *a,*b
}

func swap1(a,b int)(int,int)  {
	return b,a
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-3 函数</title>
            <link>http://blog.flywithme.top/2018/02/04/note_04/</link>
            <pubDate>Sun, 04 Feb 2018 14:37:54 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/04/note_04/</guid>
            <description>

&lt;h5 id=&#34;函数&#34;&gt;函数&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;函数是基本的代码块，用于执行一个任务。&lt;/li&gt;
&lt;li&gt;Go 语言最少有个 main() 函数。&lt;/li&gt;
&lt;li&gt;你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。&lt;/li&gt;
&lt;li&gt;函数声明告诉了编译器函数的名称，返回类型，和参数。&lt;/li&gt;
&lt;li&gt;Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Go 语言函数定义格式如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func function_name( [parameter list] ) [return_types] {
   函数体
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    package main
    
    import (
    	&amp;quot;fmt&amp;quot;
    	&amp;quot;reflect&amp;quot;
    	&amp;quot;runtime&amp;quot;
    	&amp;quot;math&amp;quot;
    )
    
    func eval(a,b int,op string)  (int,error){
    	switch op {
    	case &amp;quot;+&amp;quot;:
    		return a + b,nil
    	case &amp;quot;-&amp;quot;:
    		return a - b,nil
    	case &amp;quot;*&amp;quot;:
    		return a * b,nil
    	case &amp;quot;/&amp;quot;:
    		q,_ := div(a,b)
    		return q,nil
    	default:
    		return 0,fmt.Errorf(&amp;quot;unsupported operation:&amp;quot; +op)
    	}
    }
    
    func apply(op func(int,int)int,a,b int)int  {
    	p := reflect.ValueOf(op).Pointer()
    	opName := runtime.FuncForPC(p).Name()
    	fmt.Printf(&amp;quot;calling function %s with args (%d %d)&amp;quot;,opName,a,b)
    	return op(a,b)
    }
    
    //除法
    
    func div(a,b int)(int ,int)  {
    	return a/b,a%b
    }
    
    func pow(a,b int)int  {
    	return int(math.Pow(float64(a),float64(b)))
    }
    
    func sum(numbers ...int)int  {
    	s := 0
    	//for i := range numbers{
    	//	s +=numbers[i]
    	//}
    	for _,value := range numbers{
    		s += value
    	}
    	return s
    }
    
    func main()  {
    	fmt.Println(eval(3,4,&amp;quot;/-&amp;quot;))
    	q,r := div(13,5)
    	fmt.Println(q,r)
    
    	fmt.Println(apply(pow,3,4))
    	fmt.Println(
    		apply(func(a ,b int)int {
    			return int(math.Pow(float64(a),float64(b)))
    		},3,4))
    
    	fmt.Println(
    		apply(func(a ,b int)int {
    			return int(math.Pow(float64(a),float64(b)))
    		},3,4))
    	fmt.Println(sum(1,2,3,4,5,6,7,8,10))
    }


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;函数语法的要点回顾&#34;&gt;函数语法的要点回顾&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;返回值类型写在后面&lt;/li&gt;
&lt;li&gt;可以返回多个值&lt;/li&gt;
&lt;li&gt;函数可作为参数&lt;/li&gt;
&lt;li&gt;没有默认参数，可选参数 （有可变参数列表）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-2 条件语句和循环语句</title>
            <link>http://blog.flywithme.top/2018/02/04/note_03/</link>
            <pubDate>Sun, 04 Feb 2018 14:05:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/04/note_03/</guid>
            <description>

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语句&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;if 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;if 语句 由一个布尔表达式后紧跟一个或多个语句组成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;if&amp;hellip;else&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;if 嵌套语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;switch 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;switch 语句用于基于不同条件执行不同动作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;    package main
    
    import (
    	&amp;quot;fmt&amp;quot;
    	&amp;quot;io/ioutil&amp;quot;
    )
    
    func grade(score int) string {
    	g := &amp;quot;&amp;quot;
    	switch {
    	case score &amp;lt; 0 || score &amp;gt; 100:
    		panic(fmt.Sprintf(
    			&amp;quot;Wrong score: %d&amp;quot;, score))
    	case score &amp;lt; 60:
    		g = &amp;quot;F&amp;quot;
    	case score &amp;lt; 80:
    		g = &amp;quot;C&amp;quot;
    	case score &amp;lt; 90:
    		g = &amp;quot;B&amp;quot;
    	case score &amp;lt;= 100:
    		g = &amp;quot;A&amp;quot;
    	}
    	return g
    }
    
    func main() {
    	// If &amp;quot;abc.txt&amp;quot; is not found,
    	// please check what current directory is,
    	// and change filename accordingly.
    	const filename = &amp;quot;abc.txt&amp;quot;
    	if contents, err := ioutil.ReadFile(filename); err != nil {
    		fmt.Println(err)
    	} else {
    		fmt.Printf(&amp;quot;%s\n&amp;quot;, contents)
    	}
    
    	fmt.Println(
    		grade(0),
    		grade(59),
    		grade(60),
    		grade(82),
    		grade(99),
    		grade(100),
    		// Uncomment to see it panics.
    		// grade(-3),
    	)
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。&lt;br /&gt;
  select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;select {
    case communication clause  :
       statement(s);      
    case communication clause  :
       statement(s); 
    /* 你可以定义任意数量的 case */
    default : /* 可选 */
       statement(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;以下描述了-select-语句的语法&#34;&gt;以下描述了 select 语句的语法：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;每个case都必须是一个通信&lt;/li&gt;
&lt;li&gt;所有channel表达式都会被求值&lt;/li&gt;
&lt;li&gt;所有被发送的表达式都会被求值&lt;/li&gt;
&lt;li&gt;如果任意某个通信可以进行，它就执行；其他被忽略。&lt;/li&gt;
&lt;li&gt;如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
&lt;strong&gt;否则：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果有default子句，则执行该语句。&lt;/li&gt;
&lt;li&gt;如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;   package main
   import &amp;quot;fmt&amp;quot;
   import &amp;quot;time&amp;quot;
   func f1(ch chan int) {
       time.Sleep(time.Second * 5)
       ch &amp;lt;- 1
   }
   func f2(ch chan int) {
       time.Sleep(time.Second * 10)
       ch &amp;lt;- 1
   }
   func main() {
       var ch1 = make(chan int)
       var ch2 = make(chan int)
       go f1(ch1)
       go f2(ch2)
       select {
       case &amp;lt;-ch1:
           fmt.Println(&amp;quot;The first case is selected.&amp;quot;)
       case &amp;lt;-ch2:
           fmt.Println(&amp;quot;The second case is selected.&amp;quot;)
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;循环语句&#34;&gt;循环语句&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;strconv&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;bufio&amp;quot;
	&amp;quot;strings&amp;quot;
)

func convertToBin(n int) string  {
	result := &amp;quot;&amp;quot;
	for ; n &amp;gt;0; n /=2{
		lsb := n%2
		result = strconv.Itoa(lsb)+result
	}
	return result
}

func printFile(filename string)  {
	file,err :=os.Open(filename)
	if err != nil {
		panic(err)
	}
	printFileContents(file)
}

func printFileContents(reader io.Reader) {
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
}
func forever()  {
	for{
		fmt.Println(&amp;quot;abc&amp;quot;)
	}

}

func main()  {
	fmt.Println(&amp;quot;convertToBin results:&amp;quot;)
	fmt.Println(
		convertToBin(15),
		convertToBin(2),
		convertToBin(5),
	)
	fmt.Println(&amp;quot;abc.txt contents:&amp;quot;)
	printFile(&amp;quot;abc.txt&amp;quot;)


	s := `abc &amp;quot;ad&amp;quot;
	kddd
	123
	p
	22333&#39;`
	printFileContents(strings.NewReader(s))
}



&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-1 变量定义</title>
            <link>http://blog.flywithme.top/2018/02/03/note_02/</link>
            <pubDate>Sat, 03 Feb 2018 19:45:12 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/03/note_02/</guid>
            <description>

&lt;h5 id=&#34;变量声明&#34;&gt;变量声明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;指定变量类型，声明后若不赋值，使用默认值。&lt;/li&gt;
&lt;li&gt;根据值编译器自行判定变量类型。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。（函数外部无法省略var关键字）
```
//默认 没有初值
func variableZeroValue()  {
	var a int
	var s string
	fmt.Printf(&amp;ldquo;%d,%q\n&amp;rdquo;,a,s)
}&lt;/p&gt;

&lt;p&gt;//赋予初值和类型
func variableInitialValue()  {
	var a,b int = 3,4
	var s string = &amp;ldquo;abc&amp;rdquo;
	fmt.Println(a,b,s)
}&lt;/p&gt;

&lt;p&gt;//赋予初值
func variableTypeDeduction()  {
	var a,b,c,s = 3,4,true,&amp;ldquo;def&amp;rdquo;
	fmt.Println(a,b,c,s)
}&lt;/p&gt;

&lt;p&gt;func variableShorter()  {
	a,b,c,s := 3,4,true,&amp;ldquo;def&amp;rdquo;
	b = 3
	fmt.Println(a,b,c,s)
}
var(
	ss =&amp;ldquo;string&amp;rdquo;
	aa = 1
	bb = 2
)
func euler()  {
	//c := 3+4i
	//fmt.Println(cmplx.Abs&amp;copy;)
	//cmplx.Pow(math.E,1i*math.Pi)+1&lt;/p&gt;

&lt;p&gt;	fmt.Println(cmplx.Exp(1i*math.Pi)+1)
}
func main(){
	fmt.Println(&amp;ldquo;hello world&amp;rdquo;)
	variableZeroValue()
	variableInitialValue()
	variableTypeDeduction()
	variableShorter()
    fmt.Println(aa,ss,bb)
    euler()
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    
##### 内建变量类型
 - bool, string 
 - (u)int, (u)int8,(u)int16,(u)int32,(u)int64,(u)intptr (指针)
 - byte,rune(Go语言的一个字符型，char类型坑太多，代替char,32位)
 - float32,float64,complex64,complex128（复数）
 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func euler()  {
 	//c := 3+4i
 	//fmt.Println(cmplx.Abs(c))
 	//cmplx.Pow(math.E,1i*math.Pi)+1

 	fmt.Println(cmplx.Exp(1i*math.Pi)+1)
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; 
    
    

##### 强制类型转换
    
    func triangle()  {
        var a,b int = 3,4
        c := math.Sqrt(float64(a*a+b*b))
        fmt.Println(c)
    }

##### 常量的定义
 - 常量是一个简单值的标识符，在程序运行时，不会被修改的量。
 - 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
 - **iota** iota，特殊常量，（iota 可以被用作枚举值）可以认为是一个可以被编译器修改的常量。在每一个const关键字出现时，
 被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const filename = &amp;ldquo;abc.txt&amp;rdquo;
func consts()  {
	const a,b  = 3,4
	//a,b可以不指定类型
	c := math.Sqrt(a*a+b*b)
	fmt.Println(filename,c)&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;//第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：
const (
    a = iota
    b
    c
)&lt;/p&gt;

&lt;p&gt;const (
	b = 1 &amp;lt;&amp;lt;(10*iota)
	kb
	mb
	gb
	tb
	pb
)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h5 id=&#34;变量定义的要点&#34;&gt;变量定义的要点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;变量类型写在变量名之后&lt;/li&gt;
&lt;li&gt;编译器可以推测变量的类型&lt;/li&gt;
&lt;li&gt;没有char,只有rune&lt;/li&gt;
&lt;li&gt;原生支持复数类型&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
