<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Fly With Me</title>
        <link>http://blog.flywithme.top/post/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sun, 05 Nov 2017 20:17:21 CST</updated>
        
        <item>
            <title>使用gin框架实现一个基于Mysql数据库的用户系统</title>
            <link>http://blog.flywithme.top/2017/11/05/gin-mysql/</link>
            <pubDate>Sun, 05 Nov 2017 20:17:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/05/gin-mysql/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&#34;https://github.com/flywithbug/darkside&#34;&gt;https://github.com/flywithbug/darkside&lt;/a&gt; 欢迎fork。 TODO 更新更多内容&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>iOS11 ScrollView 页面下移问题</title>
            <link>http://blog.flywithme.top/2017-09-30-iOS11ScrollView20pt</link>
            <pubDate>Sat, 30 Sep 2017 14:58:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017-09-30-iOS11ScrollView20pt</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#一-ios-11下app中tableview内容下移20pt或下移64pt的原因分析&#34;&gt;一、iOS 11下APP中tableView内容下移20pt或下移64pt的原因分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#二-adjustcontentinset属性的计算方式&#34;&gt;二、 adjustContentInset属性的计算方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#三-什么情况下的tableview会发生上述问题&#34;&gt;三、什么情况下的tableView会发生上述问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#四-这个问题的解决方法有哪些&#34;&gt;四、这个问题的解决方法有哪些？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#五-遇到的另外一个与安全区域无关的tableview内容下移的问题&#34;&gt;五、遇到的另外一个与安全区域无关的tableView内容下移的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;&lt;strong&gt;scorllView contentOffset变动问题&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&#34;一-ios-11下app中tableview内容下移20pt或下移64pt的原因分析&#34;&gt;一、iOS 11下APP中tableView内容下移20pt或下移64pt的原因分析&lt;/h6&gt;

&lt;p&gt;问题如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/scrollview/92.png&#34; alt=&#34;sss&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 原因分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因是iOS 11中&lt;code&gt;UIViweController&lt;/code&gt;的&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性被废弃了，所以当&lt;code&gt;scrollView&lt;/code&gt;超出安全区域时系统自动调整了&lt;code&gt;SafeAreaInsets&lt;/code&gt;值，进而影响&lt;code&gt;adjustedContentInset&lt;/code&gt;值，&lt;br /&gt;
在iOS 11中决定tableView的内容与边缘距离的是&lt;code&gt;adjustedContentInset&lt;/code&gt;属性，而不是&lt;code&gt;contentInset&lt;/code&gt;。&lt;code&gt;adjustedContentInset&lt;/code&gt;的计算方式见本文第二部分内容。因为系统对&lt;code&gt;adjustedContentInset&lt;/code&gt;值进行了调整，所以导致&lt;code&gt;tableView&lt;/code&gt;的内容到边缘的距离发生了变化，导致&lt;code&gt;tableView&lt;/code&gt;下移了20pt（statusbar高度）或64pt（navigationbar高度）。&lt;/p&gt;

&lt;p&gt;如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0)。关于什么情况下会发生内容下移的问题，本文第三部分有介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 安全区域的概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统自动调整tableView内容偏移量，是根据安全区域来调整的。安全区域是iOS 11新提出的，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/scrollview/32.png&#34; alt=&#34;sssa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安全区域帮助我们将view放置在整个屏幕的可视的部分。即使把navigationbar设置为透明的，系统也认为安全区域是从navigationbar的bottom开始的。
安全区域定义了view中可视区域的部分，保证不被系统的状态栏、或父视图提供的view如导航栏覆盖。可以使用&lt;code&gt;additionalSafeAreaInsets&lt;/code&gt;去扩展安全区域去包括自定义的content在你的界面。每个view都可以改变安全区域嵌入的大小，Controller也可以。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;safeAreaInsets&lt;/code&gt;属性反映了一个view距离该view的安全区域的边距。对于一个Controller的根视图而言，&lt;code&gt;SafeAreaInsets&lt;/code&gt;值包括了被&lt;code&gt;statusbar&lt;/code&gt;和其他可视的bars覆盖的区域和其他通过&lt;code&gt;additionalSafeAreaInsets&lt;/code&gt;自定义的insets值。对于view层次中得其他view，SafeAreaInsets值反映了view被覆盖的部分。如果一个view全部在它父视图的安全区域内，则SafeAreaInsets值为(0,0,0,0)。&lt;/p&gt;

&lt;h6 id=&#34;二-adjustcontentinset属性的计算方式&#34;&gt;二、 adjustContentInset属性的计算方式&lt;/h6&gt;

&lt;p&gt;首先看scrollView在iOS11新增的两个属性：adjustContentInset 和 contentInsetAdjustmentBehavior。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Configure the behavior of adjustedContentInset.
Default is UIScrollViewContentInsetAdjustmentAutomatic.
*/
@property(nonatomic) UIScrollViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior
adjustContentInset表示contentView.frame.origin偏移了scrollview.frame.origin多少；是系统计算得来的，计算方式由contentInsetAdjustmentBehavior决定。有以下几种计算方式：

UIScrollViewContentInsetAdjustmentAutomatic：如果scrollview在一个automaticallyAdjustsScrollViewInsets = YES的controller上，并且这个Controller包含在一个navigation controller中，这种情况下会设置在top &amp;amp; bottom上 adjustedContentInset = safeAreaInset + contentInset不管是否滚动。其他情况下与UIScrollViewContentInsetAdjustmentScrollableAxes相同

UIScrollViewContentInsetAdjustmentScrollableAxes: 在可滚动方向上adjustedContentInset = safeAreaInset + contentInset，在不可滚动方向上adjustedContentInset = contentInset；依赖于scrollEnabled和alwaysBounceHorizontal / vertical = YES，scrollEnabled默认为yes，所以大多数情况下，计算方式还是adjustedContentInset = safeAreaInset + contentInset

UIScrollViewContentInsetAdjustmentNever: adjustedContentInset = contentInset

UIScrollViewContentInsetAdjustmentAlways: adjustedContentInset = safeAreaInset + contentInset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;contentInsetAdjustmentBehavior&lt;/code&gt;设置为&lt;code&gt;UIScrollViewContentInsetAdjustmentNever&lt;/code&gt;的时候，&lt;code&gt;adjustContentInset&lt;/code&gt;值不受&lt;code&gt;SafeAreaInset&lt;/code&gt;值的影响。&lt;/p&gt;

&lt;h6 id=&#34;三-什么情况下的tableview会发生上述问题&#34;&gt;三、什么情况下的tableView会发生上述问题&lt;/h6&gt;

&lt;p&gt;如果设置了automaticallyAdjustsScrollViewInsets = YES，那么不会发生问题，一直都是由系统来调整内容的偏移量。&lt;/p&gt;

&lt;p&gt;接下来排查下自己的项目中哪些页面会发生以上问题。&lt;/p&gt;

&lt;p&gt;当tableView的frame超出安全区域范围时，系统会自动调整内容的位置，SafeAreaInsets值会不为0，于是影响tableView的adjustContentInset值，于是影响tableView的内容展示，导致tableView的content下移了SafeAreaInsets的距离。SafeAreaInsets值为0时，是正常的情况。&lt;/p&gt;

&lt;p&gt;需要了解每个页面的结构，看tableView是否被系统的statusbar或navigationbar覆盖，如果被覆盖的话，则会发生下移。也可以通过tableview.safeAreaInsets的值来确认是因为安全区域的问题导致的内容下移。&lt;/p&gt;

&lt;p&gt;如下代码片段，可以看出系统对tableView向下调整了20pt的距离，因为tableView超出了安全区域范围，被statusbar覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tableview.contentInset: {64, 0, 60, 0}
tableview.safeAreaInsets: {20, 0, 0, 0}
tableview.adjustedContentInset: {84, 0, 60, 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;四-这个问题的解决方法有哪些&#34;&gt;四、这个问题的解决方法有哪些？&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置tableView的contentInsetAdjustmentBehavior属性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果不需要系统为你设置边缘距离，可以做以下设置：&lt;/p&gt;

&lt;p&gt;//如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0  110000”；如果系统版本低于11.0则没有这个宏定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef __IPHONE_11_0   
if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) {
    tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;contentInsetAdjustmentBehavior&lt;/code&gt;属性也是用来取代&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性的，推荐使用这种方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过设置iOS 11新增的属性addtionalSafeAreaInset；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;iOS 11之前，大家是通过将Controller的&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，
那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，
tableView内容不会显示异常。这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。&lt;/p&gt;

&lt;h6 id=&#34;五-遇到的另外一个与安全区域无关的tableview内容下移的问题&#34;&gt;五、遇到的另外一个与安全区域无关的tableView内容下移的问题&lt;/h6&gt;

&lt;p&gt;我的作品页面的tableView下移了约40pt，这里是否跟安全区域有关呢？&lt;/p&gt;

&lt;p&gt;查了下页面结构，tableView的父视图的frame在navigationbar的bottom之下，tableView在父视图的安全区域内，打印出来tableView的SafeAreaInset值也是(0，0，0，0);所以不是安全区域导致的内容下移。&lt;/p&gt;

&lt;p&gt;经过查看代码，发现tableView的style:UITableViewStyleGrouped类型，默认tableView开头和结尾是有间距的，不需要这个间距的话，可以通过实现heightForHeaderInSection方法（返回一个较小值：0.1）和viewForHeaderInSection（返回一个view）来去除头部的留白，底部同理。&lt;/p&gt;

&lt;p&gt;iOS 11上发生tableView顶部有留白，原因是代码中只实现了heightForHeaderInSection方法，而没有实现viewForHeaderInSection方法。那样写是不规范的，只实现高度，而没有实现view，但代码这样写在iOS 11之前是没有问题的，iOS 11之后应该是由于开启了估算行高机制引起了bug。添加上viewForHeaderInSection方法后，问题就解决了。或者添加以下代码关闭估算行高，问题也得到解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.tableView.estimatedRowHeight = 0;
self.tableView.estimatedSectionHeaderHeight = 0;
self.tableView.estimatedSectionFooterHeight = 0;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>大文件分片上传解决方案</title>
            <link>http://blog.flywithme.top/2017/08/03/bigFileUpload/</link>
            <pubDate>Thu, 03 Aug 2017 13:44:56 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/08/03/bigFileUpload/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分片模型：索引，上传状态，偏移量，大小，文件名，类型，分片数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;md5: 获取文件的md5值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件管理工具：文件路径， 分析文件内容，生成数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;上传任务池中会保持小于等于3个的请求任务
 启动上传任务之后会往任务池中添加上传任务，若分片数大于3个，则会把任务池填满。
 等其中任意一个任务上传结束之后会回调通知任务池，添加一个新的请求任务进入任务池中
 等上传任务全部结束，发送合并片的请求(这个其实是业务方自己做的)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/bigFileUpload/bigfile001.png&#34; alt=&#34;bigfile001&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文件的md5值读取，在文件很大的时候不要使用把数据转换成二进制流的形式获取。因为这样可能会造成内存溢出。使用分片读取md5的形式&lt;br /&gt;
   模型组里可以保存每一个分片的md5值，用于分片的上传状态。&lt;br /&gt;
   管理中心可以保存分片文件的上传状态，上传失败之后可以尝试重新上传，同一个分片数据只上传一次。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>swift3-22</title>
            <link>http://blog.flywithme.top/2017/04/17/swift22/</link>
            <pubDate>Mon, 17 Apr 2017 10:48:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/17/swift22/</guid>
            <description></description>
        </item>
        
        <item>
            <title>swift3-21 析构过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift21/</link>
            <pubDate>Thu, 13 Apr 2017 17:19:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift21/</guid>
            <description>&lt;p&gt;在一个类的实例被释放之前，析构函数就被立即调用，用关键字 deinit 来表示析构函数， 类似与初始化使用 init 来标示。析构函数只适用于类类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;析构过程原理&lt;/strong&gt; Swift会自动释放不在需要的实例以释放资源。通过ARC处理实例的内存管理。通常实例被释放是不需要手动清理的。但是当使用到一些资源的
 时候可能就需要额外的清理了。比如打开另一个文件写入数据，就需要在实例被释放前关闭该文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：在类的定义中，每个类最多只有一个析构函数，析构函数不带任何参数，不带括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deinit{
   //执行析构过程
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;code&gt;deinit&lt;/code&gt;的调用时机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var counter = 0;  
class BaseClass {
    init() {
        counter += 1;
    }
    deinit {
        counter -= 1;
    }
}

var show: BaseClass? = BaseClass()
print(counter) // 1
show = nil  
print(counter) // 0
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-20 构造过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift20/</link>
            <pubDate>Thu, 13 Apr 2017 16:24:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift20/</guid>
            <description>&lt;p&gt;构造过程是为了使用某个类、结构体或者枚举类型实例而进行的准备过程。这个过程包含了为实例的每一个属性设置初始值 的初始化任务&lt;br /&gt;
 swift的构造函数使用的是init()方法。 这个方法没有返回值。主要任务是保证新实例在第一次使用之前完成正确的初始化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造器&lt;/strong&gt; 在创建某特定类型的新实例时调用，它的关键字是init&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init(){
    //执行属性初值设置
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两段式构造&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值  第一段
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善  第二段
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认属性值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age:Int
    init(){
        age = 18
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造参数&lt;/strong&gt;  定义构造器 init() 时提供构造参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选属性类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认构造器&lt;/strong&gt; 所有属性都设置有默认值的实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age = 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;required 构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;必须被子类实现的构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    //子类必须实现
    required init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    private final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //子类实现父类的required
    required convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
son.name
son.age
son.level
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数的继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
   //构造函数的继承
    override convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)    
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-19 多态性</title>
            <link>http://blog.flywithme.top/2017/04/13/swift19/</link>
            <pubDate>Thu, 13 Apr 2017 12:00:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift19/</guid>
            <description>&lt;p&gt;&lt;strong&gt;多态性&lt;/strong&gt; 同样的操作或者方法，不同的对象执行的时候表现出完全不同的行为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用父类指针或者引用指向子类的实例，然后再自雷中覆盖父类的方法，利用父类引用调用相同方法而产生不同的行为。&lt;/li&gt;
&lt;li&gt;多态的条件：a,必须存在继承关系，b,子类对父类的方法进行重写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}

class sonClass2:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    override func testFunc() {
        print(&amp;quot;sonClass2&amp;quot;)
    }
}


final class grandSon1:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}
final class grandSon01:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

final class grandSon02:sonClass2{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

func printBasicInfo(base:baseClass){
    print(&amp;quot;name is \(base.name)&amp;quot;)
}

var grandson1 = grandSon01.init(name: &amp;quot;a&amp;quot;, age: 10)
var grandson2 = grandSon02.init(name: &amp;quot;b&amp;quot;, age: 7)
printBasicInfo(base: grandson1)
printBasicInfo(base: grandson2)
grandson1.testFunc()
grandson2.testFunc()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-18 继承</title>
            <link>http://blog.flywithme.top/2017/04/01/swift18/</link>
            <pubDate>Sat, 01 Apr 2017 22:29:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/01/swift18/</guid>
            <description>&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：我们可以理解为一个类获取了另外一个类的方法和属性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类)，
我们也可以为类中继承来的属性添加属性观察器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基类&lt;/strong&gt; 没有继承其它类的类，称之为基类（Base Class）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类&lt;/strong&gt; 子类指的是在一个已有类的基础上创建一个新的类。为了指明某个类的超类，将超类名写在子类名的后面，用冒号(:)分隔,语法格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
}
sonClass.init(name: &amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重写（Overriding）&lt;/strong&gt; 子类可以通过继承来的实例方法，类方法，实例属性，或下标脚本来实现自己的定制功能，我们把这种行为叫重写（overriding）。我们可以使用 override 关键字来实现重&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
    var levelStr:String
    override init(name: String) {
        self.levelStr = name.appending(&amp;quot;b&amp;quot;)
        super.init(name: name)
    }
}

var son =  sonClass.init(name: &amp;quot;a&amp;quot;)
son.baseName
son.levelStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// &lt;strong&gt;防止重写&lt;/strong&gt;   使用 final 关键字防止它们被重写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //final 关键字
 final class grandSon:sonClass{
     final var grand:String = &amp;quot;&amp;quot;
     override init(name: String) {
         super.init(name: name)
     }
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-17 单例</title>
            <link>http://blog.flywithme.top/2017/03/31/swift17/</link>
            <pubDate>Fri, 31 Mar 2017 19:47:41 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/31/swift17/</guid>
            <description>&lt;p&gt;&lt;strong&gt;单例写法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Manager{
    public var score = 0
    public static let defaultManager = Manager.init()

    private init(){

    }
    public func addScore(){
        score += 10
    }
}




let manager = Manager.defaultManager

manager.addScore()
manager.score

manager.addScore()
manager.score
let manager2 = Manager.defaultManager
manager2.addScore()
manager2.score
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-16 属性</title>
            <link>http://blog.flywithme.top/2017/03/30/swift16/</link>
            <pubDate>Thu, 30 Mar 2017 16:53:45 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/30/swift16/</guid>
            <description>&lt;p&gt;Swift 属性将值跟特定的类、结构或枚举关联&lt;/p&gt;

&lt;p&gt;属性可分为存储属性和计算属性:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;存储属性&lt;/th&gt;
&lt;th&gt;计算属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存储常量或变量作为实例的一部分&lt;/td&gt;
&lt;td&gt;计算（而不是存储）一个值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于类和结构体&lt;/td&gt;
&lt;td&gt;用于类、结构体和枚举&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;存储属性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以在定义存储属性的时候指定默认值&lt;/li&gt;
&lt;li&gt;在构造过程中设置或修改存储值属性的值，身子修改常量存储属性的值
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;延迟存储属性&lt;/strong&gt; lazy property&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;延迟对象的创建&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当属性的值依赖于其他未知类&lt;/p&gt;

&lt;p&gt;class CloseRange{
    var start: Int
    var end:Int
    var width:Int{
        return end - start + 1
    }
    lazy var sum: Int = {
        var res = 0
        for i in self.start&amp;hellip;self.end{
            res += 1
        }
        return res
    }()
    var sum1: Int {
        var res = 0
        for i in start&amp;hellip;end{
            res += 1
        }
        return res
    }
    init?(start:Int, end:Int){
        if start &amp;gt; end{
            return nil
        }
        self.start = start
        self.end = end
    }
}
var range = CloseRange(start: 0, end: 10)!
range.sum
range.sum1
range.start = 1
range.sum  //不变
range.sum1 //每次都重新计算&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;计算属性&lt;/strong&gt; 除存储属性外，类、结构体和枚举可以定义计算属性，计算属性不直接存储值，而是提供一个 getter 来获取值，
一个可选的 setter 来间接设置其他属性或变量的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class sample {
    var no1 = 0.0, no2 = 0.0
    var length = 300.0, breadth = 150.0        
    var middle: (Double, Double) {
        get{
            return (length / 2, breadth / 2)
        }
        set(axis){
            no1 = axis.0 - (length / 2)
            no2 = axis.1 - (breadth / 2)
        }
    }
}
var result = sample()
print(result.middle)
result.middle = (0.0, 10.0)
print(result.no1)
print(result.no2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;只读计算属性&lt;/strong&gt; 只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点(.)运算符访问，但不能设置新的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class film {
    var head = &amp;quot;&amp;quot;
    var duration = 0.0
    var metaInfo: [String:String] {
        return [
            &amp;quot;head&amp;quot;: self.head,
            &amp;quot;duration&amp;quot;:&amp;quot;\(self.duration)&amp;quot;
        ]
    }
}
var movie = film()
movie.head = &amp;quot;肖申克救赎&amp;quot;
movie.duration = 3.09

print(movie.metaInfo[&amp;quot;head&amp;quot;]!)
print(movie.metaInfo[&amp;quot;duration&amp;quot;]!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;属性观察器&lt;/strong&gt;  属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Samplepgm {
    var counter: Int = 0{
        willSet(newTotal){
            print(&amp;quot;计数器: \(newTotal)&amp;quot;)
        }
        didSet{
            if counter &amp;gt; oldValue {
                print(&amp;quot;新增数 \(counter - oldValue)&amp;quot;)
            }
        }
    }
}
let NewCounter = Samplepgm()
NewCounter.counter = 100
NewCounter.counter = 800
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;willSet在设置新的值之前调用&lt;/li&gt;
&lt;li&gt;didSet在新的值被设置之后立即调用&lt;/li&gt;
&lt;li&gt;willSet和didSet观察器在属性初始化过程中不会被调用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;全局变量和局部变量&lt;/strong&gt;  计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;局部变量&lt;/th&gt;
&lt;th&gt;全局变量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在函数、方法或闭包内部定义的变量。&lt;/td&gt;
&lt;td&gt;函数、方法、闭包或任何类型之外定义的变量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于存储和检索值。  用于存储和检索值。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;**类型属性 类型方法 ** 类型属性是作为类型定义的一部分写在类型最外层的花括号（{}）内。使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Player{
    var name:String
    var score = 0
    static var heighestScore = 0
    init(name:String) {
        self.name = name
    }
    func play() {
        let score = arc4random()%100
        print(&amp;quot;\(name) played and got \(score) score&amp;quot;)
        self.score += Int(score)
        Player.heighestScore = Player.heighestScore &amp;gt; self.score ? Player.heighestScore:self.score
        print(&amp;quot;Highest Score is \(Player.heighestScore)&amp;quot;)
    }

     static func heightScore(){
        print(&amp;quot;Highest Score is == \(Player.heighestScore)&amp;quot;)
     }
}
var play1 = Player.init(name: &amp;quot;Player1&amp;quot;)
var play2 = Player.init(name: &amp;quot;Player2&amp;quot;)

play1.play()
play2.play()
Player.heighestScore
Player.heightScore()


play1.play()
play2.play()
Player.heighestScore

play1.play()
play2.play()
Player.heighestScore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问控制&lt;/strong&gt; public internal private&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UI{
    private var fontColor: UIColor!
    var backGroundColor: UIColor!
    var themeMode:Theme = .DayMode{
        didSet{
            self.changetheme(themeModel: themeMode)
        }

    }

    private func changetheme(themeModel:Theme) {
        switch themeModel {
        case .DayMode:
            fontColor = UIColor.black
            backGroundColor = UIColor.orange
        case .NightMode:
            fontColor = UIColor.gray
            backGroundColor = UIColor.lightGray
        }
    }

    init(){
        self.themeMode = .DayMode
        self.changetheme(themeModel: self.themeMode)
    }

    init(themeMode:Theme) {
        self.themeMode = themeMode
        self.changetheme(themeModel: themeMode)
    }
}

let ui = UI()
ui.themeMode
ui.backGroundColor
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-15 类</title>
            <link>http://blog.flywithme.top/2017/03/29/swift15/</link>
            <pubDate>Wed, 29 Mar 2017 14:18:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/29/swift15/</guid>
            <description>&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;：Swift 类是构建代码所用的一种通用且灵活的结构体。我们可以为类定义属性和方法。
    与其他编程语言不同的是,Swift 并不要求你为自定义的类去创建独立的接口和实现文件，
    你要做的是在一个单一文件中定义一个类，系统会自动生产面向其他代码的外部接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
    var firstName:String = &amp;quot;&amp;quot;
    var lastName:String = &amp;quot;&amp;quot;
}

class Person1{
    var firstName:String
    var lastName:String
    init(firstName:String, lastName:String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}
let person1 = Person1.init(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;类和结构体的对比&lt;/strong&gt;&lt;br /&gt;
 共同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义属性用于存储值&lt;/li&gt;
&lt;li&gt;定义方法用于提供功能&lt;/li&gt;
&lt;li&gt;定义附属脚本用于访问值&lt;/li&gt;
&lt;li&gt;定义构造器用于生成初始化值&lt;/li&gt;
&lt;li&gt;通过扩展以增加默认实现的功能&lt;/li&gt;
&lt;li&gt;符合协议以对某类提供标准功能
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比结构体多了如下功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许一个类继承另一个类的特征&lt;/li&gt;
&lt;li&gt;类型转换允许在运行时检查和解释一个类的实例类型&lt;/li&gt;
&lt;li&gt;结构器允许一个实例释放任何其所分配的资源&lt;/li&gt;
&lt;li&gt;引用计数允许对一个类多次引用
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区别：引用类型和值类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
   var firstName:String = &amp;quot;&amp;quot;
   var lastName:String = &amp;quot;&amp;quot;
}

let person1 = Person(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
let person2 = person1
person2.firstName = &amp;quot;abc&amp;quot;
person1.firstName  // &amp;quot;abc&amp;quot;  person1 和 person2 是引用关系 指向同一个内存空间
let person3 = Person(firstName: &amp;quot;abc&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)

struct Location{
    var latitude:Double
    var longitude:Double
}

var aLocation = Location.init(latitude: 2.0, longitude: 3.0)
var blocation = aLocation
blocation.latitude = 1.0
aLocation.latitude    // 2.0  aLocation 和 bloaction 是值类型关系，赋值是拷贝，产生一个新的副本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;恒等运算符&lt;/strong&gt;  因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例.
          为了能够判定两个常量或者变量是否引用同一个类实例，Swift 内建了两个恒等运算符：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;===&lt;/code&gt;: 如果两个常量或者变量引用同一个类实例则返回 true&lt;br /&gt;
      &lt;code&gt;!==&lt;/code&gt;: 如果两个常量或者变量引用不同一个类实例则返回 true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; person1 === person2   //true
 person1 === person3   //false
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-14 结构体</title>
            <link>http://blog.flywithme.top/2017/03/23/swift3-14/</link>
            <pubDate>Thu, 23 Mar 2017 16:54:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/23/swift3-14/</guid>
            <description>&lt;p&gt;Swift 结构体是构建代码所用的一种通用且灵活的构造体。我们可以为结构体定义属性（常量、变量）和添加方法，从而扩展结构体的功能.&lt;br /&gt;
与 C 和 Objective-C 不同的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体不需要包含实现文件和接口&lt;/li&gt;
&lt;li&gt;结构体允许我们创建一个单一文件,且系统会自动生成面向其他代码的外部接口
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct MarkStruct{
   var mark1: Int
   var mark2: Int
   var mark3: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结构体应用&lt;/strong&gt;  需要注意的以下几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体的主要目的是用来封装少了相关简单数据&lt;/li&gt;
&lt;li&gt;有理由预计一个结构体实例在赋值和传递时,封装的数据将会被拷贝而不是被引用&lt;/li&gt;
&lt;li&gt;任何在结构体中存储的值类型属性,也将会被拷贝,而不是被引用。&lt;/li&gt;
&lt;li&gt;结构体不需要去继承另一个已存在类型的属性或者行为。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说就是:结构体实例是通过值传递,而不是通过引用传递。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude:Double
    var longitude:Double
}
let aLocation = Location(latitude: 12.0,longitude: 212.0)
var bLoaction = Location.init(latitude: 1.2, longitude: 1.3)
struct Place{
    var location:Location
    var name:String
}

var aPlace = Place.init(location: bLoaction, name: &amp;quot;苹果总部&amp;quot;)
bLoaction.latitude = 37.3230
bLoaction.longitude = -122.0332
print(aPlace)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude : Double
    var longitude: Double

    init?(coordinateString:  String) {
         guard
            let commIndex = coordinateString.range(of: &amp;quot;,&amp;quot;),
            let first = Double(coordinateString.substring(to: commIndex.lowerBound)),
            let second = Double(coordinateString.substring(from: commIndex.upperBound))
            else {
                return nil
        }

        self.latitude = first
        self.longitude = second
    }
    init(latitude:Double, longitude:Double) {
        self.latitude = latitude
        self.longitude = longitude

    }
    func printLocation() {
        print(&amp;quot;The Location is \(self.latitude), \(self.longitude)&amp;quot;)
    }
    func isNoth() -&amp;gt; Bool {
         self.printLocation()
         return self.latitude &amp;gt; 0
    }
}
let location = Location(coordinateString: &amp;quot;21,23&amp;quot;)
location?.latitude
location?.longitude
let location2 = Location(latitude: 25.222,longitude: 122.23222)
location2.isNoth()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-13 枚举</title>
            <link>http://blog.flywithme.top/2017/03/21/swift13/</link>
            <pubDate>Tue, 21 Mar 2017 15:30:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/21/swift13/</guid>
            <description>&lt;p&gt;枚举简单的说也是一种数据类型，只不过是这种数据类型只包含自定义的特定数据，它是一组有共同特性的数据的集合。
Swift 的枚举类似于 Objective C 和 C 的结构&lt;/p&gt;

&lt;p&gt;枚举的功能为&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它声明在类中,可以通过实例化类来访问它的值.&lt;br /&gt;
  枚举也可以定义构造函数来提供一个初始成员值,可以在原始的实现基础上扩展它功能。&lt;br /&gt;
  可以遵守协议来提供标准的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义枚举
enum DaysofaWeek {
    case Sunday
    case Monday
    case TUESDAY
    case WEDNESDAY
    case THURSDAY
    case FRIDAY
    case Saturday
}
var weekDay = DaysofaWeek.THURSDAY
weekDay = .THURSDAY
switch weekDay
{
case .Sunday:
    print(&amp;quot;星期天&amp;quot;)
case .Monday:
    print(&amp;quot;星期一&amp;quot;)
case .TUESDAY:
    print(&amp;quot;星期二&amp;quot;)
case .WEDNESDAY:
    print(&amp;quot;星期三&amp;quot;)
case .THURSDAY:
    print(&amp;quot;星期四&amp;quot;)
case .FRIDAY:
    print(&amp;quot;星期五&amp;quot;)
case .Saturday:
    print(&amp;quot;星期六&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值与原始值的区别&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;相关值&lt;/th&gt;
&lt;th&gt;原始值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不同数据类型&lt;/td&gt;
&lt;td&gt;相同数据类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;值的创建基于常量或变量&lt;/td&gt;
&lt;td&gt;预先填充的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;相关值是当你在创建一个枚举成员的心常量或变量时才会被设置,并且每次当你这么做的时候,它的值都不同&lt;/td&gt;
&lt;td&gt;原始值试着是相同的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;原始值&lt;/strong&gt; Raw value  原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的.在原始值为整数的枚举时，不需要显式的为每一个成员赋值，Swift会自动为你赋值。&lt;/p&gt;

&lt;p&gt;例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Month: Int {
    case January = 1, February, March, April, May, June, July, August, September, October, November, December
}

let yearMonth = Month.May.rawValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值&lt;/strong&gt; Associate Value 以下实例中我们定义一个名为 Student 的枚举类型，它可以是 Name 的一个相关值（Int，Int，Int，Int），或者是 Mark 的一个字符串类型（String）相关值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Student{
    case Name(String)
    case Mark(Int,Int,Int)
}
var studDetails = Student.Name(&amp;quot;Runoob&amp;quot;)
var studMarks = Student.Mark(98,97,95)
switch studMarks {
case .Name(let studName):
    print(&amp;quot;学生的名字是: \(studName)。&amp;quot;)
case .Mark(let Mark1, let Mark2, let Mark3):
    print(&amp;quot;学生的成绩是: \(Mark1),\(Mark2),\(Mark3)。&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选型的实质就是枚举&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//public enum Optional&amp;lt;Wrapped&amp;gt;
var website: Optional&amp;lt;String&amp;gt; = Optional.some(&amp;quot;www.dianping.com&amp;quot;)
website = .none   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;枚举递归&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indirect enum ArithmeticExpression{
indirect enum ArithmeticExpression{
    case Number(Int)
    case Addition(ArithmeticExpression, ArithmeticExpression)
    case Multiplication(ArithmeticExpression, ArithmeticExpression)
}

let five = ArithmeticExpression.Number(5)
let two = ArithmeticExpression.Number(2)
let sum = ArithmeticExpression.Addition(five, two)
let product = ArithmeticExpression.Multiplication(sum, two)

func evaluate(expression:ArithmeticExpression) -&amp;gt; Int{
    switch expression {
    case let .Number(value):
        return value
    case let .Addition(left,right):
        return evaluate(expression: left) + evaluate(expression: right)
    case let .Multiplication(left,right):
        return evaluate(expression: left)*evaluate(expression: right)
    }
} 
evaluate(expression: product)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-12 闭包</title>
            <link>http://blog.flywithme.top/2017/02/28/swift12/</link>
            <pubDate>Tue, 28 Feb 2017 17:43:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/28/swift12/</guid>
            <description>&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;
  闭包(Closures)是自包含的功能代码块,可以在代码中使用或者用来传参传值。
   Swift 的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。
   全局函数和嵌套函数其实就是特殊的闭包。&lt;/p&gt;

&lt;p&gt;闭包的形式有&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;全局函数&lt;/strong&gt;:    有名字但不能捕获任何值&lt;br /&gt;
   &lt;strong&gt;嵌套函数&lt;/strong&gt;:    有名字,可以捕获封闭函数内的值&lt;br /&gt;
   &lt;strong&gt;闭包表达式&lt;/strong&gt;:  无名闭包,使用轻量级语法,可以根据上下文环境捕获值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let clousuer = { print(&amp;quot;Swift 闭包实例。&amp;quot;) }
clousuer()


//加法
let sum = {(val1:Int, val2:Int)-&amp;gt; Int in
        return val1 + val2
}
let result = sum(20,2)

//排序
var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}
arr.sorted(by: {(a: Int, b:Int) -&amp;gt; Bool in

    return a &amp;gt; b
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包的简化&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简化: 根据现场情况,选择适合当前情况的写法。
arr.sort(by:{a, b in return a &amp;gt; b}) //因为只能是 Int 类型的,可以省去声明
arr
arr.sort(by:{a, b in  a &amp;lt; b})  //省去 Return
arr
arr.sort(by: {$0&amp;gt;$1}) //$0, $1(从0开始，表示第i个参数...) 省去参数,直接使用简化参数名
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运算符函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.sort(by: &amp;lt;) //可以这样写的原因是 Swift中,&amp;gt; &amp;lt; = + - 等,本身就是函数
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;尾随闭包&lt;/strong&gt;  Trailing closure syntax   尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//把闭包写在()外边
arr.sorted(){a, b in
    return a &amp;gt; b
}
//由于么有参数需要传入,()也可以省略
arr.sorted{a, b in
    return a &amp;gt; b
}
arr.sorted{$0 &amp;gt; $1}


//实现一个小动画
import UIKit
import XCPlayground

let showView = UIView(frame:CGRect(x:0,  y:0, width:300, height:300))
let rectAngle = UIView(frame:CGRect(x:0,  y:0, width:50, height:50))
rectAngle.center = showView.center
showView.backgroundColor = UIColor .white
rectAngle.backgroundColor = UIColor.red
showView.addSubview(rectAngle)
XCPlaygroundPage.currentPage.liveView = showView
UIView.animate(withDuration: 4.0, animations: {
    rectAngle.backgroundColor = UIColor.orange
    rectAngle.frame = CGRect(x:0,  y:0, width:300, height:300)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;内容捕获&lt;/strong&gt;   闭包可以在其定义的上下文中捕获常量或变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

var num = 300
arr.sorted{
    a, b in abs(a - num) &amp;lt; abs(b - num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包是引用类型&lt;/strong&gt;  无论您将函数/闭包赋值给一个常量还是变量，实际上都是将常量/变量的值设置为对应函数/闭包的引用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func makeIncrementor(forIncrement amount: Int) -&amp;gt; () -&amp;gt; Int {
    var runningTotal = 0
    func incrementor() -&amp;gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// 返回的值为10
incrementByTen()

// 返回的值为20
incrementByTen()

// 返回的值为30
incrementByTen()

// 返回的值为40
incrementByTen()

let alsoIncrementByTen = incrementByTen

// 返回的值为50
print(alsoIncrementByTen())
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-11 函数</title>
            <link>http://blog.flywithme.top/2017/02/27/swift11/</link>
            <pubDate>Mon, 27 Feb 2017 13:41:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/27/swift11/</guid>
            <description>&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Swift 定义函数使用关键字 func。
  定义函数的时候，可以指定一个或多个输入参数和一个返回值类型。
  每个函数都有一个函数名来描述它的功能。通过函数名以及对应类型的参数值来调用这个函数。函数的参数传递的顺序必须与参数列表相同。
  函数的实参传递的顺序必须与形参列表相同，-&amp;gt; 后定义函数的返回值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func hello(name:String)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + name
}

hello(name: &amp;quot;Jack&amp;quot;)    


func hello1(name:String?)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + (name != nil  ? name! : &amp;quot;guess&amp;quot;)
}

hello1(name: &amp;quot;Jack&amp;quot;)


func printHello(){
    print(&amp;quot;hello&amp;quot;)
}
printHello()

func printHello1() -&amp;gt; Void{  //Void 是一个类型
    print(&amp;quot;hello&amp;quot;)
}
printHello1()

func printHello2() -&amp;gt; (){
    print(&amp;quot;hello&amp;quot;)
}
printHello2()    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用元组作为返回值&lt;/strong&gt;  函数返回值的类型可以是字符串,整型,浮点型等,元组与数组类似,不同的是,元组中的元素可以是任意类型,使用的是括号,你可以使用元组类型让多个值作为一个复合值从函数中返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMaxAndMin(numbers:[Int]) -&amp;gt; (max:Int, min:Int)?{ //如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型。
    guard !numbers.isEmpty else {
        return (Int.max,Int.min)
    }
    var minValue = numbers[0]
    var maxValue = numbers[0]
    for num in numbers{
        minValue = minValue &amp;lt; num ? minValue : num
        maxValue =  maxValue &amp;gt; num ? maxValue : num
    }
    return (maxValue ,minValue)
}
var numbers = [1,23,34,2,2,31,23,23,34,45,454545,4,54,5,45,45,45]
var result =  findMaxAndMin(numbers: numbers)
print(result?.max ?? 0,result?.min ?? 0)  
if let result =  findMaxAndMin(numbers: numbers) {
    print( result.max,result.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数的内部参数和外部参数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHelloTo(name:String, msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;)  //sayHelloTo(&amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;) 这种方式已被废弃

//内部参数和外部参数
func sayHelloTo(name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//修改外部参数名
func sayHello(to name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//隐藏调用参数
func mutiply(_ num1:Int, _ num2:Int) -&amp;gt; Int{
    return num1*num2
}
mutiply(2,  4) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认参数值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;) //可以省略后面的一个参数


func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;, punctuation:String = &amp;quot;!&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name) \(punctuation)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;)
sayHello(to: &amp;quot;Jack&amp;quot;, withMessage: &amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可变参数值&lt;/strong&gt; 一个函数至多只可以有一个变长的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//常用的变长参数函数
print(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
//求平均值
func mean(numbers:Double ...) -&amp;gt;Double{
    var sum : Double = 0
    for num in numbers{
        sum += num
    }
    return sum / Double(numbers.count)
}
mean(numbers: 1,2,3,4,5,5.0,23,434)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量参数,变量参数和 inout 参数&lt;/strong&gt; 默认的函数参数都是常量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func toBinary(num:Int)-&amp;gt;String{ //直接声明称 var 类型参数已被废弃。
    var num = num  
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
toBinary(num: 1000)

//inout 
func toBinary( num:inout Int)-&amp;gt;String{
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
var num = 100
toBinary(num: &amp;amp;num) //传入指针
print(num) 

//交换两个字符串
func swapTwoString(str1:inout String, str2:inout String){
    let tstr = str1
    str1 = str2
    str2 = tstr
}

var str1 = &amp;quot;a&amp;quot;
var str2 = &amp;quot;b&amp;quot;
swapTwoString(str1: &amp;amp;str1, str2:&amp;amp;str2)
str1
str2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数型变量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int, b:Int) -&amp;gt; Int{
    return a + b
}

let add01 = add
add01(3,4)
let add02:(Int, Int) -&amp;gt; Int = add
add02(4,5)


var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

arr.sort { (a, b) -&amp;gt; Bool in
    return a &amp;lt; b
}
arr

func descending (a:Int ,b:Int) -&amp;gt;Bool{
    return a &amp;gt; b
}
arr.sorted(by: descending)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数变成初步&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeScores( scors: [Int], by method:(Int)-&amp;gt; Int) -&amp;gt; [Int]{
    var arr = scors
    for (index , score) in scors.enumerated(){
        arr[index] = method(score)
    }
    return arr
}
func changeScore01 (score : Int) -&amp;gt; Int{
    return score + 3
}

func changeScore02 (score : Int) -&amp;gt; Int{
    return Int(Double(score)/150.0*100.0)
}

var arr:[Int] = []
for _ in 0..&amp;lt;10{
    arr.append(Int(arc4random())%150)
}
arr
changeScores(scors: arr, by: changeScore01)
changeScores(scors: arr, by: changeScore02)
//map 
arr.map(changeScore01)
func isPassOrFail(score:Int)-&amp;gt;String{
    return score &amp;lt; 60 ? &amp;quot;Fail&amp;quot;: &amp;quot;Pass&amp;quot;
}
arr.map(isPassOrFail)

//filter 过滤
func fail (score:Int)-&amp;gt; Bool{
    return score &amp;lt; 60
}
arr.filter(fail)

//reduce 聚合
func add(a:Int, b:Int)-&amp;gt; Int{
    return a + b
}
arr.reduce(0, add)

arr.reduce(0, +)

//Swift中,运算符号 本质上就是一个函数 
public func +(lhs: Int, rhs: Int) -&amp;gt; Int
public func *(lhs: Int, rhs: Int) -&amp;gt; Int
public func -(lhs: Int, rhs: Int) -&amp;gt; Int
public func /(lhs: Int, rhs: Int) -&amp;gt; Int
public func %(lhs: Int, rhs: Int) -&amp;gt; Int


func concatenate(str:String , num:Int) -&amp;gt; String{
    return &amp;quot;\(str)\(num) &amp;quot;
}
arr.reduce(&amp;quot;&amp;quot;, concatenate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;返回函数类型和函数嵌套&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//邮递费用
func tilerMailfeeByWight( weight : Int) -&amp;gt; Int{
    return 1*weight
}
func tiler2MailfeeByWight( weight : Int) -&amp;gt; Int{
    return 3*weight
}
//超过10单位，则按三倍计算
func feeBytUnitPrice (price :Int , wight:Int) -&amp;gt; Int{
    py
    func chooseMailFeeCalationByWeight(weight: Int) -&amp;gt; (Int) -&amp;gt; Int{
        return weight &amp;lt;= 10 ? tilerMailfeeByWight : tiler2MailfeeByWight
    }

    let mailFeefuc = chooseMailFeeCalationByWeight(weight: wight)
    return mailFeefuc(wight) + price*wight //邮递费用+商品费用
}
feeBytUnitPrice(price: 2, wight: 11)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
