<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Fly With Me</title>
        <link>http://blog.flywithme.top/post/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 27 Feb 2017 13:41:21 CST</updated>
        
        <item>
            <title>swift3-11 函数</title>
            <link>http://blog.flywithme.top/2017/02/27/swift11/</link>
            <pubDate>Mon, 27 Feb 2017 13:41:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/27/swift11/</guid>
            <description>&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Swift 定义函数使用关键字 func。
  定义函数的时候，可以指定一个或多个输入参数和一个返回值类型。
  每个函数都有一个函数名来描述它的功能。通过函数名以及对应类型的参数值来调用这个函数。函数的参数传递的顺序必须与参数列表相同。
  函数的实参传递的顺序必须与形参列表相同，-&amp;gt; 后定义函数的返回值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func hello(name:String)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + name
}

hello(name: &amp;quot;Jack&amp;quot;)    


func hello1(name:String?)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + (name != nil  ? name! : &amp;quot;guess&amp;quot;)
}

hello1(name: &amp;quot;Jack&amp;quot;)


func printHello(){
    print(&amp;quot;hello&amp;quot;)
}
printHello()

func printHello1() -&amp;gt; Void{  //Void 是一个类型
    print(&amp;quot;hello&amp;quot;)
}
printHello1()

func printHello2() -&amp;gt; (){
    print(&amp;quot;hello&amp;quot;)
}
printHello2()    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用元组作为返回值&lt;/strong&gt;  函数返回值的类型可以是字符串,整型,浮点型等,元组与数组类似,不同的是,元组中的元素可以是任意类型,使用的是括号,你可以使用元组类型让多个值作为一个复合值从函数中返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMaxAndMin(numbers:[Int]) -&amp;gt; (max:Int, min:Int)?{ //如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型。
    guard !numbers.isEmpty else {
        return (Int.max,Int.min)
    }
    var minValue = numbers[0]
    var maxValue = numbers[0]
    for num in numbers{
        minValue = minValue &amp;lt; num ? minValue : num
        maxValue =  maxValue &amp;gt; num ? maxValue : num
    }
    return (maxValue ,minValue)
}
var numbers = [1,23,34,2,2,31,23,23,34,45,454545,4,54,5,45,45,45]
var result =  findMaxAndMin(numbers: numbers)
print(result?.max ?? 0,result?.min ?? 0)  
if let result =  findMaxAndMin(numbers: numbers) {
    print( result.max,result.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数的内部参数和外部参数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHelloTo(name:String, msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;)  //sayHelloTo(&amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;) 这种方式已被废弃

//内部参数和外部参数
func sayHelloTo(name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//修改外部参数名
func sayHello(to name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//隐藏调用参数
func mutiply(_ num1:Int, _ num2:Int) -&amp;gt; Int{
    return num1*num2
}
mutiply(2,  4) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认参数值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;) //可以省略后面的一个参数


func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;, punctuation:String = &amp;quot;!&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name) \(punctuation)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;)
sayHello(to: &amp;quot;Jack&amp;quot;, withMessage: &amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可变参数值&lt;/strong&gt; 一个函数至多只可以有一个变长的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//常用的变长参数函数
print(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
//求平均值
func mean(numbers:Double ...) -&amp;gt;Double{
    var sum : Double = 0
    for num in numbers{
        sum += num
    }
    return sum / Double(numbers.count)
}
mean(numbers: 1,2,3,4,5,5.0,23,434)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量参数,变量参数和 inout 参数&lt;/strong&gt; 默认的函数参数都是常量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func toBinary(num:Int)-&amp;gt;String{ //直接声明称 var 类型参数已被废弃。
    var num = num  
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
toBinary(num: 1000)

//inout 
func toBinary( num:inout Int)-&amp;gt;String{
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
var num = 100
toBinary(num: &amp;amp;num) //传入指针
print(num) 

//交换两个字符串
func swapTwoString(str1:inout String, str2:inout String){
    let tstr = str1
    str1 = str2
    str2 = tstr
}

var str1 = &amp;quot;a&amp;quot;
var str2 = &amp;quot;b&amp;quot;
swapTwoString(str1: &amp;amp;str1, str2:&amp;amp;str2)
str1
str2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数型变量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int, b:Int) -&amp;gt; Int{
    return a + b
}

let add01 = add
add01(3,4)
let add02:(Int, Int) -&amp;gt; Int = add
add02(4,5)


var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

arr.sort { (a, b) -&amp;gt; Bool in
    return a &amp;lt; b
}
arr

func descending (a:Int ,b:Int) -&amp;gt;Bool{
    return a &amp;gt; b
}
arr.sorted(by: descending)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数变成初步&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeScores( scors: [Int], by method:(Int)-&amp;gt; Int) -&amp;gt; [Int]{
    var arr = scors
    for (index , score) in scors.enumerated(){
        arr[index] = method(score)
    }
    return arr
}
func changeScore01 (score : Int) -&amp;gt; Int{
    return score + 3
}

func changeScore02 (score : Int) -&amp;gt; Int{
    return Int(Double(score)/150.0*100.0)
}

var arr:[Int] = []
for _ in 0..&amp;lt;10{
    arr.append(Int(arc4random())%150)
}
arr
changeScores(scors: arr, by: changeScore01)
changeScores(scors: arr, by: changeScore02)
//map 
arr.map(changeScore01)
func isPassOrFail(score:Int)-&amp;gt;String{
    return score &amp;lt; 60 ? &amp;quot;Fail&amp;quot;: &amp;quot;Pass&amp;quot;
}
arr.map(isPassOrFail)

//filter 过滤
func fail (score:Int)-&amp;gt; Bool{
    return score &amp;lt; 60
}
arr.filter(fail)

//reduce 聚合
func add(a:Int, b:Int)-&amp;gt; Int{
    return a + b
}
arr.reduce(0, add)

arr.reduce(0, +)

//Swift中,运算符号 本质上就是一个函数 
public func +(lhs: Int, rhs: Int) -&amp;gt; Int
public func *(lhs: Int, rhs: Int) -&amp;gt; Int
public func -(lhs: Int, rhs: Int) -&amp;gt; Int
public func /(lhs: Int, rhs: Int) -&amp;gt; Int
public func %(lhs: Int, rhs: Int) -&amp;gt; Int


func concatenate(str:String , num:Int) -&amp;gt; String{
    return &amp;quot;\(str)\(num) &amp;quot;
}
arr.reduce(&amp;quot;&amp;quot;, concatenate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;返回函数类型和函数嵌套&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//邮递费用
func tilerMailfeeByWight( weight : Int) -&amp;gt; Int{
    return 1*weight
}
func tiler2MailfeeByWight( weight : Int) -&amp;gt; Int{
    return 3*weight
}
//超过10单位，则按三倍计算
func feeBytUnitPrice (price :Int , wight:Int) -&amp;gt; Int{

    func chooseMailFeeCalationByWeight(weight: Int) -&amp;gt; (Int) -&amp;gt; Int{
        return weight &amp;lt;= 10 ? tilerMailfeeByWight : tiler2MailfeeByWight
    }

    let mailFeefuc = chooseMailFeeCalationByWeight(weight: wight)
    return mailFeefuc(wight) + price*wight //邮递费用+商品费用
}
feeBytUnitPrice(price: 2, wight: 11)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-10 数据集合小节</title>
            <link>http://blog.flywithme.top/2017/02/22/swift10/</link>
            <pubDate>Wed, 22 Feb 2017 16:15:18 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift10/</guid>
            <description>&lt;p&gt;&lt;strong&gt;选择合适的数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;有序,最大的特定就是有序,如果我们操作的元素是有序的话,使用数组是最方便的。如果需要排序,最好也选择数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;集合&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;无序,唯一性,集合特有的操作,快速查找 如果需要做一些特殊的集合计算,就使用集合,比如在做用户特性分析的时候,分组的时候就可以使用
          集合,获取共同喜好,共同兴趣等。快速查找这个是集合的一大优势,数组查找复杂度是 O(n), 而集合的复杂度是 O(log2(n)),
          例如一个100万的数据,如果是数组查找的话,最坏的情况是
             查找100万次,而集合的最大次数是 log2(1000000) 大约是20次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字典&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;键值数据对,这个就不说了,使用的很广泛。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;回顾&lt;/strong&gt; &lt;code&gt;for in&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...10{
    print(index)
}

for c in &amp;quot;hello&amp;quot;.characters{
    print(c)
}

var arr = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
for str in arr{
    print(str)
}

for (index ,str) in arr.enumerated(){
    print(index, str)
}

var dic = [1:&amp;quot;a&amp;quot; , 2:&amp;quot;b&amp;quot;]
for key in dic{
    print(key)
}
for value in dic.values{
    print(value)
}

for (key, value) in dic{
    print(key,value)
}

var setA = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] as Set
for str in setA{
    print(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;还有很多没有涉及到的方法。这些方法需要我们在开发的过程中,慢慢学习了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-09 集合</title>
            <link>http://blog.flywithme.top/2017/02/22/swift09/</link>
            <pubDate>Wed, 22 Feb 2017 15:18:43 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift09/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;将一些元素放在一起,它们是无序的, 跟数组的不同是,数组是一个有序的列表,而集合是一个有序的数据集&lt;br /&gt;
   为什么需要集合,因为集合是无序的,所以,在做一些查找和判重的时候,效率会有差别。集合会有一些,比数组使用起来方便很多。
   &lt;strong&gt;集合中的每一个元素都是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//集合的初始化
var arr = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;] //如果不显式的声明,则默认是数组
var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  //必须显式声明才行

var emptySet1:Set&amp;lt;String&amp;gt; = []
var emptySet2 = Set&amp;lt;Int&amp;gt;()

var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;c&amp;quot;]) //将一个数组转换成集合 


setA.count
setA.isEmpty
setA.first //随机的取出一个元素

setA.contains(&amp;quot;a&amp;quot;) //判断是否有这个元素
//遍历    
for str in setA{
    print(str)
}

var str = setA.joined(separator: &amp;quot;d&amp;quot;)

//比较
setA == setB
setA.elementsEqual(setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集合的操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  
//插入
setA.insert(&amp;quot;D&amp;quot;) //返回一个元组
//更新
setA.update(with: &amp;quot;A&amp;quot;) //若已存在元素,则返回改元素,若没有,则返回nil
//删除
setA.remove(&amp;quot;a&amp;quot;) //返回一个 bool 若是 true 则表示删除成功,返回 false 则表示之前没有这个元素
setA.removeAll() 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;并集: &lt;code&gt;union&lt;/code&gt; (不改变调用者的集合), &lt;code&gt;formUnion&lt;/code&gt;  (改变调用者的集合)  两个集合中的所有元素集合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]
var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]) //将一根数组转换成集合

var setC =  setA.union(setB)  //setC 有 setA和 setB 所有元素,但是setA 不变
setA.union([&amp;quot;a&amp;quot;])

setA
setA.formUnion(setB) //setA 被改变
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;交集: &lt;code&gt;intersect&lt;/code&gt;(不改变调用者的集合),  &lt;code&gt;formIntersection&lt;/code&gt; (改变调用者的集合) 两个集合的公共部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.intersection(setB)
setA

setA.formIntersection(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;补集(差集): 做减法  &lt;code&gt;subtracting&lt;/code&gt; (不改变调用者的集合) &lt;code&gt;subtract&lt;/code&gt; (改变调用者的集合)   调用者不包含在被调用者中的部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.subtracting(setB)  //setA 独有的,而 setB 没有的元素 不改变 setA 值
setA

setA.subtract(setB) //setA 独有的,而 setB 没有的元素 改变 setA 值
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;去重: &lt;code&gt;symmetricDifference&lt;/code&gt;(不改变调用者的集合), &lt;code&gt;formSymmetricDifference&lt;/code&gt; (改变调用者的集合),   去除两个集合中相同的部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.symmetricDifference(setB)
setA
setA.formSymmetricDifference(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;子集: &lt;code&gt;isSbuset&lt;/code&gt; 子集, &lt;code&gt;isStrictSubset&lt;/code&gt; 真子集  判断是否是另外一个集合的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSubset(of: setB)
setA.isStrictSubset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;超集: &lt;code&gt;isSuperset&lt;/code&gt;超集 ,  &lt;code&gt;isStrictSuperset&lt;/code&gt; 真超集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSuperset(of: setB)
setA.isStrictSuperset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;相离:  &lt;code&gt;isDisjoint&lt;/code&gt; 没有重叠的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isDisjoint(with: setB)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-08 字典</title>
            <link>http://blog.flywithme.top/2017/02/22/swift08/</link>
            <pubDate>Wed, 22 Feb 2017 14:12:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift08/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;字典是存储 键-值 数据对的无序数据集合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
    dic[&amp;quot;key&amp;quot;]
var value = dic[&amp;quot;key&amp;quot;] //返回的 value 是一个可选型
    value = dic[&amp;quot;daaaa&amp;quot;]

    dict.isEmpty
    dict.count  

if let value = dic[&amp;quot;key&amp;quot;]{
    print(value)
 }    

var dict:[String:Int] = [&amp;quot;1&amp;quot;:1,&amp;quot;2&amp;quot;:2]
    dict[&amp;quot;1&amp;quot;]



var dict01:[Int:Int] = [1:1,2:2]
    dict01[1]

var dict02:[Int:Any] = [1:1,2:&amp;quot;a&amp;quot;]
    dict02[1]    

//遍历   
for (key, value) in dict{
        print(key,value)
}   

//比较
var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
dic[&amp;quot;key&amp;quot;]
var dic2 = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
dic2[&amp;quot;key&amp;quot;]dict == dict01
dic == dic2  //true  如果 元素类型不同,比较会抛错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;增删改查&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
//查
dic[&amp;quot;key&amp;quot;]

//修改
dic[&amp;quot;key&amp;quot;]= &amp;quot;a&amp;quot;
//增加
dic[&amp;quot;c&amp;quot;] = &amp;quot;c&amp;quot; //若之前没有响应的 Key 则会添加
dic.updateValue(&amp;quot;d&amp;quot;, forKey: &amp;quot;d&amp;quot;)

//删除    
dic.removeValue(forKey: &amp;quot;key&amp;quot;)
if let key = dic.removeValue(forKey: &amp;quot;key&amp;quot;){
    print(&amp;quot;删除成功&amp;quot;)
}

//删除所有
dic.removeAll()


var str =  dic.updateValue(&amp;quot;value&amp;quot;, forKey: &amp;quot;key&amp;quot;) //返回值是原始值 str 的值是 &amp;quot;a&amp;quot;

//问题
 if  dic.updateValue(&amp;quot;jack01&amp;quot;, forKey: &amp;quot;nick&amp;quot;) == dic[&amp;quot;nick&amp;quot;] {
        print(&amp;quot;新旧昵称一样&amp;quot;)  //会不会打印出来?
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-07 数组</title>
            <link>http://blog.flywithme.top/2017/02/21/swift07/</link>
            <pubDate>Tue, 21 Feb 2017 15:38:45 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/21/swift07/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;数组是 Swift 三种最基本的数据集合的一种,这三种集合分别是: &lt;code&gt;Array Dictionary set&lt;/code&gt;
数组的概念就是一个有序的数据序列,概念很简单,我们已经很熟悉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;初始化方式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var numbers = [0,1,2,3] 
var num:[Int] = [0,1,2] //只能是 Int 类型
var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] //只能是 字符串
var arr1:[Any] = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,1,num,arr] //里面的元素可以为任意类型

var arr0: Array&amp;lt;String&amp;gt; = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
var arr01 = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,1] as [Any]

//空数组的声明方式
var emptyArr1:[Int] = []
var emptyArr2:Array&amp;lt;Int&amp;gt; = []
var emptyArr3 = [Int]()

//重复数组初始化
var allzZeros = [String](repeatElement(&amp;quot;a&amp;quot;, count: 4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数组的基本查询 属性方法 &lt;code&gt;count ,isEmpty, first, last, max, min, [], contains, index, for in enumerated, compare&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]

arr.count //判断数组长度
arr.isEmpty //判空

arr[1]     //索引数组中第二个元素

//取值
arr.first
arr.last
var fistElement =  arr.first  // 返回的是一个可选型。

//最大最小
arr.max()
arr.min()

//区间
arr[0...2]
arr[0..&amp;lt;2]

//判断是否包含
arr.contains(&amp;quot;c&amp;quot;)

//获取位置
arr.index(of: &amp;quot;b&amp;quot;)
arr.index(of: &amp;quot;add23&amp;quot;)

//遍历
for str in arr{
    print(str)
}

for (index, str ) in arr.enumerated(){
    print(index, str)
}

//数组比较
var arr1 = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
arr == arr1  //数组比较。。 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;数组的&lt;strong&gt;增删改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]

//增加元素
arr.append(&amp;quot;d&amp;quot;)
arr += [&amp;quot;a&amp;quot;]  // 后面必须跟同数据类型的数组
arr.insert(&amp;quot;x&amp;quot;, at: 2)  //在某一个位置添加,注意越界问题

//删除元素
arr.removeFirst(2) //删除数组首2个元素
arr.removeLast(3) //删除数组尾部3个元素
arr.remove(at: 2)  //删除第二个元素
arr.removeSubrange(0...1)
arr.removeSubrange(0..&amp;lt;2)
//arr.removeAll()

//修改元素  
arr[0] = &amp;quot;hello&amp;quot; 修改第一个元素 为 &amp;quot;hello&amp;quot;
arr[0...2] = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] //修改区间中的元素为新元素 
arr[0...2] = [&amp;quot;a&amp;quot;] //修改区间中的元素为新元素 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;二维数组&lt;/strong&gt;  其实就是一维数组中的元素都是一维数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr:[Array&amp;lt;String&amp;gt;] = [[&amp;quot;a&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]] //元素必须都是 String
var arrtemp = arr[0]  
var str = arr[0][0]  
var arr01:[Array&amp;lt;Any&amp;gt;] = [[&amp;quot;a&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;],[1,2,3]] //任意元素,使用时需要谨慎。经常会有各种解包问题
var int = arr01[2][1] as! Int

arr.append([&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;]) //在二维数组的尾部添加新的数组元素
arr[0].append(&amp;quot;b&amp;quot;) //给二维数组的第一个数组元素 添加一个String

arr += [[&amp;quot;b&amp;quot;,&amp;quot;d&amp;quot;]]   //+的也需要是二维数组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NSArray&lt;/strong&gt; NSArray 和 Array 的区别就是 NSArray 是一个类,而 Array 是一个结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr000 = [1, 2, 3, 4] as NSArray
var arr001:NSArray = [&amp;quot;a&amp;quot;]
var arr002:NSArray = [1, 2, &amp;quot;hello&#39;&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;遗留问题&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var arr000 = [1, 2, 3, 4]
 var arr001 = [&amp;quot;a&amp;quot;]
 var arr002 = [[1],[2],[3],[&amp;quot;a&amp;quot;],arr000] as [Any]

 //如何在 arr002 中获取第五个元素,然后解包这个元素。
 var arr = arr002[4]   //对 arr的解包,如何顺利进行。
 //arr[0]  //error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//问题解决&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr0001 = arr1[5] as! Array&amp;lt;String&amp;gt;
arr0001[1] 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-06 可选型 Optionals</title>
            <link>http://blog.flywithme.top/2017/02/20/swift06/</link>
            <pubDate>Mon, 20 Feb 2017 15:22:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/20/swift06/</guid>
            <description>&lt;p&gt;画重点!
Optionals 是 swift 新加入的类型,所以之前的 Objective-C 中是没有这个概念的。可选型 简单一些理解就是:有值的时候就有值,无值的时候
是 nil. 但是 swift 的 nil 和其他语言中的 nil 不一样,nil 本身也是一中类型,nil就是没有,不是任何一个值,是和其他类型严格区分开的。&lt;/p&gt;

&lt;p&gt;可选型不是表示 可以表示任意类型,而是可以表示一个指定数据类型 和 nil类型,&lt;/p&gt;

&lt;p&gt;错误代码示范&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: String = &amp;quot;loveway&amp;quot;
name = nil //报错 error: Nil cannot be assigned to type &#39;String&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optionals的声明&lt;/strong&gt; &lt;code&gt;var optionalInteger: Int? , var optionalInteger: Optional&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: String? = &amp;quot;loveway&amp;quot;
print(name!)
name = nil
print(name as Any)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选型的解包&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: Optional&amp;lt;String&amp;gt; = &amp;quot;lazy&amp;quot;
print(name!)
name = nil
print(name as Any )
name = &amp;quot;sam&amp;quot;
//var string = &amp;quot;my name is &amp;quot; + name  //error 因为 ```name```是一个未解包的数据,不能直接使用。
var string = &amp;quot;my name is &amp;quot; + name!  //强制解包
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;后面加一个 叹号 &lt;code&gt;!&lt;/code&gt; 可以强制解包 但是 name 有可能出现为 nil 的情况,这是有风险的。可能
        会造成 app 崩溃。所以在使用之前需要对 &lt;code&gt;name&lt;/code&gt; 进行判空&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var name: Optional&amp;lt;String&amp;gt; = &amp;quot;lazy&amp;quot;
var age : Optional&amp;lt;Int&amp;gt; = 24

if name != nil {
    var string = &amp;quot;my name is &amp;quot; + name!
}else{
     &amp;quot;name is nil&amp;quot;
}

//或者
if let unwrapName = name{ //自动解包 name 数据到 unwrapName
    var string = &amp;quot;my name is &amp;quot; + unwrapName
}else{
          &amp;quot;name is nil&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;两个数据都解包成功之后才会进入判断方法中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if let unwrapName = name,let unwrapAge = age{
    var string = &amp;quot;my name is &amp;quot; + unwrapName + &amp;quot;age is \(unwrapAge)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;添加限制条件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if let unwrapName = name,let unwrapAge = age , unwrapAge &amp;gt; 20{
    var string = &amp;quot;my name is &amp;quot; + unwrapName + &amp;quot;age is \(unwrapAge)&amp;quot;
}

if let name = name,let age = age , age &amp;gt; 20{
    var string = &amp;quot;my name is &amp;quot; + name + &amp;quot;age is \(age)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional Chaining&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var errorMsg:String? = nil
print(errorMsg as Any)
errorMsg = &amp;quot;404&amp;quot;
//重点 尝试解包 ```?```
errorMsg?.uppercased() //尝试解包,如果成功就调用方法,如果失败,就停止 

//如果确认 ```errorMsg```有值,可以使用,否则很容易出错。 
errorMsg!.uppercased() //强制解包,如果 ```errorMsg``` 是 nil 则会报错,这样写会不安全。

var temp = errorMsg?.uppercased() //temp 依然是一个可选型

var msg = errorMsg == nil ? &amp;quot;No error&amp;quot; : errorMsg!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional在元组中的使用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var error :(errorCode: Int , errorMsg:String?) = (404, &amp;quot;Not found&amp;quot;)
error.errorMsg = nil

var error1 :(errorCode: Int , errorMsg:String)? = nil
error1 = nil

var error2 :(errorCode: Int , errorMsg:String?)? = nil
error2?.errorMsg = nil
error2 = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional 的应用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ageInput:String = &amp;quot;ads&amp;quot;
var age = Int(ageInput) //返回的 age 类型是可选型。
if let age = Int(ageInput), age &amp;gt; 18{ //这里的 age 的类似又是什么呢? 
    print(&amp;quot;成年了&amp;quot;)
}


var str = &amp;quot;hello world&amp;quot;
var range =  str.range(of: &amp;quot;ll&amp;quot;)
range?.lowerBound
range?.upperBound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;隐式可选型&lt;/strong&gt;  隐式可选型在使用的时候可以不进行解包直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var errorMsg:String! = nil
errorMsg = &amp;quot;Not found&amp;quot;
&amp;quot;messge &amp;quot; + errorMsg  //使用的时候必须保证 errorMsg 不为空,要不然程序会报错。




class Student{
    let name:String
    var age:Int
    var stdId:Int
    unowned var aClass:Class //避免循环引用
    init(name:String,age:Int,stdId:Int,aClass:Class){
        self.name = name
        self.age = age
        self.stdId = stdId
        self.aClass = aClass
    }
}

class Class{
    var className:String = &amp;quot;&amp;quot;
    var classNum:Int = 0
    var monitor:Student! //若不设置成可选型，则在下面初始化的时候回造成死循环

    init(className:String, classNum:Int, monitorName:String) {
        self.className = className;
        self.classNum = classNum;
        self.monitor = Student(name: monitorName, age: 18, stdId: 20, aClass: self)
    }
    func showInfo(){
        print(&amp;quot;this is \(classNum)&amp;quot;)
        print(&amp;quot;monitor is \(monitor.name)&amp;quot;)
    }
}

let class001 = Class(className: &amp;quot;0101&amp;quot;, classNum: 1001, monitorName: &amp;quot;jack&amp;quot;)
class001.monitor
class001.showInfo()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-05 逻辑控制</title>
            <link>http://blog.flywithme.top/2017/02/17/swift05/</link>
            <pubDate>Fri, 17 Feb 2017 17:34:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/17/swift05/</guid>
            <description>&lt;p&gt;控制流的三种基本结构:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;顺序结构&lt;/strong&gt;:  顺序语句有语句序列组成,程序执行时,按照语句顺序,从上而下,一条一条顺序执行&lt;br /&gt;
 &lt;strong&gt;循环结构&lt;/strong&gt;   循环语句使用同一个语句组根据一定的条件执行若干次&lt;br /&gt;
 &lt;strong&gt;选择结构&lt;/strong&gt;:  分支语句根据一定的条件决定执行那一部分语句序列
顺序结构不再多说&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;循环结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for _ in 0...100{
    print(&amp;quot;遍历循环&amp;quot;) 
}


//这种方式在 swift3 中被废弃,不能在使用
//for var i = 1; i &amp;lt; 100 ; i++{
//    print(&amp;quot;遍历循环中&amp;quot;)
//}


var a = 0.0
while a &amp;lt; 50 {
    a += 0.5
    sin(a)   
}


//至少执行一次
repeat{
    a += 0.5
    sin(a)
}while a &amp;lt; 100


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if true {


}else if(1 == 1){


}else{


}


switch index {
case 0:
    break
case 1:
    break
case 2:
    break
default: break
}


//swift 提供的基础数据类型都可以用作 switch 的判断
var str = &amp;quot;a&amp;quot;
switch str {
case &amp;quot;a&amp;quot;,&amp;quot;A&amp;quot;:
    print(&amp;quot;A&amp;quot;)
case &amp;quot;b&amp;quot;:
    print(&amp;quot;B&amp;quot;)
default:
    break


}


//区间
let age = 19
switch age {
case 0..&amp;lt;18:
    print(&amp;quot;未成年&amp;quot;)
case 18..&amp;lt;30:
    print(&amp;quot;青年&amp;quot;)
case 30..&amp;lt;60:
    print(&amp;quot;壮年&amp;quot;)
default:
     break
}


//元组    
let point = (5, 2)


switch point {
case (0,0):
    print(&amp;quot;原点&amp;quot;)
case (0,1):
    print(&amp;quot;1&amp;quot;)
case (0,2):
    print(&amp;quot;2&amp;quot;)
case (_,2): //可以忽略某一个维度的值
    print(&amp;quot;_ 2&amp;quot;)
case (-10...10,2...5): //元组中,同样可以使用区间
    print(&amp;quot;_ 2&amp;quot;)
default:
    print(&amp;quot;没找到&amp;quot;)
}


//解包
let point1 = (5, 2)
switch point1 {
case (0,0):
    print(&amp;quot;原点&amp;quot;)
case (let x,0):
    print(&amp;quot;x 轴 \(x)&amp;quot;)
case (0,let y):
    print(&amp;quot;y 轴  \(y)&amp;quot;)
case (let x, let y):
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;where&lt;/strong&gt;  限定匹配条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch point {
case (0,0) :
    print(&amp;quot;原点&amp;quot;)

case (let x,0):
    print(&amp;quot;x 轴 \(x)&amp;quot;)
case (0,let y):
    print(&amp;quot;y 轴  \(y)&amp;quot;)
case (let x, let y) where x == y :
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
case  let(x, y ) where x == -y :
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
case (let x, let y):
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;if case&lt;/strong&gt;  简化 switch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = 19 
if case 18...20 = age {
    print(&amp;quot;青年&amp;quot;)
}

// 对 case 增加一个限定条件
if case 18...30 = age, age &amp;gt;= 19 {
    print(&amp;quot;青年&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;for case where&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for case let index in 1...100 where index % 7 == 0{
    print(index)
}

for  index in 1...100 where index % 7 == 0{
    print(index)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;控制转移&lt;/strong&gt;   &lt;code&gt;break&lt;/code&gt; 跳出本层循环体,提前结束循环 。   &lt;code&gt;continue&lt;/code&gt; 结束当前循环体,进行下一次循环   &lt;code&gt;fallthrough&lt;/code&gt; 执行完当前case 之后 进入下一个 case&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while true {
    a += 0.5
    if a == 5.5{
        continue
    }
    sin(a)
    if a &amp;gt; 50{
        break
    }
}

var str = &amp;quot;a&amp;quot;
switch str {
case &amp;quot;a&amp;quot;,&amp;quot;A&amp;quot;:
    print(&amp;quot;A&amp;quot;)
    fallthrough //执行完之后 ,跳入下一个 case 语句
case &amp;quot;b&amp;quot;:
    print(&amp;quot;B&amp;quot;)
    fallthrough //执行完之后 ,跳入下一个 case 语句
default:
    print(&amp;quot;C&amp;quot;)
}

//给 for 循环加一个名字,可以使用 break 结束这个循环。 谨慎使用。
findanswer:for x in 1...300{
    for y in 1...300{
        print(x, y)
        if x == 4,y == 5 {
            break findanswer
        }

    }
}
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;guard&lt;/strong&gt; 关键字守护  &lt;code&gt;guard  bool condition  else&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func buyComputer(money:Int, price:Int, brand:String){
    guard money &amp;gt; price else {
        print(&amp;quot;钱不够&amp;quot;)
        return
    }

    guard brand == &amp;quot;Apple&amp;quot; else {
        print(&amp;quot;不是苹果电脑&amp;quot;)
        return
    }
}
buyComputer(money: 9000, price: 6000, brand: &amp;quot;Sony&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-04 基础运算符</title>
            <link>http://blog.flywithme.top/2017/02/17/swift04/</link>
            <pubDate>Fri, 17 Feb 2017 11:00:55 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/17/swift04/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;赋值运算符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;=&lt;/strong&gt;  这里是没有返回值的。返回值可能是Void，此时不等于nil，即赋值成功；或等于nil，即赋值失败&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 3  
a = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数学运算符  &lt;code&gt;+ - * / +=  -= %&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 201
var b  = 4
a + b
a * b
a - b
a / b
a % b
a += 1
+a
-a
a += 2
a -= 3
a *= 2
a /= 2
a %= 2    


var u = 2.5.truncatingRemainder(dividingBy: 1.2) //小数求余


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑运算符  &lt;code&gt;! &amp;amp;&amp;amp; ||&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var isTrue:Bool = true , isFalse:Bool = false
!isTrue
isTrue &amp;amp;&amp;amp; isFalse
isTrue || isFalse
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比较运算符   &lt;code&gt;== != &amp;gt; &amp;gt;= &amp;lt; &amp;lt;=&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let money = 100
let price = 20
if money &amp;gt;= price{
    print(&amp;quot;buy&amp;quot;)
}


let capacity = 30 //背包容量
let volume = 40 //购买物体积


if money &amp;gt;= price &amp;amp;&amp;amp; capacity &amp;gt;= volume{
    print(&amp;quot;buy it&amp;quot;)
}


if money &amp;lt; price || capacity &amp;lt; volume{
    print(&amp;quot;can not buy it&amp;quot;)
}


if  !(money &amp;gt;= price &amp;amp;&amp;amp; capacity &amp;gt;= volume){
     print(&amp;quot;can not buy it&amp;quot;)
}


//登陆
var isUserNameOK = false
var isPasswordOk = false


var isPhoneNumOk = true
var isPhoneCodeOk = false


if isUserNameOK &amp;amp;&amp;amp; isPasswordOk || isPhoneNumOk &amp;amp;&amp;amp; isPasswordOk{
    print(&amp;quot;登陆成功&amp;quot;)
}else{
    print(&amp;quot;登陆失败&amp;quot;)
}


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三目运算符   bool?answer1:answer2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var battery = 19
var batteryColor:UIColor
batteryColor =  battery &amp;lt;= 20 ? UIColor.red:UIColor.green
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;区间运算符  闭区间运算符 &lt;code&gt;[a, b] a...b&lt;/code&gt; , 前闭后开区间运算符 &lt;code&gt;[) a..&amp;lt;b&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...10{
    index
}


for index in 1..&amp;lt;10{
        index
}


let arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
for str in arr{
    print(str)
}


&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-03 基础类型</title>
            <link>http://blog.flywithme.top/2017/02/16/swift03/</link>
            <pubDate>Thu, 16 Feb 2017 16:11:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift03/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常量 &lt;strong&gt;let&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a = 1
let b:Int
b = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量 &lt;strong&gt;var&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var b = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;swift 是一个强类型语言:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1

x = &amp;quot;abc&amp;quot; //会报错(Cannot assign value of type &amp;quot;String&amp;quot; to type &amp;quot;int&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示声明变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s:String = &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一次声明多个变量,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var y, z, d:Double
var x = 1, y = 2, z = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;常用数据类型: Int , Float ,Double , Boolean , String ,Tuple&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Int&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var aInt: Int = 20 //整型的存储空间是有限的,根据不同的计算机来定。有最大最小值
Int.max
Int.min

var aUInt:UInt = 200  //无法存储负数,最大值是 Int 的两倍+1
UInt.max
UInt.min
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Int 的类型&lt;br /&gt;
   !&lt;img src=&#34;sources/swift/Int类型.png&#34; alt=&#34;intType&#34; /&gt;&lt;/p&gt;

&lt;p&gt;小知识 如果是一个比较大的数值,可以使用下划线对数字进行分割&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let bigNum = 1_000_000_000_00232
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/swift/BA6D5746-A4AE-411F-905E-4761288DEE0F.png&#34; alt=&#34;C8A54525-8DE7-4EC3-8665-89146D67C0CF&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Float Double&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浮点数 float Double 区别&lt;br /&gt;
    &lt;img src=&#34;sources/swift/C1DB90FE-EE4F-4CC2-95F3-580D54437E75.png&#34; alt=&#34;C8A54525-8DE7-4EC3-8665-89146D67C0CF&#34; /&gt;&lt;/p&gt;

&lt;p&gt;//上面的数字加下划线 亦可以用在小数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var aFloat = 1_000_000.000_0001  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不同数据类型之间不能直接做数据运算,不能自动做类型转换。必需要做显示类型转换,以防止运算出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a:Int = 1
let b:UInt = 2
a + b //错误,运算歧义 
a + Int(b) //正确
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;swift 是一个强制类型语言,把浮点数赋值给整型是肯定会报错的。除非对浮点数进行转换才行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Boolean&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let aTrue:Bool = true
let aFalse = false

if aTrue{
    print(&amp;quot;True&amp;quot;)
}else if(1 == 1){
    print(&amp;quot;1 == 1&amp;quot;)
}
else{
    print(&amp;quot;False&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if 判断语句 只能使用 Bool 类型判断,否则会报错&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tuple&lt;/strong&gt; 元组就是将多个不同的值集合在一个数据中。可以有任意多个值,多个不同的数据类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var point = (1 , 1)
var httpResponse = (401, &amp;quot;未授权&amp;quot;)

// 显式指定元组类型
var point2:(Int, Int, Int) = (2, 3, 4)

var httpResponse2:(Int, String) = (200, &amp;quot;OK&amp;quot;)

//取值
httpResponse.0
httpResponse.1

//解包
let (x, y) = httpResponse2
print(x, y)

//给分量加一个名字。
let point3 = (x: 3, y :4)
point3.x
point3.y

let point4:(x: Int, y: Int) =(2, 3)
point4.x
point4.y

let point5 = (10,23)
let (z, _) = point5 //若不需要解包某一个数据,可以用下划线_忽略一些值
z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;   使用双引号引起来的一段文本。&lt;/p&gt;

&lt;p&gt;字符串基本用法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//声明一个字符串
var str: String = &amp;quot;swift&amp;quot;
let str1 = String(&amp;quot;abdd&amp;quot;)

//空字符串
var emptyStr = &amp;quot;&amp;quot;
var emptystr1 = String()

str.isEmpty //字符串判空

let a = &amp;quot;abc&amp;quot;
str + a 

str += a

str1 += a //错误 常量不能被改变

//字符串插值  字符串插值是一种全新的构建字符串的方式，可以在其中包含常量、变量、字面量和表达式。您插入的字符串字面量的每一项都被包裹在以反斜线为前缀的圆括号中：
let name  = &amp;quot;jack&amp;quot;
let age = 20
let s = &amp;quot;My name is \(name), age is \(age)&amp;quot;

// \是转义字符  \t 是制表符  \n 是换行符
let s2 = &amp;quot;\\&amp;quot; //输出转义字符
print(s2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello. swift&amp;quot;

for c in str.characters{
    print(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mark:Character = &amp;quot;!&amp;quot; //字符

str + String(mark) //不改变 str 

str.append(mark) //改变 str 值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 swift 中一个中文字符和表情符都可以是一个字符(其他语言中可能需要多个字符才能标识)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dog:Character = &amp;quot;🐶&amp;quot;
let chinessLetter :Character = &amp;quot;程&amp;quot;
let coolguy: Character = &amp;quot;\u{1F60E}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串长度 :swift 更倾向于人类理解,而不是机器理解。  但是这会导致 swift 处理大批量字符串的时候速度比较慢&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var strLetters = &amp;quot;abcdef\u{1F60E}&amp;quot;
strLetters.characters.count //长度计算 为7
strLetters = &amp;quot;中国&amp;quot;
strLetters.characters.count //长度计算 为2

var cafe = &amp;quot;café&amp;quot;  //字符串长度是多少?

cafe = &amp;quot;cafe\u{0301}&amp;quot; //字符串长度是多少?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何索引获取字符串中的字符   //这个处理几个版本变化很大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello, swift&amp;quot; 
let startIndex =  str.index(str.startIndex, offsetBy: 2) //距离起点字符偏移位置
str[startIndex] //
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var varA   = &amp;quot;Hello, Swift!&amp;quot;
var varB   = &amp;quot;Hello, World!&amp;quot;

if varA == varB {
   print( &amp;quot;\(varA) 与 \(varB) 是相等的&amp;quot; )
} else {
   print( &amp;quot;\(varA) 与 \(varB) 是不相等的&amp;quot; )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串 filter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let str2 = &amp;quot;    a  b  c  d &amp;quot;
let res = String(str2.characters.filter  { $0 != &amp;quot; &amp;quot; })
res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串插入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let c:Character = &amp;quot;1&amp;quot;
str.insert(c, at: startIndex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串大小写转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello, swift&amp;quot;
let shouty = str.uppercased()
let shoutx = str.lowercased()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断字母首尾是否为某特定字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str.hasPrefix(&amp;quot;hello&amp;quot;)
str.hasSuffix(&amp;quot;swift&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制类型转换  as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s2 = NSString(format:&amp;quot;1/3 =  %.2f&amp;quot;, 1.0/3.0) as String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NSString&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s3:NSString = &amp;quot;😄哈&amp;quot;
s3.length
s3.character(at: 1)
let s4 = &amp;quot;    hello world    &amp;quot; as NSString

s4.trimmingCharacters(in: .whitespaces) //去除空格
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-02 初见</title>
            <link>http://blog.flywithme.top/2017/02/16/swift02/</link>
            <pubDate>Thu, 16 Feb 2017 11:27:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift02/</guid>
            <description>&lt;p&gt;首先我们来在屏幕上输出一个 &lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要 import 任何库,可以直接在全局作用域使用。代码结尾不要带分号。&lt;/p&gt;

&lt;p&gt;Xcode 提供了代码预览功能 &lt;strong&gt;Playground&lt;/strong&gt; . 使用它可以加快 swift的学习速度&lt;/p&gt;

&lt;p&gt;初始化一个变量和常量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  a = 2  //可变数据
a = 3
let b = 2 //不可变
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if else&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if a == 2{
     print(&amp;quot;true&amp;quot;)
 } else{
     print(&amp;quot;false&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for in 遍历语句(此外还有 ,repeat..while ,for 循环3.0中已经被弃用)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 0...100{
   var c = Double(index)/20.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while 1 == 1 {
    a += 1
    if a == 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repeat&amp;hellip; while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repeat
{
    a += 1
    if a &amp;gt; 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}while( 1 == 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = -3 
assert(age &amp;gt;= 0, &amp;quot;A person&#39;s age cannot be less than zero&amp;quot;) 
// 因为 age &amp;lt; 0，所以断言会触发  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面开始深入学习&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于 Swift3-01</title>
            <link>http://blog.flywithme.top/2017/02/09/swift01/</link>
            <pubDate>Thu, 09 Feb 2017 10:12:48 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/09/swift01/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift 是一门新的编程语言，用于编写 iOS、OS X 以及 watchOS 应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受C兼容性的限制。
Swift 使用安全的编程模式并添加了很多新特性，这将使编程更简单，扩展性更强，也更有趣。Swift 支持 Cocoa 和 Cocoa Touch 框架。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构，让 Swift 使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Objective-C 开发者对于 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性，支持面向过程编程和面向对象编程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 对于初学者来说也很简单。Swift是一门既满足工业标准又像脚本语言一样充满表现力和趣味的编程语言。Swift支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 Swift编写 iOS，watchOS,macOS,和 tvOS apps 是一个极佳的选择。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 3.0 是自 Swift开源以来第一个大的版本更新。从语言角度不兼容之前的版本。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;部分摘自：&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html&#34;&gt;AppleLibrary&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go语言fmt包Printf方法详解t</title>
            <link>http://blog.flywithme.top/2017/01/01/golangfmt/</link>
            <pubDate>Sun, 01 Jan 2017 00:56:42 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/01/01/golangfmt/</guid>
            <description>&lt;p&gt;Go语言的标准输出流在打印到屏幕时有些参数跟别的语言（比如C#和Java）不同，下面是我整理的一些常用的格式化输入操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;General&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%v 以默认的方式打印变量的值&lt;/li&gt;
&lt;li&gt;%T 打印变量的类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%+d 带符号的整型，fmt.Printf(&amp;ldquo;%+d&amp;rdquo;, 255)输出+255&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%q 打印单引号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%o 不带零的八进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#o 带零的八进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%x 小写的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%X 大写的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#x 带0x的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%U 打印Unicode字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#U 打印带字符的Unicode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%b 打印整型的二进制&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Integer width&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;%5d 表示该整型最大长度是5，下面这段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1)
fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1234567)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|    1|
|1234567|
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;%-5d则相反，打印结果会自动左对齐&lt;/li&gt;
&lt;li&gt;%05d会在数字前面补零。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Float&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%f (=%.6f) 6位小数点&lt;/li&gt;
&lt;li&gt;%e (=%.6e) 6位小数点（科学计数法）&lt;/li&gt;
&lt;li&gt;%g 用最少的数字来表示&lt;/li&gt;
&lt;li&gt;%.3g 最多3位数字来表示&lt;/li&gt;
&lt;li&gt;%.3f 最多3位小数来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%s 正常输出字符串&lt;/li&gt;
&lt;li&gt;%q 字符串带双引号，字符串中的引号带转义符&lt;/li&gt;
&lt;li&gt;%#q 字符串带反引号，如果字符串内有反引号，就用双引号代替&lt;/li&gt;
&lt;li&gt;%x 将字符串转换为小写的16进制格式&lt;/li&gt;
&lt;li&gt;%X 将字符串转换为大写的16进制格式&lt;/li&gt;
&lt;li&gt;% x 带空格的16进制格式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;String Width&lt;/strong&gt; (以5做例子）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%5s 最小宽度为5&lt;/li&gt;
&lt;li&gt;%-5s 最小宽度为5（左对齐）&lt;/li&gt;
&lt;li&gt;%.5s 最大宽度为5&lt;/li&gt;
&lt;li&gt;%5.7s 最小宽度为5，最大宽度为7&lt;/li&gt;
&lt;li&gt;%-5.7s 最小宽度为5，最大宽度为7（左对齐）&lt;/li&gt;
&lt;li&gt;%5.3s 如果宽度大于3，则截断&lt;/li&gt;
&lt;li&gt;%05s 如果宽度小于5，就会在字符串前面补零&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Struct&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%v 正常打印。比如：{sam {12345 67890}}&lt;/li&gt;
&lt;li&gt;%+v 带字段名称。比如：{name:sam phone:{mobile:12345 office:67890}&lt;/li&gt;
&lt;li&gt;%#v 用Go的语法打印。比如main.People{name:”sam”, phone:main.Phone{mobile:”12345”, office:”67890”}}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Boolean&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%t 打印true或false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pointer&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%p 带0x的指针&lt;/li&gt;
&lt;li&gt;%#p 不带0x的指针&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>golang-Gin-Https</title>
            <link>http://blog.flywithme.top/2016/12/26/golang-Gin-Https/</link>
            <pubDate>Mon, 26 Dec 2016 14:29:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/26/golang-Gin-Https/</guid>
            <description>&lt;p&gt;关于https&lt;br /&gt;
背景知识&lt;br /&gt;
密码学的一些基本知识&lt;br /&gt;
大致上分为两类，基于key的加密算法与不基于key的加密算法。现在的算法基本都是基于key的，key就以一串随机数数，更换了key之后，算法还可以继续使用。&lt;/p&gt;

&lt;p&gt;基于key的加密算法又分为两类，对称加密和不对称加密，比如DES,AES那种的，通信双方一方用key加密之后，另一方用相同的key进行反向的运算就可以解密。&lt;/p&gt;

&lt;p&gt;不对称加密比较著名的就是RSA,加密的时候有一个公钥和一个私钥，公钥是可以交给对方的，a给b发送信息，a用自己的私钥加密，b用a的公钥解密，反之，b给a发送信息，b用自己的私钥加密。&lt;/p&gt;

&lt;p&gt;在通信之前，需要经过一些握手的过程，双方交换公钥，这个就是key exchange的过程，https最开始的阶段就包含了这个key exchange的过程，大概原理是这样，有些地方还要稍微复杂一些。&lt;/p&gt;

&lt;p&gt;数字证书与CA&lt;br /&gt;
数字证书相当于是服务器的一个“身份证”，用于唯一标识一个服务器。一般而言，数字证书从受信的权威证书授权机构 (Certification Authority，证书授权机构)买来的（免费的很少），浏览器里面一般就内置好了一些权威的CA，在使用https的时候，只要是这些CA签发的证书，浏览器都是可以认证的，要是在与服务器通信的时候，收到一个没有权威CA认证的证书，就会报出提醒不受信任证书的错误，就像登录12306一样，但是也可以选择接受。&lt;/p&gt;

&lt;p&gt;在自己的一些项目中，通常是自己签发一个ca根证书，之后这个根证书签发一个server.crt，以及server.key给服务端，server.key是服务端的私钥，server.crt包含了服务端的公钥还有服务端的一些身份信息。在客户端和服务端通信的时候（特别是使用代码编写的客户端访问的时候），要指定ca根证书，作用就相当于是浏览器中内置的那些权威证书一样，用于进行服务端的身份检测。&lt;/p&gt;

&lt;p&gt;证书的格式：&lt;/p&gt;

&lt;p&gt;ca证书在为server.crt证书签名时候的大致流程参考这个(&lt;a href=&#34;http://www.tuicool.com/articles/aymYbmM)：&#34;&gt;http://www.tuicool.com/articles/aymYbmM)：&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数字证书由两部分组成：&lt;/p&gt;

&lt;p&gt;1、C：证书相关信息（对象名称+过期时间+证书发布者+证书签名算法….）&lt;/p&gt;

&lt;p&gt;2、S：证书的数字签名 （由CA证书通过加密算法生成的）&lt;/p&gt;

&lt;p&gt;其中的数字签名是通过公式S = F(Digest&amp;copy;)得到的。&lt;/p&gt;

&lt;p&gt;Digest为摘要函数，也就是 md5、sha-1或sha256等单向散列算法，用于将无限输入值转换为一个有限长度的“浓缩”输出值。比如我们常用md5值来验证下载的大文件是否完整。大文件的内容就是一个无限输入。大文件被放在网站上用于下载时，网站会对大文件做一次md5计算，得出一个128bit的值作为大文件的摘要一同放在网站上。用户在下载文件后，对下载后的文件再进行一次本地的md5计算，用得出的值与网站上的md5值进行比较，如果一致，则大 文件下载完好，否则下载过程大文件内容有损坏或源文件被篡改。这里还有一个小技巧常常在机器之间copy或者下载压缩文件的时候也可以用md5sum的命令来进行检验，看看文件是否完整。&lt;/p&gt;

&lt;p&gt;F为签名函数。CA自己的私钥是唯一标识CA签名的，因此CA用于生成数字证书的签名函数一定要以自己的私钥作为一个输入参数。在RSA加密系统中，发送端的解密函数就是一个以私钥作为参数的函数，因此常常被用作签名函数使用。因此CA用私钥解密函数作为F，以CA证书中的私钥进行加密，生成最后的数字签名，正如最后一部分实践时候给出的证书生成过程，生成server.crt的时候需要ca.crt（包含根证书的信息）和ca.key（根证书的私钥）都加入进去。&lt;/p&gt;

&lt;p&gt;接收端接收服务端数字证书后，如何验证数字证书上携带的签名是这个CA的签名呢？当然接收端首先需要指定对应的CA，接收端会运用下面算法对数字证书的签名进行校验：
F&amp;rsquo;(S) ?= Digest&amp;copy;&lt;/p&gt;

&lt;p&gt;接收端进行两个计算，并将计算结果进行比对：&lt;/p&gt;

&lt;p&gt;1、首先通过Digest&amp;copy;，接收端计算出证书内容（除签名之外）的摘要，C的内容都是明文可以看到到的。&lt;/p&gt;

&lt;p&gt;2、数字证书携带的签名是CA通过CA密钥加密摘要后的结果，因此接收端通过一个解密函数F&amp;rsquo;对S进行“解密”。就像最开始介绍的那样，在RSA系统中，接收端使用CA公钥（包含在ca.crt中）对S进行“解密”，这恰是CA用私钥对S进行“加密”的逆过程。&lt;/p&gt;

&lt;p&gt;将上述两个运算的结果进行比较，如果一致，说明签名的确属于该CA，该证书有效，否则要么证书不是该CA的，要么就是中途被人篡改了。&lt;/p&gt;

&lt;p&gt;对于self-signed(自签发)证书来说，接收端并没有你这个self-CA的数字证书，也就是没有CA公钥，也就没有办法对数字证书的签名进行验证。因此如果要编写一个可以对self-signed证书进行校验的接收端程序的话，首先我们要做的就是建立一个属于自己的CA，用该CA签发我们的server端证书，之后给客户端发送信息的话，需要对这个根证书进行指定，之后按上面的方式进行验证。&lt;/p&gt;

&lt;p&gt;可以使用openssl x509 -text -in client.crt -noout 查看某个证书文件所包含的具体信息。&lt;/p&gt;

&lt;p&gt;HTTPS基本过程概述&lt;/p&gt;

&lt;p&gt;https协议是在http协议的基础上组成的secure的协议。主要功能包含一下两个方面:&lt;/p&gt;

&lt;p&gt;1 通信双方的身份认证&lt;/p&gt;

&lt;p&gt;2 通信双方的通信过程加密&lt;/p&gt;

&lt;p&gt;下面通过详细分析https的通信过程来解释这两个功能。&lt;/p&gt;

&lt;p&gt;具体参考这两个文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fenesky.com/blog/2014/07/19/how-https-works.html&#34;&gt;http://www.fenesky.com/blog/2014/07/19/how-https-works.html&lt;/a&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&#34;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1、client 发送 sayhello给server端，说明client所支持的加密套件，还有一个随机数1。
2、server 发送 sayhello给client端，端把server.crt发送给客户端,server.crt采用还有一个随机数2。
3、client端生成preMaster key 这个是随机数3，之后三个随机数结合在一起生成MasterSecret,之后生成session secret，使用指定的ca进行身份认证，就像之前介绍的那样，都正常的话，就切换到加密模式。
4、client端使用server.crt中的公钥对preMasterSecret进行加密，如果要进行双向认证的话，client端会把client.crt一并发送过去，server端接受到数据，解密之后，也有了三个随机数，采用同样的方式，三个随机数生成通信所使用的session secret。具体session secret的结构可以参考前面列出的两个博客。server端完成相关工作之后，会发一个ChangeCipherSpec给client，通知client说明自己已经切换到相关的加解密模式，之后发一段加密信息给client看是否正常。
5、client端解密正常，之后就可以按照之前的协议，使用session secret进行加密的通信了。&lt;/p&gt;

&lt;p&gt;整体看下，开始的时候建立握手的过程就是身份认证的过程，之后认证完毕之后，就是加密通信的过程了，https的两个主要做用就实现了。&lt;/p&gt;

&lt;p&gt;相关实践&lt;/p&gt;

&lt;p&gt;比较典型的证书生成的过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out ca.key 2048

#这里可以使用 -subj 不用进行交互 当然还可以添加更多的信息
openssl req -x509 -new -nodes -key ca.key -subj &amp;quot;/CN=zju.com&amp;quot; -days 5000 -out ca.crt

openssl genrsa -out server.key 2048

#这里的/cn可以是必须添加的 是服务端的域名 或者是etc/hosts中的ip别名
openssl req -new -key server.key -subj &amp;quot;/CN=server&amp;quot; -out server.csr

openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 5000
注意生成client端证书的时候，注意要多添加一个字段，golang的server端认证程序会对这个字段进行认证：

openssl genrsa -out client.key 2048

openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

echo extendedKeyUsage=clientAuth &amp;gt; extfile.cnf

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -extfile extfile.cnf -out client.crt -days 5000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;https客户端和服务端单向校验&lt;/p&gt;

&lt;p&gt;这部分参考了这个（&lt;a href=&#34;http://www.tuicool.com/articles/aymYbmM&#34;&gt;http://www.tuicool.com/articles/aymYbmM&lt;/a&gt;
），里面代码部分讲得比较细致。&lt;/p&gt;

&lt;p&gt;服务端采用证书，客户端采用普通方式访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//server端代码
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;os&amp;quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w,
        &amp;quot;Hi, This is an example of https service in golang!&amp;quot;)
}

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, handler)
    //http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
    _, err := os.Open(&amp;quot;cert_server/server.crt&amp;quot;)
    if err != nil {
        panic(err)
    }
    http.ListenAndServeTLS(&amp;quot;:8081&amp;quot;, &amp;quot;cert_server/server.crt&amp;quot;,
        &amp;quot;cert_server/server.key&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client端直接发请求，什么都不加，会报如下错误：&lt;/p&gt;

&lt;p&gt;2015/07/11 18:13:50 http: TLS handshake error from 10.183.47.203:58042: remote error: bad certificate
使用浏览器直接访问的话，之后点击信赖证书，这个时候就可以正常get到消息&lt;/p&gt;

&lt;p&gt;或者使用curl -k https:// 来经行访问，相当于忽略了第一步的身份验证的工作。
要是不加-k的话 使用curl -v 参数打印出来详细的信息，会看到如下的错误：&lt;/p&gt;

&lt;p&gt;curl: (60) SSL certificate problem: Invalid certificate chain
说明是认证没有通过，因为客户端这面并没有提供可以信赖的根证书来对服务端发过来的证书进行验，/CN使用的直接是ip地址，就会报下面的错误：&lt;/p&gt;

&lt;p&gt;Get &lt;a href=&#34;https://10.183.47.206:8081:&#34;&gt;https://10.183.47.206:8081:&lt;/a&gt; x509: cannot validate certificate for 10.183.47.206 because it doesn&amp;rsquo;t contain any IP SANs
最好是生成证书的时候使用域名，或者是在/etc/hosts中加上对应的映射。&lt;/p&gt;

&lt;p&gt;可以发送请求的客户端的代码如下，注意导入根证书的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    //&amp;quot;io&amp;quot;
    //&amp;quot;log&amp;quot;
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    //&amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    //&amp;quot;strings&amp;quot;
)

func main() {
    //x509.Certificate.
    pool := x509.NewCertPool()
    //caCertPath := &amp;quot;etcdcerts/ca.crt&amp;quot;
    caCertPath := &amp;quot;certs/cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)
    //pool.AddCert(caCrt)

    tr := &amp;amp;http.Transport{
        TLSClientConfig:    &amp;amp;tls.Config{RootCAs: pool},
        DisableCompression: true,
    }
    client := &amp;amp;http.Client{Transport: tr}

    resp, err := client.Get(&amp;quot;https://server:8081&amp;quot;)

    if err != nil {
        panic(err)
    }

    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.Status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用curl命令的话，就加上&amp;ndash;cacrt ca.crt证书，这样就相当于添加了可信赖的证书，身份认证的操作就可以成功了。&lt;/p&gt;

&lt;p&gt;比如生成服务端证书的时候/CN写的是server 那client发送的时候也发送给&lt;a href=&#34;https://server:8081就好，不过在本地的/etc/hosts中要加上对应的映射。&#34;&gt;https://server:8081就好，不过在本地的/etc/hosts中要加上对应的映射。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端和服务端的双向校验：&lt;/p&gt;

&lt;p&gt;按照之前的方式，客户端生成证书，根证书就按之前的那个：
    openssl genrsa -out client.key 2048&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 5000
server端代码进行改进，添加受信任的根证书。

// gohttps/6-dual-verify-certs/server.go
package main

import (
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type myhandler struct {
}

func (h *myhandler) ServeHTTP(w http.ResponseWriter,
    r *http.Request) {
    fmt.Fprintf(w,
        &amp;quot;Hi, This is an example of http service in golang!\n&amp;quot;)
}

func main() {
    pool := x509.NewCertPool()
    caCertPath := &amp;quot;cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)

    s := &amp;amp;http.Server{
        Addr:    &amp;quot;:8081&amp;quot;,
        Handler: &amp;amp;myhandler{},
        TLSConfig: &amp;amp;tls.Config{
            ClientCAs:  pool,
            ClientAuth: tls.RequireAndVerifyClientCert,
        },
    }

    err = s.ListenAndServeTLS(&amp;quot;cert_server/server.crt&amp;quot;, &amp;quot;cert_server/server.key&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;ListenAndServeTLS err:&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端代码改进，发送的时候把指定client端的client.crt以及client.key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// gohttps/6-dual-verify-certs/client.go

package main

import (
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func main() {
    pool := x509.NewCertPool()
    caCertPath := &amp;quot;certs/cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)

    cliCrt, err := tls.LoadX509KeyPair(&amp;quot;certs/cert_server/client.crt&amp;quot;, &amp;quot;certs/cert_server/client.key&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;Loadx509keypair err:&amp;quot;, err)
        return
    }

    tr := &amp;amp;http.Transport{
        TLSClientConfig: &amp;amp;tls.Config{
            RootCAs:      pool,
            Certificates: []tls.Certificate{cliCrt},
        },
    }
    client := &amp;amp;http.Client{Transport: tr}
    resp, err := client.Get(&amp;quot;https://server:8081&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;Get error:&amp;quot;, err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但实际上，这样是不行的，server端会报这样的错误：&lt;/p&gt;

&lt;p&gt;client&amp;rsquo;s certificate&amp;rsquo;s extended key usage doesn&amp;rsquo;t permit it to be used for client authentication
因为client的证书生成方式有一点不一样，向开始介绍的那样，goalng对于client端的认证要多一个参数，生成证书的时候，要加上一个单独的认证信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out client.key 2048

openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

echo extendedKeyUsage=clientAuth &amp;gt; extfile.cnf

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -extfile extfile.cnf -out client.crt -days 5000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是多添加一个认证文件的信息，之后使用新的证书就可以实现双向认证了，这样只有那些持有被认证过的证书的客户端才能向服务端发送请求。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>TableView 中 Cell的重用机制分析</title>
            <link>http://blog.flywithme.top/2016/12/20/dequeueReusableCell/</link>
            <pubDate>Tue, 20 Dec 2016 11:41:34 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/20/dequeueReusableCell/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;UItableView 是我们经常会用到的一个数据列表展示控件, 其 Cell 复用api更是我们要经常用到的
   这个方法到底是怎么实现的呢?&lt;br /&gt;
   &lt;code&gt;[tableView dequeueReusableCellWithIdentifier:CellIdentifier]&lt;/code&gt;由于苹果并没有开源,所以我就对这个
``的实现分析一下。&lt;br /&gt;
   UITableView 的显示和数据是分离的。 列表的实现并不是为每一个数据创建一个 Cell。 而是只创建屏幕可显示的最大个数的 Cell ,然后重用这些 cell,
   对 Cell 做单独的显示配置,来达到既不影响显示效果,又可以充分解约资源的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;重用实现分析:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UITableView.m 中,应该会有两个数据元。 屏幕上已显示的数据源  NSMutableArray* visiableCells, 和一个待使用的可重用数据源 NSMutableDictionary * reusableCels;&lt;br /&gt;
   TableView 初始化之初,这两个数据都是空的。&lt;br /&gt;
   通过&lt;code&gt;[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]&lt;/code&gt; 创建新的 cell,创建之后 数据会进入visiableCells 中
   当屏幕上的Cell 够用之后,会有一个 Cell  使用 key CellIdentifier 存 reusableTableCels 中,&lt;br /&gt;
   比如有20条数据,而屏幕上最多可以显示5条数据。 程序最开始的时候情况是这样的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用&lt;code&gt;[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]&lt;/code&gt;创建5次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且5个cell全部都加入到visiableCells数组，reusableCells为空&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tableView向上滚动时,第一个 Cell1 会移出屏幕,并且第6个 Cell6 也初始化显示完成之后, 第一个 Cell1 会进入reusableCells中,而第6个 Cell6 会加入到 visiableCells中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tableView向下滚动时,如果在顶部,数据不会有变化,如果在中间,上下都屏幕外都有数据。 因为reusableCells中有数据,当需要时会把之前加入的 cell1 返回&lt;code&gt;[tableView dequeueReusableCellWithIdentifier:CellIdentifier]&lt;/code&gt;,并移出 reusableCells,移入visiableCells,底部的 Cell6移入 reusableCells ,这样就完成了重用逻辑。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些情况需要注意,并不是只有拖动的时候才会有以上逻辑,tableview 调用&lt;code&gt;reloadData&lt;/code&gt;的时候,&lt;code&gt;reloadRowsAtIndex&lt;/code&gt; 方法的时候也会,具体步骤,以后再分析。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>JS判断客户端类型</title>
            <link>http://blog.flywithme.top/2016/12/19/clientType/</link>
            <pubDate>Mon, 19 Dec 2016 14:30:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/19/clientType/</guid>
            <description>&lt;p&gt;通过浏览器的userAgent,使用JS判断客户端、浏览器、操作系统类型&lt;/p&gt;

&lt;p&gt;扫描二维码打开:
  &lt;img src=&#34;http://blog.flywithme.top/sources/localHtml/clientType01.png&#34; width = &#34;200&#34; height = &#34;200&#34; alt=&#34;二维码&#34; align=center /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.flywithme.top/sources/localhtml/clientType01/index.html&#34; target=&#34;_blank&#34;&gt;测试链接:&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_weixn(){
        var ua = navigator.userAgent.toLowerCase();
        if(ua.match(/MicroMessenger/i)==&amp;quot;micromessenger&amp;quot;) {
            alert(&#39;在微信里打开&#39;);
        } else {
            alert(&#39;不在微信里打开&#39;);
        }
    }

    is_weixn();



    //判断各个平台
    function detectOS() {
        var sUserAgent = navigator.userAgent;
        var isWin = (navigator.platform == &amp;quot;Win32&amp;quot;) || (navigator.platform == &amp;quot;Windows&amp;quot;);
        var isMac = (navigator.platform == &amp;quot;Mac68K&amp;quot;) || (navigator.platform == &amp;quot;MacPPC&amp;quot;) || (navigator.platform == &amp;quot;Macintosh&amp;quot;) || (navigator.platform == &amp;quot;MacIntel&amp;quot;);
        if (isMac) return &amp;quot;Mac&amp;quot;;
        var isUnix = (navigator.platform == &amp;quot;X11&amp;quot;) &amp;amp;&amp;amp; !isWin &amp;amp;&amp;amp; !isMac;
        if (isUnix) return &amp;quot;Unix&amp;quot;;
        var isLinux = (String(navigator.platform).indexOf(&amp;quot;Linux&amp;quot;) &amp;gt; -1);
        if (isLinux) return &amp;quot;Linux&amp;quot;;
        if (isWin) {
            var isWin2K = sUserAgent.indexOf(&amp;quot;Windows NT 5.0&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 2000&amp;quot;) &amp;gt; -1;
            if (isWin2K) return &amp;quot;Win2000&amp;quot;;
            var isWinXP = sUserAgent.indexOf(&amp;quot;Windows NT 5.1&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows XP&amp;quot;) &amp;gt; -1;
            if (isWinXP) return &amp;quot;WinXP&amp;quot;;
            var isWin2003 = sUserAgent.indexOf(&amp;quot;Windows NT 5.2&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 2003&amp;quot;) &amp;gt; -1;
            if (isWin2003) return &amp;quot;Win2003&amp;quot;;
            var isWinVista= sUserAgent.indexOf(&amp;quot;Windows NT 6.0&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows Vista&amp;quot;) &amp;gt; -1;
            if (isWinVista) return &amp;quot;WinVista&amp;quot;;
            var isWin7 = sUserAgent.indexOf(&amp;quot;Windows NT 6.1&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 7&amp;quot;) &amp;gt; -1;
            if (isWin7) return &amp;quot;Win7&amp;quot;;
            var isWin10 = sUserAgent.indexOf(&amp;quot;Windows NT 10&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 10&amp;quot;) &amp;gt; -1;
            if (isWin10) return &amp;quot;Win10&amp;quot;;
        }
        if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {
            //alert(navigator.userAgent);
//            alert(&#39;这是IOS&#39;);
            return &amp;quot;iOS&amp;quot;
        } else if (/(Android)/i.test(navigator.userAgent)) {
            //alert(navigator.userAgent);
            return &amp;quot;Android&amp;quot;;
        }
        return &amp;quot;other&amp;quot;;
    }

    alert(detectOS());
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
