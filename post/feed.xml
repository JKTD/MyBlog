<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on JKCoder&#39;s Blog </title>
        <link>http://blog.flywithme.top/post/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Thu, 16 Feb 2017 16:11:36 CST</updated>
        
        <item>
            <title>swift03</title>
            <link>http://blog.flywithme.top/2017/02/16/swift03/</link>
            <pubDate>Thu, 16 Feb 2017 16:11:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift03/</guid>
            <description></description>
        </item>
        
        <item>
            <title>Swift 初见</title>
            <link>http://blog.flywithme.top/2017/02/16/swift02/</link>
            <pubDate>Thu, 16 Feb 2017 11:27:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift02/</guid>
            <description>&lt;p&gt;首先我们来在屏幕上输出一个 &lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要 import 任何库,可以直接在全局作用域使用。代码结尾不要带分号。&lt;/p&gt;

&lt;p&gt;Xcode 提供了代码预览功能 &lt;strong&gt;Playground&lt;/strong&gt; . 使用它可以加快 swift的学习速度&lt;/p&gt;

&lt;p&gt;初始化一个变量和常量
    var  a = 2  //可变数据
    a = 3
    let b = 2 //不可变&lt;/p&gt;

&lt;p&gt;if else 雨晶
    if a == 2{
        print(&amp;ldquo;true&amp;rdquo;)
    } else{
       print(&amp;ldquo;false&amp;rdquo;)
    }&lt;/p&gt;

&lt;p&gt;for in 遍历语句(此外还有 ,repeat..while ,for 循环3.0中已经被弃用)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 0...100{
   var c = Double(index)/20.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while 1 == 1 {
    a += 1
    if a == 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repeat&amp;hellip; while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repeat
{
    a += 1
    if a &amp;gt; 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}while( 1 == 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = -3 
assert(age &amp;gt;= 0, &amp;quot;A person&#39;s age cannot be less than zero&amp;quot;) 
// 因为 age &amp;lt; 0，所以断言会触发   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面开始深入学习&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于 Swift</title>
            <link>http://blog.flywithme.top/2017/02/09/swift01/</link>
            <pubDate>Thu, 09 Feb 2017 10:12:48 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/09/swift01/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift 是一门新的编程语言，用于编写 iOS、OS X 以及 watchOS 应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受C兼容性的限制。
Swift 使用安全的编程模式并添加了很多新特性，这将使编程更简单，扩展性更强，也更有趣。Swift 支持 Cocoa 和 Cocoa Touch 框架。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构，让 Swift 使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Objective-C 开发者对于 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性，支持面向过程编程和面向对象编程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 对于初学者来说也很简单。Swift是一门既满足工业标准又像脚本语言一样充满表现力和趣味的编程语言。Swift支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 Swift编写 iOS，watchOS,macOS,和 tvOS apps 是一个极佳的选择。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift 3.0 是自 Swift开源以来第一个大的版本更新。从语言角度不兼容之前的版本。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;部分摘自：&lt;a href=&#34;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html&#34;&gt;AppleLibrary&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go语言fmt包Printf方法详解t</title>
            <link>http://blog.flywithme.top/2017/01/01/golangfmt/</link>
            <pubDate>Sun, 01 Jan 2017 00:56:42 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/01/01/golangfmt/</guid>
            <description>&lt;p&gt;Go语言的标准输出流在打印到屏幕时有些参数跟别的语言（比如C#和Java）不同，下面是我整理的一些常用的格式化输入操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;General&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%v 以默认的方式打印变量的值&lt;/li&gt;
&lt;li&gt;%T 打印变量的类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%+d 带符号的整型，fmt.Printf(&amp;ldquo;%+d&amp;rdquo;, 255)输出+255&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%q 打印单引号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%o 不带零的八进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#o 带零的八进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%x 小写的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%X 大写的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#x 带0x的十六进制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%U 打印Unicode字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%#U 打印带字符的Unicode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;%b 打印整型的二进制&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Integer width&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;%5d 表示该整型最大长度是5，下面这段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1)
fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1234567)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|    1|
|1234567|
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;%-5d则相反，打印结果会自动左对齐&lt;/li&gt;
&lt;li&gt;%05d会在数字前面补零。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Float&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%f (=%.6f) 6位小数点&lt;/li&gt;
&lt;li&gt;%e (=%.6e) 6位小数点（科学计数法）&lt;/li&gt;
&lt;li&gt;%g 用最少的数字来表示&lt;/li&gt;
&lt;li&gt;%.3g 最多3位数字来表示&lt;/li&gt;
&lt;li&gt;%.3f 最多3位小数来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%s 正常输出字符串&lt;/li&gt;
&lt;li&gt;%q 字符串带双引号，字符串中的引号带转义符&lt;/li&gt;
&lt;li&gt;%#q 字符串带反引号，如果字符串内有反引号，就用双引号代替&lt;/li&gt;
&lt;li&gt;%x 将字符串转换为小写的16进制格式&lt;/li&gt;
&lt;li&gt;%X 将字符串转换为大写的16进制格式&lt;/li&gt;
&lt;li&gt;% x 带空格的16进制格式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;String Width&lt;/strong&gt; (以5做例子）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%5s 最小宽度为5&lt;/li&gt;
&lt;li&gt;%-5s 最小宽度为5（左对齐）&lt;/li&gt;
&lt;li&gt;%.5s 最大宽度为5&lt;/li&gt;
&lt;li&gt;%5.7s 最小宽度为5，最大宽度为7&lt;/li&gt;
&lt;li&gt;%-5.7s 最小宽度为5，最大宽度为7（左对齐）&lt;/li&gt;
&lt;li&gt;%5.3s 如果宽度大于3，则截断&lt;/li&gt;
&lt;li&gt;%05s 如果宽度小于5，就会在字符串前面补零&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Struct&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%v 正常打印。比如：{sam {12345 67890}}&lt;/li&gt;
&lt;li&gt;%+v 带字段名称。比如：{name:sam phone:{mobile:12345 office:67890}&lt;/li&gt;
&lt;li&gt;%#v 用Go的语法打印。比如main.People{name:”sam”, phone:main.Phone{mobile:”12345”, office:”67890”}}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Boolean&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%t 打印true或false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pointer&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%p 带0x的指针&lt;/li&gt;
&lt;li&gt;%#p 不带0x的指针&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>golang-Gin-Https</title>
            <link>http://blog.flywithme.top/2016/12/26/golang-Gin-Https/</link>
            <pubDate>Mon, 26 Dec 2016 14:29:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/26/golang-Gin-Https/</guid>
            <description>&lt;p&gt;关于https&lt;br /&gt;
背景知识&lt;br /&gt;
密码学的一些基本知识&lt;br /&gt;
大致上分为两类，基于key的加密算法与不基于key的加密算法。现在的算法基本都是基于key的，key就以一串随机数数，更换了key之后，算法还可以继续使用。&lt;/p&gt;

&lt;p&gt;基于key的加密算法又分为两类，对称加密和不对称加密，比如DES,AES那种的，通信双方一方用key加密之后，另一方用相同的key进行反向的运算就可以解密。&lt;/p&gt;

&lt;p&gt;不对称加密比较著名的就是RSA,加密的时候有一个公钥和一个私钥，公钥是可以交给对方的，a给b发送信息，a用自己的私钥加密，b用a的公钥解密，反之，b给a发送信息，b用自己的私钥加密。&lt;/p&gt;

&lt;p&gt;在通信之前，需要经过一些握手的过程，双方交换公钥，这个就是key exchange的过程，https最开始的阶段就包含了这个key exchange的过程，大概原理是这样，有些地方还要稍微复杂一些。&lt;/p&gt;

&lt;p&gt;数字证书与CA&lt;br /&gt;
数字证书相当于是服务器的一个“身份证”，用于唯一标识一个服务器。一般而言，数字证书从受信的权威证书授权机构 (Certification Authority，证书授权机构)买来的（免费的很少），浏览器里面一般就内置好了一些权威的CA，在使用https的时候，只要是这些CA签发的证书，浏览器都是可以认证的，要是在与服务器通信的时候，收到一个没有权威CA认证的证书，就会报出提醒不受信任证书的错误，就像登录12306一样，但是也可以选择接受。&lt;/p&gt;

&lt;p&gt;在自己的一些项目中，通常是自己签发一个ca根证书，之后这个根证书签发一个server.crt，以及server.key给服务端，server.key是服务端的私钥，server.crt包含了服务端的公钥还有服务端的一些身份信息。在客户端和服务端通信的时候（特别是使用代码编写的客户端访问的时候），要指定ca根证书，作用就相当于是浏览器中内置的那些权威证书一样，用于进行服务端的身份检测。&lt;/p&gt;

&lt;p&gt;证书的格式：&lt;/p&gt;

&lt;p&gt;ca证书在为server.crt证书签名时候的大致流程参考这个(&lt;a href=&#34;http://www.tuicool.com/articles/aymYbmM)：&#34;&gt;http://www.tuicool.com/articles/aymYbmM)：&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数字证书由两部分组成：&lt;/p&gt;

&lt;p&gt;1、C：证书相关信息（对象名称+过期时间+证书发布者+证书签名算法….）&lt;/p&gt;

&lt;p&gt;2、S：证书的数字签名 （由CA证书通过加密算法生成的）&lt;/p&gt;

&lt;p&gt;其中的数字签名是通过公式S = F(Digest&amp;copy;)得到的。&lt;/p&gt;

&lt;p&gt;Digest为摘要函数，也就是 md5、sha-1或sha256等单向散列算法，用于将无限输入值转换为一个有限长度的“浓缩”输出值。比如我们常用md5值来验证下载的大文件是否完整。大文件的内容就是一个无限输入。大文件被放在网站上用于下载时，网站会对大文件做一次md5计算，得出一个128bit的值作为大文件的摘要一同放在网站上。用户在下载文件后，对下载后的文件再进行一次本地的md5计算，用得出的值与网站上的md5值进行比较，如果一致，则大 文件下载完好，否则下载过程大文件内容有损坏或源文件被篡改。这里还有一个小技巧常常在机器之间copy或者下载压缩文件的时候也可以用md5sum的命令来进行检验，看看文件是否完整。&lt;/p&gt;

&lt;p&gt;F为签名函数。CA自己的私钥是唯一标识CA签名的，因此CA用于生成数字证书的签名函数一定要以自己的私钥作为一个输入参数。在RSA加密系统中，发送端的解密函数就是一个以私钥作为参数的函数，因此常常被用作签名函数使用。因此CA用私钥解密函数作为F，以CA证书中的私钥进行加密，生成最后的数字签名，正如最后一部分实践时候给出的证书生成过程，生成server.crt的时候需要ca.crt（包含根证书的信息）和ca.key（根证书的私钥）都加入进去。&lt;/p&gt;

&lt;p&gt;接收端接收服务端数字证书后，如何验证数字证书上携带的签名是这个CA的签名呢？当然接收端首先需要指定对应的CA，接收端会运用下面算法对数字证书的签名进行校验：
F&amp;rsquo;(S) ?= Digest&amp;copy;&lt;/p&gt;

&lt;p&gt;接收端进行两个计算，并将计算结果进行比对：&lt;/p&gt;

&lt;p&gt;1、首先通过Digest&amp;copy;，接收端计算出证书内容（除签名之外）的摘要，C的内容都是明文可以看到到的。&lt;/p&gt;

&lt;p&gt;2、数字证书携带的签名是CA通过CA密钥加密摘要后的结果，因此接收端通过一个解密函数F&amp;rsquo;对S进行“解密”。就像最开始介绍的那样，在RSA系统中，接收端使用CA公钥（包含在ca.crt中）对S进行“解密”，这恰是CA用私钥对S进行“加密”的逆过程。&lt;/p&gt;

&lt;p&gt;将上述两个运算的结果进行比较，如果一致，说明签名的确属于该CA，该证书有效，否则要么证书不是该CA的，要么就是中途被人篡改了。&lt;/p&gt;

&lt;p&gt;对于self-signed(自签发)证书来说，接收端并没有你这个self-CA的数字证书，也就是没有CA公钥，也就没有办法对数字证书的签名进行验证。因此如果要编写一个可以对self-signed证书进行校验的接收端程序的话，首先我们要做的就是建立一个属于自己的CA，用该CA签发我们的server端证书，之后给客户端发送信息的话，需要对这个根证书进行指定，之后按上面的方式进行验证。&lt;/p&gt;

&lt;p&gt;可以使用openssl x509 -text -in client.crt -noout 查看某个证书文件所包含的具体信息。&lt;/p&gt;

&lt;p&gt;HTTPS基本过程概述&lt;/p&gt;

&lt;p&gt;https协议是在http协议的基础上组成的secure的协议。主要功能包含一下两个方面:&lt;/p&gt;

&lt;p&gt;1 通信双方的身份认证&lt;/p&gt;

&lt;p&gt;2 通信双方的通信过程加密&lt;/p&gt;

&lt;p&gt;下面通过详细分析https的通信过程来解释这两个功能。&lt;/p&gt;

&lt;p&gt;具体参考这两个文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fenesky.com/blog/2014/07/19/how-https-works.html&#34;&gt;http://www.fenesky.com/blog/2014/07/19/how-https-works.html&lt;/a&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&#34;&gt;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1、client 发送 sayhello给server端，说明client所支持的加密套件，还有一个随机数1。
2、server 发送 sayhello给client端，端把server.crt发送给客户端,server.crt采用还有一个随机数2。
3、client端生成preMaster key 这个是随机数3，之后三个随机数结合在一起生成MasterSecret,之后生成session secret，使用指定的ca进行身份认证，就像之前介绍的那样，都正常的话，就切换到加密模式。
4、client端使用server.crt中的公钥对preMasterSecret进行加密，如果要进行双向认证的话，client端会把client.crt一并发送过去，server端接受到数据，解密之后，也有了三个随机数，采用同样的方式，三个随机数生成通信所使用的session secret。具体session secret的结构可以参考前面列出的两个博客。server端完成相关工作之后，会发一个ChangeCipherSpec给client，通知client说明自己已经切换到相关的加解密模式，之后发一段加密信息给client看是否正常。
5、client端解密正常，之后就可以按照之前的协议，使用session secret进行加密的通信了。&lt;/p&gt;

&lt;p&gt;整体看下，开始的时候建立握手的过程就是身份认证的过程，之后认证完毕之后，就是加密通信的过程了，https的两个主要做用就实现了。&lt;/p&gt;

&lt;p&gt;相关实践&lt;/p&gt;

&lt;p&gt;比较典型的证书生成的过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out ca.key 2048

#这里可以使用 -subj 不用进行交互 当然还可以添加更多的信息
openssl req -x509 -new -nodes -key ca.key -subj &amp;quot;/CN=zju.com&amp;quot; -days 5000 -out ca.crt

openssl genrsa -out server.key 2048

#这里的/cn可以是必须添加的 是服务端的域名 或者是etc/hosts中的ip别名
openssl req -new -key server.key -subj &amp;quot;/CN=server&amp;quot; -out server.csr

openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 5000
注意生成client端证书的时候，注意要多添加一个字段，golang的server端认证程序会对这个字段进行认证：

openssl genrsa -out client.key 2048

openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

echo extendedKeyUsage=clientAuth &amp;gt; extfile.cnf

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -extfile extfile.cnf -out client.crt -days 5000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;https客户端和服务端单向校验&lt;/p&gt;

&lt;p&gt;这部分参考了这个（&lt;a href=&#34;http://www.tuicool.com/articles/aymYbmM&#34;&gt;http://www.tuicool.com/articles/aymYbmM&lt;/a&gt;
），里面代码部分讲得比较细致。&lt;/p&gt;

&lt;p&gt;服务端采用证书，客户端采用普通方式访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//server端代码
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;os&amp;quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w,
        &amp;quot;Hi, This is an example of https service in golang!&amp;quot;)
}

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, handler)
    //http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
    _, err := os.Open(&amp;quot;cert_server/server.crt&amp;quot;)
    if err != nil {
        panic(err)
    }
    http.ListenAndServeTLS(&amp;quot;:8081&amp;quot;, &amp;quot;cert_server/server.crt&amp;quot;,
        &amp;quot;cert_server/server.key&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client端直接发请求，什么都不加，会报如下错误：&lt;/p&gt;

&lt;p&gt;2015/07/11 18:13:50 http: TLS handshake error from 10.183.47.203:58042: remote error: bad certificate
使用浏览器直接访问的话，之后点击信赖证书，这个时候就可以正常get到消息&lt;/p&gt;

&lt;p&gt;或者使用curl -k https:// 来经行访问，相当于忽略了第一步的身份验证的工作。
要是不加-k的话 使用curl -v 参数打印出来详细的信息，会看到如下的错误：&lt;/p&gt;

&lt;p&gt;curl: (60) SSL certificate problem: Invalid certificate chain
说明是认证没有通过，因为客户端这面并没有提供可以信赖的根证书来对服务端发过来的证书进行验，/CN使用的直接是ip地址，就会报下面的错误：&lt;/p&gt;

&lt;p&gt;Get &lt;a href=&#34;https://10.183.47.206:8081:&#34;&gt;https://10.183.47.206:8081:&lt;/a&gt; x509: cannot validate certificate for 10.183.47.206 because it doesn&amp;rsquo;t contain any IP SANs
最好是生成证书的时候使用域名，或者是在/etc/hosts中加上对应的映射。&lt;/p&gt;

&lt;p&gt;可以发送请求的客户端的代码如下，注意导入根证书的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    //&amp;quot;io&amp;quot;
    //&amp;quot;log&amp;quot;
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    //&amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    //&amp;quot;strings&amp;quot;
)

func main() {
    //x509.Certificate.
    pool := x509.NewCertPool()
    //caCertPath := &amp;quot;etcdcerts/ca.crt&amp;quot;
    caCertPath := &amp;quot;certs/cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)
    //pool.AddCert(caCrt)

    tr := &amp;amp;http.Transport{
        TLSClientConfig:    &amp;amp;tls.Config{RootCAs: pool},
        DisableCompression: true,
    }
    client := &amp;amp;http.Client{Transport: tr}

    resp, err := client.Get(&amp;quot;https://server:8081&amp;quot;)

    if err != nil {
        panic(err)
    }

    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.Status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用curl命令的话，就加上&amp;ndash;cacrt ca.crt证书，这样就相当于添加了可信赖的证书，身份认证的操作就可以成功了。&lt;/p&gt;

&lt;p&gt;比如生成服务端证书的时候/CN写的是server 那client发送的时候也发送给&lt;a href=&#34;https://server:8081就好，不过在本地的/etc/hosts中要加上对应的映射。&#34;&gt;https://server:8081就好，不过在本地的/etc/hosts中要加上对应的映射。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;客户端和服务端的双向校验：&lt;/p&gt;

&lt;p&gt;按照之前的方式，客户端生成证书，根证书就按之前的那个：
    openssl genrsa -out client.key 2048&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 5000
server端代码进行改进，添加受信任的根证书。

// gohttps/6-dual-verify-certs/server.go
package main

import (
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type myhandler struct {
}

func (h *myhandler) ServeHTTP(w http.ResponseWriter,
    r *http.Request) {
    fmt.Fprintf(w,
        &amp;quot;Hi, This is an example of http service in golang!\n&amp;quot;)
}

func main() {
    pool := x509.NewCertPool()
    caCertPath := &amp;quot;cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)

    s := &amp;amp;http.Server{
        Addr:    &amp;quot;:8081&amp;quot;,
        Handler: &amp;amp;myhandler{},
        TLSConfig: &amp;amp;tls.Config{
            ClientCAs:  pool,
            ClientAuth: tls.RequireAndVerifyClientCert,
        },
    }

    err = s.ListenAndServeTLS(&amp;quot;cert_server/server.crt&amp;quot;, &amp;quot;cert_server/server.key&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;ListenAndServeTLS err:&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端代码改进，发送的时候把指定client端的client.crt以及client.key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// gohttps/6-dual-verify-certs/client.go

package main

import (
    &amp;quot;crypto/tls&amp;quot;
    &amp;quot;crypto/x509&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func main() {
    pool := x509.NewCertPool()
    caCertPath := &amp;quot;certs/cert_server/ca.crt&amp;quot;

    caCrt, err := ioutil.ReadFile(caCertPath)
    if err != nil {
        fmt.Println(&amp;quot;ReadFile err:&amp;quot;, err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)

    cliCrt, err := tls.LoadX509KeyPair(&amp;quot;certs/cert_server/client.crt&amp;quot;, &amp;quot;certs/cert_server/client.key&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;Loadx509keypair err:&amp;quot;, err)
        return
    }

    tr := &amp;amp;http.Transport{
        TLSClientConfig: &amp;amp;tls.Config{
            RootCAs:      pool,
            Certificates: []tls.Certificate{cliCrt},
        },
    }
    client := &amp;amp;http.Client{Transport: tr}
    resp, err := client.Get(&amp;quot;https://server:8081&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;Get error:&amp;quot;, err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但实际上，这样是不行的，server端会报这样的错误：&lt;/p&gt;

&lt;p&gt;client&amp;rsquo;s certificate&amp;rsquo;s extended key usage doesn&amp;rsquo;t permit it to be used for client authentication
因为client的证书生成方式有一点不一样，向开始介绍的那样，goalng对于client端的认证要多一个参数，生成证书的时候，要加上一个单独的认证信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -out client.key 2048

openssl req -new -key client.key -subj &amp;quot;/CN=client&amp;quot; -out client.csr

echo extendedKeyUsage=clientAuth &amp;gt; extfile.cnf

openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -extfile extfile.cnf -out client.crt -days 5000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是多添加一个认证文件的信息，之后使用新的证书就可以实现双向认证了，这样只有那些持有被认证过的证书的客户端才能向服务端发送请求。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>TableView 中 Cell的重用机制分析</title>
            <link>http://blog.flywithme.top/2016/12/20/dequeueReusableCell/</link>
            <pubDate>Tue, 20 Dec 2016 11:41:34 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/20/dequeueReusableCell/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;UItableView 是我们经常会用到的一个数据列表展示控件, 其 Cell 复用api更是我们要经常用到的
   这个方法到底是怎么实现的呢?&lt;br /&gt;
   &lt;code&gt;[tableView dequeueReusableCellWithIdentifier:CellIdentifier]&lt;/code&gt;由于苹果并没有开源,所以我就对这个
``的实现分析一下。&lt;br /&gt;
   UITableView 的显示和数据是分离的。 列表的实现并不是为每一个数据创建一个 Cell。 而是只创建屏幕可显示的最大个数的 Cell ,然后重用这些 cell,
   对 Cell 做单独的显示配置,来达到既不影响显示效果,又可以充分解约资源的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;重用实现分析:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UITableView.m 中,应该会有两个数据元。 屏幕上已显示的数据源  NSMutableArray* visiableCells, 和一个待使用的可重用数据源 NSMutableDictionary * reusableCels;&lt;br /&gt;
   TableView 初始化之初,这两个数据都是空的。&lt;br /&gt;
   通过&lt;code&gt;[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]&lt;/code&gt; 创建新的 cell,创建之后 数据会进入visiableCells 中
   当屏幕上的Cell 够用之后,会有一个 Cell  使用 key CellIdentifier 存 reusableTableCels 中,&lt;br /&gt;
   比如有20条数据,而屏幕上最多可以显示5条数据。 程序最开始的时候情况是这样的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用&lt;code&gt;[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]&lt;/code&gt;创建5次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且5个cell全部都加入到visiableCells数组，reusableCells为空&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tableView向上滚动时,第一个 Cell1 会移出屏幕,并且第6个 Cell6 也初始化显示完成之后, 第一个 Cell1 会进入reusableCells中,而第6个 Cell6 会加入到 visiableCells中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tableView向下滚动时,如果在顶部,数据不会有变化,如果在中间,上下都屏幕外都有数据。 因为reusableCells中有数据,当需要时会把之前加入的 cell1 返回&lt;code&gt;[tableView dequeueReusableCellWithIdentifier:CellIdentifier]&lt;/code&gt;,并移出 reusableCells,移入visiableCells,底部的 Cell6移入 reusableCells ,这样就完成了重用逻辑。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一些情况需要注意,并不是只有拖动的时候才会有以上逻辑,tableview 调用&lt;code&gt;reloadData&lt;/code&gt;的时候,&lt;code&gt;reloadRowsAtIndex&lt;/code&gt; 方法的时候也会,具体步骤,以后再分析。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>JS判断客户端类型</title>
            <link>http://blog.flywithme.top/2016/12/19/clientType/</link>
            <pubDate>Mon, 19 Dec 2016 14:30:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/12/19/clientType/</guid>
            <description>&lt;p&gt;通过浏览器的userAgent,使用JS判断客户端、浏览器、操作系统类型&lt;/p&gt;

&lt;p&gt;扫描二维码打开:
  &lt;img src=&#34;http://blog.flywithme.top/sources/localHtml/clientType01.png&#34; width = &#34;200&#34; height = &#34;200&#34; alt=&#34;二维码&#34; align=center /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.flywithme.top/sources/localhtml/clientType01/index.html&#34; target=&#34;_blank&#34;&gt;测试链接:&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_weixn(){
        var ua = navigator.userAgent.toLowerCase();
        if(ua.match(/MicroMessenger/i)==&amp;quot;micromessenger&amp;quot;) {
            alert(&#39;在微信里打开&#39;);
        } else {
            alert(&#39;不在微信里打开&#39;);
        }
    }

    is_weixn();



    //判断各个平台
    function detectOS() {
        var sUserAgent = navigator.userAgent;
        var isWin = (navigator.platform == &amp;quot;Win32&amp;quot;) || (navigator.platform == &amp;quot;Windows&amp;quot;);
        var isMac = (navigator.platform == &amp;quot;Mac68K&amp;quot;) || (navigator.platform == &amp;quot;MacPPC&amp;quot;) || (navigator.platform == &amp;quot;Macintosh&amp;quot;) || (navigator.platform == &amp;quot;MacIntel&amp;quot;);
        if (isMac) return &amp;quot;Mac&amp;quot;;
        var isUnix = (navigator.platform == &amp;quot;X11&amp;quot;) &amp;amp;&amp;amp; !isWin &amp;amp;&amp;amp; !isMac;
        if (isUnix) return &amp;quot;Unix&amp;quot;;
        var isLinux = (String(navigator.platform).indexOf(&amp;quot;Linux&amp;quot;) &amp;gt; -1);
        if (isLinux) return &amp;quot;Linux&amp;quot;;
        if (isWin) {
            var isWin2K = sUserAgent.indexOf(&amp;quot;Windows NT 5.0&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 2000&amp;quot;) &amp;gt; -1;
            if (isWin2K) return &amp;quot;Win2000&amp;quot;;
            var isWinXP = sUserAgent.indexOf(&amp;quot;Windows NT 5.1&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows XP&amp;quot;) &amp;gt; -1;
            if (isWinXP) return &amp;quot;WinXP&amp;quot;;
            var isWin2003 = sUserAgent.indexOf(&amp;quot;Windows NT 5.2&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 2003&amp;quot;) &amp;gt; -1;
            if (isWin2003) return &amp;quot;Win2003&amp;quot;;
            var isWinVista= sUserAgent.indexOf(&amp;quot;Windows NT 6.0&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows Vista&amp;quot;) &amp;gt; -1;
            if (isWinVista) return &amp;quot;WinVista&amp;quot;;
            var isWin7 = sUserAgent.indexOf(&amp;quot;Windows NT 6.1&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 7&amp;quot;) &amp;gt; -1;
            if (isWin7) return &amp;quot;Win7&amp;quot;;
            var isWin10 = sUserAgent.indexOf(&amp;quot;Windows NT 10&amp;quot;) &amp;gt; -1 || sUserAgent.indexOf(&amp;quot;Windows 10&amp;quot;) &amp;gt; -1;
            if (isWin10) return &amp;quot;Win10&amp;quot;;
        }
        if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {
            //alert(navigator.userAgent);
//            alert(&#39;这是IOS&#39;);
            return &amp;quot;iOS&amp;quot;
        } else if (/(Android)/i.test(navigator.userAgent)) {
            //alert(navigator.userAgent);
            return &amp;quot;Android&amp;quot;;
        }
        return &amp;quot;other&amp;quot;;
    }

    alert(detectOS());
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>iOS 开发Debug工具壳</title>
            <link>http://blog.flywithme.top/2016/07/14/debugpanel/</link>
            <pubDate>Thu, 14 Jul 2016 11:40:29 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/07/14/debugpanel/</guid>
            <description>

&lt;h5 id=&#34;初衷:bccb225b752499f845bd206d74979637&#34;&gt;初衷&lt;/h5&gt;

&lt;p&gt;移动端开发的时候总会遇到需要切换设备环境,或者切换服务器环境,或者查看一些测试 Log的时候. 这个时候免不了需要调取一下设备信息, 所以就想做一个固定在状态栏上的的
 Debug 功能控件,之前公司也有一个旧的类似控件,但是里面牵连业务非常多,而且扩展也不友好,所以我就想趁着有新项目需求的时候写一个顶部的控件壳子,
 而且可以很方便的扩展方法,当然,需要的测试方法依然需要开发者手动添加,这个控件并不侵入业务,以后如果有需要可以做一些设备基础功能的公用方法.
 暂时这个工具只有一个非常简单的工具壳,使用起来应该也不算麻烦.下面是使用方法&lt;/p&gt;

&lt;p&gt;效果如下图:
  &lt;img src=&#34;http://blog.flywithme.top/sources/DebugPanel/01.gif&#34; alt=&#34;01&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;使用方法:bccb225b752499f845bd206d74979637&#34;&gt;使用方法&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;Podfile&lt;/strong&gt;&lt;br /&gt;
   To integrate DebugPanel into your Xcode project using CocoaPods, specify it in your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; source &#39;https://github.com/CocoaPods/Specs.git&#39;
 platform :ios, &#39;7.0&#39;
 target &#39;TargetName&#39; do
 pod &#39;DebugPanel&#39;  , :git =&amp;gt;&#39;https://github.com/brasbug/DebugPanel.git&#39;
 end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then ,runthe following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;参数说明:&lt;/strong&gt;&lt;br /&gt;
   &lt;code&gt;MTADebugModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
  *  @author Jack, 16-07-14 12:07:12
  *
  *  title: 显示名称
  *  selectorProperty: 调用的方法名
  *  etc: 额外参数
  */
  @property (nonatomic, strong) NSString *title;
  @property (nonatomic, strong) NSDictionary *etc;
  @property (nonatomic, strong) NSString *selectorProperty;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MTADebugMethodBridge&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在方法调用的时候根据传入的参数生成相应的 selector 
- (BOOL)handleSelectorProperty:(MTADebugModel *)modelProperty
{
    if (modelProperty &amp;amp;&amp;amp; modelProperty.title &amp;amp;&amp;amp; modelProperty.selectorProperty.length) {
        SEL selector = [self selectorForMethod:modelProperty.selectorProperty];
        if (!selector || ![self respondsToSelector:selector]) {
            return NO;
        }
#pragma clang diagnostic push
#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;
        [self performSelector:selector withObject:modelProperty];
        NSLog(@&amp;quot;%@&amp;quot;,modelProperty);
#pragma clang diagnostic pop
        return YES;
    }
    return NO;
}
//生成相应的方法
- (SEL)selectorForMethod:(NSString *)method {
    if ([method length] == 0) return nil;
    NSString *objcMethod = [[@&amp;quot;debugapi_&amp;quot; stringByAppendingString:method] stringByAppendingString:@&amp;quot;:&amp;quot;];
    return NSSelectorFromString(objcMethod);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;br /&gt;
  如果需要在&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;或者是 rootiew 中启动,一定要使用`&lt;code&gt;performSelector&lt;/code&gt;方法延迟调用启动 debug 按钮&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    [self performSelector:@selector(doJobsAfterFinishLaunching) withObject:nil afterDelay:0];
    return YES;
}

- (void)doJobsAfterFinishLaunching
{
    NSMutableArray *arrlist = [NSMutableArray array];

    MTADebugModel *item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;一键线上&amp;quot;;
    item.selectorProperty = @&amp;quot;changeOnlineServer&amp;quot;;
    item.etc = @{@&amp;quot;host&amp;quot;:@&amp;quot;http://www.baidu.com&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;一键测试&amp;quot;;
    item.selectorProperty = @&amp;quot;changeTestServer&amp;quot;;
    item.etc = @{@&amp;quot;host&amp;quot;:@&amp;quot;http://www.sohu.com&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;调试面板&amp;quot;;
    item.selectorProperty = @&amp;quot;showDebugPanel&amp;quot;;
    //    item.etc = @{@&amp;quot;a&amp;quot;:@&amp;quot;b&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;打开 URL&amp;quot;;
    item.selectorProperty = @&amp;quot;OpenSchemeURL&amp;quot;;
    //    item.etc = @{@&amp;quot;c&amp;quot;:@&amp;quot;d&amp;quot;};
    [arrlist addObject:item];

    [[MTADebugpanel shareInstance]startDebugBar:YES methodModels:arrlist error:^(NSString *errMsg) {
        NSLog(@&amp;quot;%@&amp;quot;,errMsg);
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这一步很重要&lt;/strong&gt;&lt;br /&gt;
   创建&lt;code&gt;MTADebugMethodBridge&lt;/code&gt;的 &lt;code&gt;category&lt;/code&gt; 实现你在 &lt;code&gt;MTADebugModel&lt;/code&gt; 中的&lt;code&gt;selectorProperty&lt;/code&gt; 参数方法,需要加上 &lt;code&gt;debugapi_&lt;/code&gt;的签名前缀&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//方法扩展示例
- (void)debugapi_changeOnlineServer:(MTADebugModel *)parameters{
// TODO  Do Your Job
}


- (void)debugapi_OpenSchemeURL:(MTADebugModel *)parameters{
    // TODO  Do Your Job
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>golang-gin 框架学习 一、 GET POST Method</title>
            <link>http://blog.flywithme.top/2016/06/30/Go-gin01/</link>
            <pubDate>Thu, 30 Jun 2016 18:16:12 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/06/30/Go-gin01/</guid>
            <description>

&lt;h5 id=&#34;前言:2551b16abac86e66e05bae7b2b34a895&#34;&gt;前言&lt;/h5&gt;

&lt;p&gt;一直想学一些新的东西,自从接触了 Go 语言,然后学了一些基本语法,但是基本上还是停留在知道这么个语言的阶段,没有深入的了解过.&lt;br /&gt;
 所以就选了一个文档比较齐全的 Gin 来写我的第一个 webServer 项目.这只是一个 Demo ,写这个日志是为了记录自己的学习历程.激励下自己吧.&lt;/p&gt;

&lt;h6 id=&#34;gin-api:2551b16abac86e66e05bae7b2b34a895&#34;&gt;Gin API&lt;/h6&gt;

&lt;p&gt;搭建Web 服务器少不了要写 api 首先从最简单的 GET POST 开始.&lt;br /&gt;
 首先要初始化一个路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    router := gin.Default()//初始化路由
    router.Run(&amp;quot;:8080&amp;quot;) // listen and GO on 0.0.0.0:8080
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;get-method:2551b16abac86e66e05bae7b2b34a895&#34;&gt;GET Method&lt;/h6&gt;

&lt;p&gt;这个最基本的网络请求在 gin 几行代码就可以搞定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.GET(&amp;quot;/user/:name/:action&amp;quot;, func(c *gin.Context) {
        name := c.Param(&amp;quot;name&amp;quot;)
        action := c.Param(&amp;quot;action&amp;quot;)
        message := name + &amp;quot; is &amp;quot; + action
        c.String(http.StatusOK, message)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
 &lt;img src=&#34;sources/GoGin01/20160630-0.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) {
        firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;)
        lastname := c.Query(&amp;quot;lastname&amp;quot;) // shortcut for c.Request.URL.Query().Get(&amp;quot;lastname&amp;quot;)

        c.String(http.StatusOK, &amp;quot;Hello %s %s&amp;quot;, firstname, lastname)
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
  &lt;img src=&#34;sources/GoGin01/20160631-0.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.POST(&amp;quot;/form_post&amp;quot;, func(c *gin.Context) {
        message := c.PostForm(&amp;quot;message&amp;quot;)
        nick := c.DefaultPostForm(&amp;quot;nick&amp;quot;, &amp;quot;anonymous&amp;quot;)

        c.JSON(200, gin.H{
            &amp;quot;status&amp;quot;:  &amp;quot;posted&amp;quot;,
            &amp;quot;message&amp;quot;: message,
            &amp;quot;nick&amp;quot;:    nick,
        })
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;post-method:2551b16abac86e66e05bae7b2b34a895&#34;&gt;POST Method&lt;/h6&gt;

&lt;p&gt;一样只需要几行代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.POST(&amp;quot;/post&amp;quot;, func(c *gin.Context) {

    id := c.Query(&amp;quot;postid&amp;quot;)
    page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;)
    name := c.PostForm(&amp;quot;name&amp;quot;)
    message := c.PostForm(&amp;quot;message&amp;quot;)

    fmt.Printf(&amp;quot;id: %s; page: %s; name: %s; message: %s&amp;quot;, id, page, name, message)

    c.JSON(200, gin.H{
        &amp;quot;status&amp;quot;:  &amp;quot;posted&amp;quot;,
        &amp;quot;id&amp;quot;: id,
        &amp;quot;page&amp;quot;:page,
        &amp;quot;name&amp;quot;:name,
        &amp;quot;message&amp;quot;:message,

    })
}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
 &lt;img src=&#34;sources/GoGin01/20160631-1.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type postForm1 struct {
        UserId     string `form:&amp;quot;userid&amp;quot; binding:&amp;quot;required&amp;quot;`
        Page string `form:&amp;quot;page&amp;quot; binding:&amp;quot;required&amp;quot;`
    }

    router.POST(&amp;quot;/post1&amp;quot;, func(c *gin.Context) {
        var form postForm1
        if c.Bind(&amp;amp;form) == nil{
            c.JSON(200,gin.H{
                &amp;quot;status&amp;quot;:200,
                &amp;quot;id&amp;quot;:form.UserId,
                &amp;quot;page&amp;quot;:form.Page,
            })
        }
        fmt.Printf(&amp;quot;id: %s &amp;quot;, form.UserId)
    }) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
  &lt;img src=&#34;sources/GoGin01/20160631-2.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>ReactiveCocoa简单介绍</title>
            <link>http://blog.flywithme.top/2016/05/15/ReactiveCocoa/</link>
            <pubDate>Tue, 14 Jun 2016 14:33:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/05/15/ReactiveCocoa/</guid>
            <description>

&lt;h5 id=&#34;一-引入-reactivecocoa:28e95232603870e31ddfa6e2560a7d74&#34;&gt;一 引入 ReactiveCocoa&lt;/h5&gt;

&lt;p&gt;使用 pod 引入 选择自己需要的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &#39;ReactiveCocoa&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;二-使用-reactivecocoa:28e95232603870e31ddfa6e2560a7d74&#34;&gt;二 使用 ReactiveCocoa&lt;/h6&gt;

&lt;p&gt;下方会通过一些简单的实例来介绍一下信号量机制和一些常用的方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;引入相应的头文件,在工程中引入下方的头文件（建议在Pch文件中引入）就可以使用我们的ReactiveCocoa框架了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;ReactiveCocoa/ReactiveCocoa.h&amp;gt;
#import &amp;lt;ReactiveCocoa/RACEXTScope.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sequence和Map&lt;br /&gt;
Sequence:队列，是ReactiveCocoa中引入的一个类型，它类似于数组，我们可以暂且把Sequence看做绑定信号量的数组吧。在OC中的NSArray可以通过rac_sequence方法转换成ReactiveCocoa中的Sequence，然后就可以调用处理信号的一些方法了。&lt;br /&gt;
参考以下实例代码：&lt;br /&gt;
   a. 把NSArray通过rac_sequence方法生成RAC中的Sequence&lt;br /&gt;
   b. 获取该Sequence对象的信号量&lt;br /&gt;
   c. 调用Signal的Map方法，使每个元素的首字母大写&lt;br /&gt;
   d. 通过subscribNext方法对其进行遍历输出   　　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//uppercaseString use map
- (void)uppercaseString {


    RACSequence *sequence = [@[@&amp;quot;you&amp;quot;, @&amp;quot;are&amp;quot;, @&amp;quot;beautiful&amp;quot;] rac_sequence];


    RACSignal *signal =  sequence.signal;


    RACSignal *capitalizedSignal = [signal map:^id(NSString * value) {
                               return [value capitalizedString];
                            }];


    [signal subscribeNext:^(NSString * x) {
        NSLog(@&amp;quot;signal --- %@&amp;quot;, x);
    }];


    [capitalizedSignal subscribeNext:^(NSString * x) {
        NSLog(@&amp;quot;capitalizedSignal --- %@&amp;quot;, x);
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下方截图是上个这个方法中的运行结果，从运行结果不难看出，通过Signal相应的方法处理完后，处理的结果会与新返回的信号量所绑定。原信号量中的值保持不变。每次信号量调用相应的方法处理完数据后，都会返回一个新的信号量，而这个信号量是独立于原信号量的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/reactivecocoa/blogreactivelog.png&#34; alt=&#34;reactivelog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由上面的介绍可知，上面方法中的一坨代码可以写成下方的一串。因为一个方法调用后会返回一个持有新结果的新的信号量，然后在这个信号量的基础上再次调用信号量其他的方法。Signal还有其他一些好用的方法，用法和map方法类似，在此就不一一赘述了，gitHub上有相应的实例文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)uppercaseString {


    [[[@[@&amp;quot;you&amp;quot;, @&amp;quot;are&amp;quot;, @&amp;quot;beautiful&amp;quot;] rac_sequence].signal
     map:^id(NSString * value) {
        return [value capitalizedString];
    }] subscribeNext:^(id x) {
        NSLog(@&amp;quot;capitalizedSignal --- %@&amp;quot;, x);
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;信号量开关(Switch)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面把信号量比喻成水管，那么Switch就是水龙头呢。通过Switch我们可以控制那个信号量起作用，并且可以在信号量之间进行切换。也可以这么理解，把Switch看成另一段水管，Switch对接那个水管，就流那个水管的水，这样比喻应该更为贴切一些。下方是一个关于Switch的一个小实例。&lt;/p&gt;

&lt;p&gt;(1) 首先创建3个自定义信号量（3个水管），前两个水管是用来接通不同的水源的(google, baidu), 而最后一个信号量是用来对接不同水源水管的水管（signalOfSignal）。signalOfSignal接baidu水管上，他就流baidu水源的水，接google水管上就流google水源的水。&lt;br /&gt;
   (2) 把signalOfSignal信号量通过switchToLatest方法加工成开关信号量。&lt;br /&gt;
   (3) 紧接着是对通过开关数据进行处理。&lt;br /&gt;
   (4) 开关对接baidu信号量，然后baidu和google信号量同时往水管里灌入数据，那么起作用的是baidu信号量。&lt;br /&gt;
   (5) 开关对接google信号量，google和baidu信号量发送数据，则google信号量输出到signalOfSignal中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//信号开关Switch
- (void)signalSwitch {
    //创建3个自定义信号
    RACSubject *google = [RACSubject subject];
    RACSubject *baidu = [RACSubject subject];
    RACSubject *signalOfSignal = [RACSubject subject];


    //获取开关信号
    RACSignal *switchSignal = [signalOfSignal switchToLatest];


    //对通过开关的信号量进行操作
    [[switchSignal  map:^id(NSString * value) {
        return [@&amp;quot;https//www.&amp;quot; stringByAppendingFormat:@&amp;quot;%@&amp;quot;, value];
    }] subscribeNext:^(NSString * x) {
        NSLog(@&amp;quot;%@&amp;quot;, x);
    }];


    //通过开关打开baidu
    [signalOfSignal sendNext:baidu];
    [baidu sendNext:@&amp;quot;baidu.com&amp;quot;];
    [google sendNext:@&amp;quot;google.com&amp;quot;];


    //通过开关打开google
    [signalOfSignal sendNext:google];
    [baidu sendNext:@&amp;quot;baidu.com/&amp;quot;];
    [google sendNext:@&amp;quot;google.com/&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码输出结果如下：&lt;br /&gt;
    &lt;img src=&#34;sources/reactivecocoa/blogreactivelog1.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信号量的合并&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;信号量的合并说白了就是把两个水管中的水合成一个水管中的水。但这个合并有个限制，当两个水管中都有水的时候才合并。如果一个水管中有水，另一个水管中没有水，那么有水的水管会等到无水的水管中来水了，在与这个水管中的水按规则进行合并。下面这个实例就是把两个信号量进行合并。&lt;/p&gt;

&lt;p&gt;(1) 首先创建两个自定义的信号量letters和numbers&lt;br /&gt;
   (2) 吧两个信号量通过combineLatest函数进行合并，combineLatest说明要合并信号量中最后发送的值&lt;br /&gt;
   (3) reduce块中是合并规则：把numbers中的值拼接到letters信号量中的值后边。&lt;br /&gt;
   (4) 经过上面的步骤就是创建所需的相关信号量，也就是相当于架好运输的管道。接着我们就可以通过sendNext方法来往信号量中发送值了，也就是往管道中进行灌水。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//组合信号
- (void)combiningLatest{
    RACSubject *letters = [RACSubject subject];
    RACSubject *numbers = [RACSubject subject];


    [[RACSignal
     combineLatest:@[letters, numbers]
     reduce:^(NSString *letter, NSString *number){
         return [letter stringByAppendingString:number];
     }]
     subscribeNext:^(NSString * x) {
         NSLog(@&amp;quot;%@&amp;quot;, x);
     }];


    //B1 C1 C2
    [letters sendNext:@&amp;quot;A&amp;quot;];
    [letters sendNext:@&amp;quot;B&amp;quot;];
    [numbers sendNext:@&amp;quot;1&amp;quot;];
    [letters sendNext:@&amp;quot;C&amp;quot;];
    [numbers sendNext:@&amp;quot;2&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面示例的运行输出结果如下：&lt;br /&gt;
   &lt;img src=&#34;sources/reactivecocoa/reactivelog2.png&#34; alt=&#34;log2&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信号的合并（merge）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;信号合并就理解起来就比较简单了，merge信号量规则比较简单，就是把多个信号量，放入数组中通过merge函数来合并数组中的所有信号量为一个。类比一下，合并后，无论哪个水管中有水都会在merge产生的水管中流出来的。下方是merge信号量的代码：&lt;/p&gt;

&lt;p&gt;(1) 创建三个自定义信号量, 用于merge&lt;br /&gt;
   (2) 合并上面创建的3个信号量&lt;br /&gt;
   (3) 往信号里灌入数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//合并信号
- (void)merge {
    RACSubject *letters = [RACSubject subject];
    RACSubject *numbers = [RACSubject subject];
    RACSubject *chinese = [RACSubject subject];


    [[RACSignal
     merge:@[letters, numbers, chinese]]
     subscribeNext:^(id x) {
        NSLog(@&amp;quot;merge:%@&amp;quot;, x);
    }];


    [letters sendNext:@&amp;quot;AAA&amp;quot;];
    [numbers sendNext:@&amp;quot;666&amp;quot;];
    [chinese 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码运行结果如下：&lt;br /&gt;
  &lt;img src=&#34;sources/reactivecocoa/reactivelog3.png&#34; alt=&#34;log3&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>YYModel 简介与使用</title>
            <link>http://blog.flywithme.top/2016/06/12/modelExt/</link>
            <pubDate>Sun, 12 Jun 2016 15:14:43 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/06/12/modelExt/</guid>
            <description>

&lt;h5 id=&#34;1-简单的-json-与-model-的转换:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;1. 简单的 JSON 与 Model 的转换&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;// JSON:
{
    &amp;quot;uid&amp;quot;:123456,
    &amp;quot;name&amp;quot;:&amp;quot;Harry&amp;quot;,
    &amp;quot;created&amp;quot;:&amp;quot;1965-07-31T00:00:00+0000&amp;quot;
}

// Model:
@interface User : NSObject
@property UInt64 uid;
@property NSString *name;
@property NSDate *created;
@end
@implementation User
@end

// 从 JSON 转为 Model:
User *user = [User yy_modelWithJSON:json];

//从 Model 转为 JSON:
NSDictionary *json = [user yy_modelToJSONObject];
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果 Model 属性的类型和 JSON 中的类型不一样，YYModel 会自动进行如下转换:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;table&gt;
       &lt;thead&gt;
         &lt;tr&gt;
           &lt;th width=&#34;35%&#34;&gt;JSON/Dictionary&lt;/th&gt;
           &lt;th&gt;Model&lt;/th&gt;
         &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
         &lt;tr&gt;
           &lt;td&gt;NSString&lt;/td&gt;
           &lt;td&gt;NSURL,SEL,Class&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSString&lt;/td&gt;
           &lt;td&gt;
   NSDate parsed with these formats:          &lt;br/&gt;
   yyyy-MM-dd          &lt;br/&gt;
   yyyy-MM-dd HH:mm:ss          &lt;br/&gt;
   yyyy-MM-dd&amp;rsquo;T&amp;rsquo;HH:mm:ss          &lt;br/&gt;
   yyyy-MM-dd&amp;rsquo;T&amp;rsquo;HH:mm:ssZ          &lt;br/&gt;
   EEE MMM dd HH:mm:ss Z yyyy        &lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSDate&lt;/td&gt;
           &lt;td&gt;NSString (formatted with ISO8601)&amp;quot;YYYY-MM-dd&amp;rsquo;T&amp;rsquo;HH:mm:ssZ&amp;quot;        &lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSString/NSNumber&lt;/td&gt;
           &lt;td&gt;C number (BOOL,int,float,NSUInteger,UInt64,&amp;hellip;)NaN and Inf will be ignored        &lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSNumber&lt;/td&gt;
           &lt;td&gt;NSString (NSNumber.stringValue)&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSValue&lt;/td&gt;
           &lt;td&gt;struct (CGRect,CGSize,&amp;hellip;)&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;NSNull&lt;/td&gt;
           &lt;td&gt;nil,0&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;&amp;quot;null&amp;quot;,&amp;quot;nil&amp;quot;,&amp;quot;no&amp;quot;,&amp;quot;false&amp;quot;,&amp;hellip;&lt;/td&gt;
           &lt;td&gt;nil,0&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
           &lt;td&gt;&amp;quot;YES&amp;quot;,&amp;quot;yes&amp;quot;,&amp;quot;true&amp;quot;,&amp;hellip;&lt;/td&gt;
           &lt;td&gt;@(YES)&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/tbody&gt;
     &lt;/table&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果自动转换不能完成，则相应属性会被忽略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;2-将-model-的属性匹配到指定的-json-nsdictionary-键值:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;2. 将 Model 的属性匹配到指定的 JSON/NSDictionary 键值：&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;// JSON:
{
    &amp;quot;n&amp;quot;:&amp;quot;Harry Pottery&amp;quot;,
    &amp;quot;p&amp;quot;: 256,
    &amp;quot;ext&amp;quot; : {
        &amp;quot;desc&amp;quot; : &amp;quot;A book written by J.K.Rowing.&amp;quot;
    }
}

// Model:
@interface Book : NSObject
@property NSString *name;
@property NSInteger page;
@property NSString *desc;
@end
@implementation Book
+ (NSDictionary *)modelCustomPropertyMapper {
    return @{@&amp;quot;name&amp;quot; : @&amp;quot;n&amp;quot;,
    @&amp;quot;page&amp;quot; : @&amp;quot;p&amp;quot;,
    @&amp;quot;desc&amp;quot; : @&amp;quot;ext.desc&amp;quot;};
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;通过实现 协议中的 modelCustomPropertyMapper，可以将 Model 属性的名字对应到 JSON/NSDictionary 相应的字段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;3-model-属性关联到其他-model:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;3. Model 属性关联到其他 Model&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;// JSON:
{
    &amp;quot;author&amp;quot;:{
        &amp;quot;name&amp;quot;:&amp;quot;J.K.Rowling&amp;quot;,
        &amp;quot;birthday&amp;quot;:&amp;quot;1965-07-31T00:00:00+0000&amp;quot;
    },
    &amp;quot;name&amp;quot;:&amp;quot;Harry Potter&amp;quot;,
    &amp;quot;pages&amp;quot;:256
}

// Model:
@interface Author : NSObject
@property NSString *name;
@property NSDate *birthday;
@end
@implementation Author
@end

@interface Book : NSObject
@property NSString *name;
@property NSUInteger pages;
@property Author *author;
@end
@implementation Book
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;默认什么都不用做，YYModel 就可以自动转换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;4-model-属性是容器类型:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;4. Model 属性是容器类型&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@class Shadow, Border, Attachment;

@interface Attributes
@property NSString *name;
@property NSArray *shadows;
@property NSSet *borders;
@property NSMutableDictionary *attachments;
@end

@implementation Attributes
+ (NSDictionary *)modelContainerPropertyGenericClass {
    return @{@&amp;quot;shadows&amp;quot; : [Shadow class],
             @&amp;quot;borders&amp;quot; : Border.class,
             @&amp;quot;attachments&amp;quot; : @&amp;quot;Attachment&amp;quot; };
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;通过实现 协议中的 modelContainerPropertyGenericClass，返回 Model 属性容器中需要存放的对象类型，YYModel 会自动进行处理。对象类型可以是 Class 或者 Class name。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;5-黑名单白名单:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;5. 黑名单白名单&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@interface User
@property NSString *name;
@property NSUInteger age;
@end

@implementation Attributes
+ (NSArray *)modelPropertyBlacklist {
    return @{@&amp;quot;test1&amp;quot;, @&amp;quot;test2&amp;quot;};
}
+ (NSArray *)modelPropertyWhitelist {
    return @{@&amp;quot;name&amp;quot;};
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果一个 Model 需要忽略某些属性，则可以通过实现 协议中的 modelPropertyBlacklist 来返回属性名列表，YYModel 会在处理过程中忽略这些属性。&lt;/p&gt;

&lt;p&gt;如果一个 Model 只需要处理某些特性的属性，则可以通过实现 协议中的 modelPropertyWhitelist 来返回属性名列表，YYModel 在处理中只会处理列表内的属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;6-数据校验与额外的处理:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;6. 数据校验与额外的处理&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@interface User
@property NSString *name;
@property NSDate *createdAt;
@end

@implementation User
- (BOOL))modelCustomTransformFromDictionary:(NSDictionary *)dic {
    NSNumber *timestamp = dic[@&amp;quot;timestamp&amp;quot;];
    if (![timestamp isKindOfClass:[NSNumber class]]) return NO;
    _createdAt = [NSDate dateWithTimeIntervalSince1970:timestamp.floatValue];
    return YES;
}

- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic {
    if (!_createdAt) return NO;
    dic[@&amp;quot;timestamp&amp;quot;] = @(n.timeIntervalSince1970);
    return YES;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;果一个 Model 需要校验数据有效性，可以通过实现 协议中的 modelCustomTransformFromDictionary 或 modelCustomTransformToDictionary 方法来完成。如果数据校验失败，则可以返回 NO，YYModel 会忽略这个 Model。&lt;/p&gt;

&lt;p&gt;在上面两个方法中，也可以对 Model/JSON 进行额外的处理，以转换 YYModel 不支持的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;6-coding-copying-hash-equal:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;6.Coding/Copying/hash/equal&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@interface YYShadow :NSObject &amp;lt;NSCoding, NSCopying&amp;gt;
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) CGSize size;
@end

@implementation YYShadow
- (void)encodeWithCoder:(NSCoder *)aCoder { [self yy_modelEncodeWithCoder:aCoder]; }
- (id)initWithCoder:(NSCoder *)aDecoder { return [self yy_modelInitWithCoder:aDecoder]; }
- (id)copyWithZone:(NSZone *)zone { return [self yy_modelCopy]; }
- (NSUInteger)hash { return [self yy_modelHash]; }
- (BOOL)isEqual:(id)object { return [self yy_modelIsEqual:object]; }
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;在一个对象的实现中，调用 YYModel 对应的方法，即可实现 NSCoding/NSCopying/hash/equal 协议。YYModel 会自动处理所有有效的 property。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;最后:8ec36dbf2f8e0e1414f1b45b0a0ff0ff&#34;&gt;最后&lt;/h6&gt;

&lt;p&gt;YYModel 的设计目标是高性能和高容错性，虽然功能并不如 Mantle 等项目丰富，但是性能却是远远高于它们。上面所有的方法内部都经过仔细检查，能确保每个属性类型的正确性，避免了可能的崩溃问题。&lt;/p&gt;

&lt;p&gt;from:YYModel作者&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>iOS 自定义 Log 简介</title>
            <link>http://blog.flywithme.top/2016/05/27/Dlog-Introduce/</link>
            <pubDate>Fri, 27 May 2016 10:46:06 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/05/27/Dlog-Introduce/</guid>
            <description>&lt;p&gt;我们在调试程序的时候，往往需要输出一些日志信息，用到NSLog函数，当我们准备发布程序，需要注释掉NSLog代码，这个时候往往会定义一个宏，在调试的时候，会输出日志，在Release正式版本的时候，会关闭日志输出。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef DEBUG
# define DLog(fmt, ...) NSLog((@&amp;quot;[FileName:%s]\n&amp;quot; &amp;quot;[FuctionName:%s]\n&amp;quot; &amp;quot;[Line:%d] \n&amp;quot; fmt), __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);
#else
# define DLog(...);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/dlog/blogDlog.png&#34; alt=&#34;dog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;VA_ARGS&lt;/strong&gt;是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&amp;rdquo;,&amp;ldquo;去掉的作用,否则会编译出错, 你可以试试。&lt;a href=&#34;http://stackoverflow.com/questions/21873616/how-to-use-va-args-properly&#34;&gt;stackOverflow&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;FILE&lt;/strong&gt;宏在预编译时会替换成当前的源文件名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;LINE&lt;/strong&gt;宏在预编译时会替换成当前的行号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;FUNCTION&lt;/strong&gt;宏在预编译时会替换成当前的函数名称&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了以上这几个宏，特别是有了&lt;strong&gt;VA_ARGS&lt;/strong&gt;，调试信息的输出就变得灵活多了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>singnal 信号类型</title>
            <link>http://blog.flywithme.top/2016/06/14/singnal/</link>
            <pubDate>Sun, 15 May 2016 17:26:11 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/06/14/singnal/</guid>
            <description>

&lt;h5 id=&#34;简介:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;简介&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;处理一些 crash 需要查到这些资料&lt;/p&gt;

&lt;p&gt;信号是Linux编程中非常重要的部分，本文将详细介绍信号机制的基本概念、Linux对信号机制的大致实现方法、如何使用信号，以及有关信号的几个系统调用。&lt;br /&gt;
信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。从它的命名可以看出，它的实质和使用很象中断。所以，信号可以说是进程控制的一部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;一-信号的基本概念:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;一、信号的基本概念&lt;/h6&gt;

&lt;p&gt;本节先介绍信号的一些基本概念，然后给出一些基本的信号类型和信号对应的事件。基本概念对于理解和使用信号，对于理解信号机制都特别重要。下面就来看看什么是信号。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。&lt;/p&gt;

&lt;p&gt;收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处 理。第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信 号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。&lt;/p&gt;

&lt;p&gt;在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信号的类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：&lt;/p&gt;

&lt;p&gt;（1） 与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。
   （2） 与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。
   （3） 与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。
   （4） 与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。
   （5） 在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。
   （6） 与终端交互相关的信号。如用户关闭一个终端，或按下break键等情况。
   （7） 跟踪进程执行的信号。&lt;/p&gt;

&lt;p&gt;Linux支持的信号列表如下。很多信号是与机器的体系结构相关的，首先列出的是POSIX.1中列出的信号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
---------------------------------------------------------------------- 
SIGHUP 1 A 终端挂起或者控制进程终止 
SIGINT 2 A 键盘中断（如break键被按下） 
SIGQUIT 3 C 键盘的退出键被按下 
SIGILL 4 C 非法指令 
SIGABRT 6 C 由abort(3)发出的退出指令 
SIGFPE 8 C 浮点异常 
SIGKILL 9 AEF Kill信号 
SIGSEGV 11 C 无效的内存引用 
SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 
SIGALRM 14 A 由alarm(2)发出的信号 
SIGTERM 15 A 终止信号 
SIGUSR1 30,10,16 A 用户自定义信号1 
SIGUSR2 31,12,17 A 用户自定义信号2 
SIGCHLD 20,17,18 B 子进程结束信号 
SIGCONT 19,18,25 进程继续（曾被停止的进程） 
SIGSTOP 17,19,23 DEF 终止进程 
SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键 
SIGTTIN 21,21,26 D 后台进程企图从控制终端读 
SIGTTOU 22,22,27 D 后台进程企图从控制终端写 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的信号没在POSIX.1中列出，而在SUSv2列出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
-------------------------------------------------------------------- 
SIGBUS 10,7,10 C 总线错误(错误的内存访问) 
SIGPOLL A Sys V定义的Pollable事件，与SIGIO同义 
SIGPROF 27,27,29 A Profiling定时器到 
SIGSYS 12,-,12 C 无效的系统调用 (SVID) 
SIGTRAP 5 C 跟踪/断点捕获 
SIGURG 16,23,21 B Socket出现紧急条件(4.2 BSD) 
SIGVTALRM 26,26,28 A 实际时间报警时钟信号(4.2 BSD) 
SIGXCPU 24,24,30 C 超出设定的CPU时间限制(4.2 BSD) 
SIGXFSZ 25,25,31 C 超出设定的文件大小限制(4.2 BSD) 

（对于SIGSYS，SIGXCPU，SIGXFSZ，以及某些机器体系结构下的SIGBUS，Linux缺省的动作是A (terminate)，SUSv2 是C (terminate and dump core)）。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是其它的一些信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
---------------------------------------------------------------------- 
SIGIOT 6 C IO捕获指令，与SIGABRT同义 
SIGEMT 7,-,7 
SIGSTKFLT -,16,- A 协处理器堆栈错误 
SIGIO 23,29,22 A 某I/O操作现在可以进行了(4.2 BSD) 
SIGCLD -,-,18 A 与SIGCHLD同义 
SIGPWR 29,30,19 A 电源故障(System V) 
SIGINFO 29,-,- A 与SIGPWR同义 
SIGLOST -,-,- A 文件锁丢失 
SIGWINCH 28,28,20 B 窗口大小改变(4.3 BSD, Sun) 
SIGUNUSED -,31,- A 未使用的信号(will be SIGSYS) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（在这里，- 表示信号没有实现；有三个值给出的含义为，第一个值通常在Alpha和Sparc上有效，中间的值对应i386和ppc以及sh，最后一个值对应mips。信号29在Alpha上为SIGINFO / SIGPWR ，在Sparc上为SIGLOST。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;处理动作一项中的字母含义如下 
A 缺省的动作是终止进程 
B 缺省的动作是忽略此信号 
C 缺省的动作是终止进程并进行内核映像转储（dump core） 
D 缺省的动作是停止进程 
E 信号不能被捕获 
F 信号不能被忽略 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面介绍的信号是常见系统所支持的。以表格的形式介绍了各种信号的名称、作用及其在默认情况下的处理动作。各种默认处理动作的含义是：终止程序是指进程退 出；忽略该信号是将该信号丢弃，不做处理；停止程序是指程序挂起，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调 用）；内核映像转储是指将进程数据在内存的映像和进程在内核结构中存储的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提 供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。&lt;/p&gt;

&lt;p&gt;注意 信号SIGKILL和SIGSTOP既不能被捕捉，也不能被忽略。信号SIGIOT与SIGABRT是一个信号。可以看出，同一个信号在不同的系统中值可能不一样，所以建议最好使用为信号定义的名字，而不要直接使用信号的值。&lt;/p&gt;

&lt;h6 id=&#34;二-信-号-机-制:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;二、信 号 机 制&lt;/h6&gt;

&lt;p&gt;上一节中介绍了信号的基本概念，在这一节中，我们将介绍内核如何实现信号机制。即内核如何向一个进程发送信号、进程如何接收一个信号、进程怎样控制自己对信 号的反应、内核在什么时机处理和怎样处理进程收到的信号。还要介绍一下setjmp和longjmp在信号中起到的作用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内核对信号的基本处理方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。这里要补充的是，如果信号发送给一个正在睡眠的进程，那么要看 该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。这一点比较重要，因为进程检 查是否收到信号的时机是：一个进程在即将从内核态返回到用户态时；或者，在一个进程要进入或离开一个适当的低调度优先级睡眠状态时。&lt;/p&gt;

&lt;p&gt;内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。&lt;/p&gt;

&lt;p&gt;内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。前面介绍概念的时候讲过，处理信号有三种类型：进程接收到信号后退 出；进程忽略该信号；进程收到信号后执行用户设定用系统调用signal的函数。当进程接收到一个它忽略的信号时，进程丢弃该信号，就象没有收到该信号似 的继续运行。如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创 建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时， 才返回原先进入内核的地方。这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权 限）。&lt;/p&gt;

&lt;p&gt;在信号的处理方法中有几点特别要引起注意。&lt;br /&gt;
   &lt;strong&gt;第一&lt;/strong&gt; 在一些系统中，当一个进程处理完中断信号返回用户态之前，内核清除用户区中设 定的对该信号的处理例程的地址，即下一次进程对该信号的处理方法又改为默认值，除非在下一次信号到来之前再次使用signal系统调用。这可能会使得进程 在调用signal之前又得到该信号而导致退出。在BSD中，内核不再清除该地址。但不清除该地址可能使得进程因为过多过快的得到某个信号而导致堆栈溢 出。为了避免出现上述情况。在BSD系统中，内核模拟了对硬件中断的处理方法，即在处理某个中断时，阻止接收新的该类中断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二&lt;/strong&gt; 引起注意的是，如果要捕捉的信号发生于进程正在一个系统调用中时，并且该进程睡眠在可中断的优先级上，这时该信号引起进程作一次longjmp，跳出睡眠 状态，返回用户态并执行信号处理例程。当从信号处理例程返回时，进程就象从系统调用返回一样，但返回了一个错误代码，指出该次系统调用曾经被中断。这要注 意的是，BSD系统中内核可以自动地重新开始系统调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三&lt;/strong&gt; 注意的地方：若进程睡眠在可中断的优先级上，则当它收到一个要忽略的信号时，该进程被唤醒，但不做longjmp，一般是继续睡眠。但用户感觉不到进程曾经被唤醒，而是象没有发生过该信号一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四&lt;/strong&gt; 注意的地方：内核对子进程终止（SIGCLD）信号的处理方法与其他信号有所区别。当进程检查出收到了一个子进程终止的信号时，缺省情况下，该进程 就象没有收到该信号似的，如果父进程执行了系统调用wait，进程将从系统调用wait中醒来并返回wait调用，执行一系列wait调用的后续操作（找 出僵死的子进程，释放子进程的进程表项），然后从wait中返回。SIGCLD信号的作用是唤醒一个睡眠在可被中断优先级上的进程。如果该进程捕捉了这个 信号，就象普通信号处理一样转到处理例程。如果进程忽略该信号，那么系统调用wait的动作就有所不同，因为SIGCLD的作用仅仅是唤醒一个睡眠在可被 中断优先级上的进程，那么执行wait调用的父进程被唤醒继续执行wait调用的后续操作，然后等待其他的子进程。&lt;/p&gt;

&lt;p&gt;如果一个进程调用signal系统调用，并设置了SIGCLD的处理方法，并且该进程有子进程处于僵死状态，则内核将向该进程发一个SIGCLD信号。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;setjmp和longjmp的作用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前面在介绍信号处理机制时，多次提到了setjmp和longjmp，但没有仔细说明它们的作用和实现方法。这里就此作一个简单的介绍。&lt;/p&gt;

&lt;p&gt;在介绍信号的时候，我们看到多个地方要求进程在检查收到信号后，从原来的系统调用中直接返回，而不是等到该调用完成。这种进程突然改变其上下文的情况，就是 使用setjmp和longjmp的结果。setjmp将保存的上下文存入用户区，并继续在旧的上下文中执行。这就是说，进程执行一个系统调用，当因为资 源或其他原因要去睡眠时，内核为进程作了一次setjmp，如果在睡眠中被信号唤醒，进程不能再进入睡眠时，内核为进程调用longjmp，该操作是内核 为进程将原先setjmp调用保存在进程用户区的上下文恢复成现在的上下文，这样就使得进程可以恢复等待资源前的状态，而且内核为setjmp返回1，使 得进程知道该次系统调用失败。这就是它们的作用。&lt;/p&gt;

&lt;h6 id=&#34;三-有关信号的系统调用:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;三、有关信号的系统调用&lt;/h6&gt;

&lt;p&gt;前面两节已经介绍了有关信号的大部分知 识。这一节我们来了解一下这些系统调用。其中，系统调用signal是进程用来设定某个信号的处理方法，系统调用kill是用来发送信号给指定进程的。这 两个调用可以形成信号的基本操作。后两个调用pause和alarm是通过信号实现的进程暂停和定时器，调用alarm是通过信号通知进程定时器到时。所 以在这里，我们还要介绍这两个调用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;signal 系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用signal用来设定某个信号的处理方法。该调用声明的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void (*signal(int signum, void (*handler)(int)))(int); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述声明格式比较复杂，如果不清楚如何使用，也可以通过下面这种类型定义的格式来使用（POSIX的定义）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef void (*sighandler_t)(int); 
sighandler_t signal(int signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这种格式在不同的系统中有不同的类型定义，所以要使用这种格式，最好还是参考一下联机手册。&lt;/p&gt;

&lt;p&gt;在调用中，参数signum指出要设置处理方法的信号。第二个参数handler是一个处理函数，或者是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SIG_IGN：忽略参数signum所指的信号。 
SIG_DFL：恢复参数signum所指信号的处理方法为默认值。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传递给信号处理例程的整数参数是信号值，这样可以使得一个信号处理例程处理多个信号。系统调用signal返回值是指定信号signum前一次的处理例程或者错误时返回错误代码SIG_ERR。下面来看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
void sigroutine(int dunno) { /* 信号处理例程，其中dunno将会得到信号的值 */ 
switch (dunno) { 
case 1: 
printf(&amp;quot;Get a signal -- SIGHUP &amp;quot;); 
break; 
case 2: 
printf(&amp;quot;Get a signal -- SIGINT &amp;quot;); 
break; 
case 3: 
printf(&amp;quot;Get a signal -- SIGQUIT &amp;quot;); 
break; 
} 
return; 
} 

int main() { 
printf(&amp;quot;process id is %d &amp;quot;,getpid()); 
signal(SIGHUP, sigroutine); //* 下面设置三个信号的处理方法 
signal(SIGINT, sigroutine); 
signal(SIGQUIT, sigroutine); 
for (;;) ; 
} 

其中信号SIGINT由按下Ctrl-C发出，信号SIGQUIT由按下Ctrl-发出。该程序执行的结果如下： 

localhost:~$ ./sig_test 
process id is 463 
Get a signal -SIGINT //按下Ctrl-C得到的结果 
Get a signal -SIGQUIT //按下Ctrl-得到的结果 
//按下Ctrl-z将进程置于后台 
[1]+ Stopped ./sig_test 
localhost:~$ bg 
[1]+ ./sig_test &amp;amp; 
localhost:~$ kill -HUP 463 //向进程发送SIGHUP信号 
localhost:~$ Get a signal – SIGHUP 
kill -9 463 //向进程发送SIGKILL信号，终止进程 
localhost:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;kill 系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用kill用来向进程发送一个信号。该调用声明的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int kill(pid_t pid, int sig); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; 
#include &amp;lt;signal.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该系统调用可以用来向任何进程或进程组发送任何信号。如果参数pid是正数，那么该调用将信号sig发送到进程号为pid的进程。如果pid等于0，那么信 号sig将发送给当前进程所属进程组里的所有进程。如果参数pid等于-1，信号sig将发送给除了进程1和自身以外的所有进程。如果参数pid小于- 1，信号sig将发送给属于进程组-pid的所有进程。如果参数sig为0，将不发送信号。该调用执行成功时，返回值为0；错误时，返回-1，并设置相应 的错误代码errno。下面是一些可能返回的错误代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EINVAL：指定的信号sig无效。 
ESRCH：参数pid指定的进程或进程组不存在。注意，在进程表项中存在的进程，可能是一个还没有被wait收回，但已经终止执行的僵死进程。 
EPERM： 进程没有权力将这个信号发送到指定接收信号的进程。因为，一个进程被允许将信号发送到进程pid时，必须拥有root权力，或者是发出调用的进程的UID 或EUID与指定接收的进程的UID或保存用户ID（savedset-user-ID）相同。如果参数pid小于-1，即该信号发送给一个组，则该错误 表示组中有成员进程不能接收该信号。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.pause系统调用&lt;/p&gt;

&lt;p&gt;系统调用pause的作用是等待一个信号。该调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int pause(void); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：
    #include &lt;unistd.h&gt;&lt;/p&gt;

&lt;p&gt;该调用使得发出调用的进程进入睡眠，直到接收到一个信号为止。该调用总是返回-1，并设置错误代码为EINTR（接收到一个信号）。下面是一个简单的范例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;signal.h&amp;gt; 
void sigroutine(int unused) { 
printf(&amp;quot;Catch a signal SIGINT &amp;quot;); 
} 

int main() { 
signal(SIGINT, sigroutine); 
pause(); 
printf(&amp;quot;receive a signal &amp;quot;); 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，程序开始执行，就象进入了死循环一样，这是因为进程正在等待信号，当我们按下Ctrl-C时，信号被捕捉，并且使得pause退出等待状态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;alarm和 setitimer系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用alarm的功能是设置一个定时器，当定时器计时到达时，将发出一个信号给进程。该调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned int alarm(unsigned int seconds); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;系统调用alarm安排内核为调用进程在指定的seconds秒后发出一个SIGALRM的信号。如果指定的参数seconds为0，则不再发送 SIGALRM信号。后一次设定将取消前一次的设定。该调用返回值为上次定时调用到发送之间剩余的时间，或者因为没有前一次定时调用而返回0。&lt;/p&gt;

&lt;p&gt;注意，在使用时，alarm只设定为发送一次信号，如果要多次发送，就要多次使用alarm调用。&lt;/p&gt;

&lt;p&gt;对于alarm，这里不再举例。现在的系统中很多程序不再使用alarm调用，而是使用setitimer调用来设置定时器，用getitimer来得到定时器的状态，这两个调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int getitimer(int which, struct itimerval *value); 
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用这两个调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/time.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该系统调用给进程提供了三个定时器，它们各自有其独有的计时域，当其中任何一个到达，就发送一个相应的信号给进程，并使得计时器重新开始。三个计时器由参数which指定，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TIMER_REAL：按实际时间计时，计时到达将给进程发送SIGALRM信号。 
ITIMER_VIRTUAL：仅当进程执行时才进行计时。计时到达将发送SIGVTALRM信号给进程。 
ITIMER_PROF：当进程执行时和系统为该进程执行动作时都计时。与ITIMER_VIR-TUAL是一对，该定时器经常用来统计进程在用户态和内核态花费的时间。计时到达将发送SIGPROF信号给进程。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定时器中的参数value用来指明定时器的时间，其结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct itimerval { 
struct timeval it_interval; /* 下一次的取值 */ 
struct timeval it_value; /* 本次的设定值 */ 
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该结构中timeval结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct timeval { 
long tv_sec; /* 秒 */ 
long tv_usec; /* 微秒，1秒 = 1000000 微秒*/ 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在setitimer 调用中，参数ovalue如果不为空，则其中保留的是上次调用设定的值。定时器将it_value递减到0时，产生一个信号，并将it_value的值设 定为it_interval的值，然后重新开始计时，如此往复。当it_value设定为0时，计时器停止，或者当它计时到期，而it_interval 为0时停止。调用成功时，返回0；错误时，返回-1，并设置相应的错误代码errno：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EFAULT：参数value或ovalue是无效的指针。 
EINVAL：参数which不是ITIMER_REAL、ITIMER_VIRT或ITIMER_PROF中的一个。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是关于setitimer调用的一个简单示范，在该例子中，每隔一秒发出一个SIGALRM，每隔0.5秒发出一个SIGVTALRM信号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;sys/time.h&amp;gt; 
int sec; 

void sigroutine(int signo) { 
switch (signo) { 
case SIGALRM: 
printf(&amp;quot;Catch a signal -- SIGALRM &amp;quot;); 
break; 
case SIGVTALRM: 
printf(&amp;quot;Catch a signal -- SIGVTALRM &amp;quot;); 
break; 
} 
return; 
} 

int main() { 
struct itimerval value,ovalue,value2; 
sec = 5; 

printf(&amp;quot;process id is %d &amp;quot;,getpid()); 
signal(SIGALRM, sigroutine); 
signal(SIGVTALRM, sigroutine); 

value.it_value.tv_sec = 1; 
value.it_value.tv_usec = 0; 
value.it_interval.tv_sec = 1; 
value.it_interval.tv_usec = 0; 
setitimer(ITIMER_REAL, &amp;amp;value, &amp;amp;ovalue); 

value2.it_value.tv_sec = 0; 
value2.it_value.tv_usec = 500000; 
value2.it_interval.tv_sec = 0; 
value2.it_interval.tv_usec = 500000; 
setitimer(ITIMER_VIRTUAL, &amp;amp;value2, &amp;amp;ovalue); 

for (;;) ; 
} 

该例子的屏幕拷贝如下： 

localhost:~$ ./timer_test 
process id is 579 
Catch a signal – SIGVTALRM 
Catch a signal – SIGALRM 
Catch a signal – SIGVTALRM 
Catch a signal – SIGVTALRM 
Catch a signal – SIGALRM 
Catch a signal –GVTALRM 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>UINavigationBar-使用总结</title>
            <link>http://blog.flywithme.top/2016/05/03/UINavigationBar-Summary/</link>
            <pubDate>Tue, 03 May 2016 11:49:19 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/05/03/UINavigationBar-Summary/</guid>
            <description>

&lt;h5 id=&#34;简介:fd9faebe845f09d44f4a35833c132216&#34;&gt;简介&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;UINavigationBar&lt;/code&gt;是用于实现管理层级关系内容的组件，直接继承自&lt;code&gt;UIView&lt;/code&gt;。通常用在&lt;code&gt;UINavgationController&lt;/code&gt;类中，用于管理和显示&lt;code&gt;UINavgationController&lt;/code&gt;的&lt;code&gt;subViewController&lt;/code&gt; , 同时&lt;code&gt;UINavgationBar&lt;/code&gt;也可以单独使用，添加至任何的&lt;code&gt;UIView&lt;/code&gt;中。&lt;code&gt;UINavigationBar&lt;/code&gt;比较重要的属性为，左侧按钮，中间的标题，以及右侧按钮。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NS_CLASS_AVAILABLE_IOS(2_0) @interface UINavigationBar : UIView &amp;lt;NSCoding, UIBarPositioning&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;在导航控制器中的简单使用:fd9faebe845f09d44f4a35833c132216&#34;&gt;在导航控制器中的简单使用&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取导航条&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UINavigationBar *navBar = self.navigationController.navigationBar;
//设置导航栏 title
self.navigationItem.title = @&amp;quot;UINavigationBar使用总结&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置导航栏背景色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//通过barTintColor来设置背景色
self.navigationController.navigationBar.barTintColor = [UIColor redColor];//iOS7 以上系统  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/navigationbar/navigationbackbartiniColor.png&#34; alt=&#34;navigation back bar tint Color&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置导航栏的背景图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@&amp;quot;Background&amp;quot;] forBarMetrics:UIBarMetricsDefault];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/navigationbar/uinavigationBarbackground.png&#34; alt=&#34;navigation Bar background&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这里得稍微说说UIBarMetrics这个枚举, 它主要是用来控制在不同状态下导航栏的显示。和&lt;code&gt;UIButton&lt;/code&gt;的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)setBackgroundImage:(nullable UIImage *)image forState:(UIControlState)state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法有点类似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, UIBarMetrics) {
    UIBarMetricsDefault,
    UIBarMetricsCompact,
    UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar
    UIBarMetricsCompactPrompt,
    UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &amp;quot;Use UIBarMetricsCompact instead&amp;quot;) = UIBarMetricsCompact,
    UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &amp;quot;Use UIBarMetricsCompactPrompt&amp;quot;) = UIBarMetricsCompactPrompt,
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置导航栏样式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[navBar setBarStyle:UIBarStyleDefault];  
   分别有如下几种样式：  
typedef NS_ENUM(NSInteger, UIBarStyle) {  
    UIBarStyleDefault          = 0,  
    UIBarStyleBlack            = 1,  
    UIBarStyleBlackOpaque      = 1, // Deprecated. Use UIBarStyleBlack  
    UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES
};    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;我们发现，在后面两个标记为Deprecated，我们知道使用后面两种将不被提倡。
            从枚举中，我们也可以看出：UIBarStyleBlack=1和UIBarStyleBlackOpaque=1表示为一样的。
            后来，发现增加了一个方法：[navBar setTranslucent:YES];用来指示是否透明。
            所以，我们使用UIBarStyleDefault和UIBarStyleBlack来定义UINavigationBar样式，并且用setTranslucent:方法来设置透明与否。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//使用方式
switch (buttonIndex) {
   case 0: // &amp;quot;Default&amp;quot;
       self.navigationController.navigationBar.barStyle = UIBarStyleDefault;
       // Bars are translucent by default.
       self.navigationController.navigationBar.translucent = YES;
       // Reset the bar&#39;s tint color to the system default.
       self.navigationController.navigationBar.tintColor = nil;
       self.navigationController.navigationBar.barTintColor = nil;//iOS7 以上系统


       break;
   case 1: // &amp;quot;Black Opaque&amp;quot;
       self.navigationController.navigationBar.barStyle = UIBarStyleBlack;
       self.navigationController.navigationBar.translucent = NO;
       self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
       break;
   case 2: // &amp;quot;Black Translucent&amp;quot;
       self.navigationController.navigationBar.barStyle = UIBarStyleBlack;
       self.navigationController.navigationBar.translucent = YES;
       self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
       self.navigationController.navigationBar.barTintColor = [UIColor redColor];
       break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更改顶部状态栏的颜色
   修改完导航栏的颜色之后,顶部状态栏可能因为导航栏的颜色相近而现实不清楚,所以有时候需要修改状态栏的颜色
   状态栏的颜色修改:系统给我们提供了&lt;code&gt;UIStatusBarStyleDefault&lt;/code&gt;和&lt;code&gt;UIStatusBarStyleLightContent&lt;/code&gt;两种样式供我们选择。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   UIStatusBarStyleDefault，系统的默认样式，黑色内容，用于浅色的背景（如白色）
   UIStatusBarStyleLightContent 白色内容，用于深色的背景（如红色）
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下面来看看具体怎么实现，主流的实现方式是分两步：&lt;br /&gt;
   &lt;strong&gt;a.&lt;/strong&gt; 在工程的Info.plist文件中添加一行&lt;code&gt;UIViewControllerBasedStatusBarAppearance&lt;/code&gt;，选择Boolean类型，并设置为YES，Xcode会自动把名称变为&lt;code&gt;View controller-based status bar appearance&lt;/code&gt;。&lt;br /&gt;
   &lt;strong&gt;b.&lt;/strong&gt; 在你的ViewController中添加下面的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(UIStatusBarStyle)preferredStatusBarStyle{
  return UIStatusBarStyleLightContent;
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;另外，&lt;strong&gt;特别需要注意的是&lt;/strong&gt;，如果你的ViewController是通过navigationController push进来的，还需要加下面一句代码才能生效：
   &lt;code&gt;self.navigationController.navigationBar.barStyle = UIBarStyleBlack;&lt;/code&gt;
   具体，可参考&lt;a href=&#34;http://stackoverflow.com/questions/19108513/uistatusbarstyle-preferredstatusbarstyle-does-not-work-on-ios-7&#34;&gt;UIStatusBarStyle PreferredStatusBarStyle does not work on iOS 7&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;恩，我们来看看运行效果。&lt;br /&gt;
   &lt;img src=&#34;sources/navigationbar/uinavigationBarbackground.png&#34; alt=&#34;naviagation&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置返回按钮
  从上面的效果图中我们可以看到返回按钮还是默认的蓝色按钮，下面我将会大家来介绍返回按钮的个性化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置返回按钮的颜色 只需要设置tintColor属性即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的效果图如下：&lt;br /&gt;
&lt;img src=&#34;sources/navigationbar/navigationbartiniColor.png&#34; alt=&#34;naviagation&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只设置返回按钮的图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)goToBack {
    [self.navigationController popViewControllerAnimated:YES];
}


- (void)setBackButtonWithImage {
    UIImage *leftButtonIcon = [[UIImage imageNamed:@&amp;quot;LeftButton_back_Icon&amp;quot;]
                               imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
    UIBarButtonItem *leftButton = [[UIBarButtonItem alloc] initWithImage:leftButtonIcon
                                                                   style:UIBarButtonItemStyleBordered
                                                                  target:self
                                                                  action:@selector(goToBack)];
    self.navigationItem.leftBarButtonItem = leftButton;


    //修复navigationController侧滑关闭失效的问题
    self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的效果如下：&lt;br /&gt;
&lt;img src=&#34;sources/navigationbar/navigationBarBackBtn.png&#34; alt=&#34;naviagation&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里需要注意的地方有三点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;需要自己实现返回按钮的事件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;特别的解释下&lt;code&gt;UIImage&lt;/code&gt;的&lt;code&gt;imageWithRenderingMode:&lt;/code&gt;方法，参数&lt;code&gt;UIImageRenderingModeAlwaysOriginal&lt;/code&gt; 表示总是用原图渲染，如果不这么设置，返回按钮将会显示&lt;code&gt;tintColor&lt;/code&gt;的颜色(默认为蓝色)。&lt;code&gt;UITabbarItem&lt;/code&gt;也存在同样地问题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;我们自己设置返回按钮，会导致系统的侧滑关闭效果失效。添加上面代码中最后一句代码即可修复(&lt;code&gt;self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;&lt;/code&gt;)。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;仅设置返回按钮的文字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)setBackButtonTitle {
    UIBarButtonItem *leftButton = [[UIBarButtonItem alloc]
            initWithTitle:NSLocalizedString(@&amp;quot;取消&amp;quot;, nil)  
            style:UIBarButtonItemStylePlain  
            target:self action:@selector(goToBack)];
    leftButton.tintColor = [UIColor whiteColor];
    self.navigationItem.leftBarButtonItem = leftButton;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的效果如下：&lt;br /&gt;
  &lt;img src=&#34;sources/navigationbar/navigationbarBtnTitle.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自定义返回按钮&lt;br /&gt;
 如果上面几种方式还无法满足你的要求（比如，需要同时设置返回按钮文字和图片），就需要用到UIBarButtonItem的initWithCustomView方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)setCustomLeftButton {
    UIView* leftButtonView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 60, 40)];
    UIButton* leftButton = [UIButton buttonWithType:UIButtonTypeSystem];
    leftButton.backgroundColor = [UIColor clearColor];
    leftButton.frame = leftButtonView.frame;
    [leftButton setImage:[UIImage imageNamed:@&amp;quot;LeftButton_back_Icon&amp;quot;] forState:UIControlStateNormal];
    [leftButton setTitle:@&amp;quot;返回&amp;quot; forState:UIControlStateNormal];
    leftButton.tintColor = [UIColor redColor];
    leftButton.autoresizesSubviews = YES;
    leftButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
    leftButton.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleLeftMargin;
    [leftButton addTarget:self action:@selector(goToBack) forControlEvents:UIControlEventTouchUpInside];
    [leftButtonView addSubview:leftButton];
    UIBarButtonItem* leftBarButton = [[UIBarButtonItem alloc] initWithCustomView:leftButtonView];
    self.navigationItem.leftBarButtonItem = leftBarButton;
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到的效果图如下：&lt;br /&gt;
   &lt;img src=&#34;sources/navigationbar/navigationBackBartBackImage.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;设置&lt;code&gt;rightBarButtonItem&lt;/code&gt;基本上脱离不了上面的几种方式，大家可以参照上面返回按钮的设置方式。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;隐藏导航栏底部的线条&lt;br /&gt;
  有时候遇到一些特殊的要求，需要隐藏导航栏底部的线条。
  两行代码就可以做到。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置导航栏的背景图（&lt;code&gt;setBackgroundImage&lt;/code&gt;方法）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置导航栏的shadowImage (&lt;code&gt;setShadowImage&lt;/code&gt;方法)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UINavigationBar *navigationBar = self.navigationController.navigationBar;
//设置透明的背景图，便于识别底部线条有没有被隐藏
[navigationBar setBackgroundImage:[[UIImage alloc] init]
                       forBarPosition:UIBarPositionAny
                           barMetrics:UIBarMetricsDefault];
//此处使底部线条失效
[navigationBar setShadowImage:[UIImage new]];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看看效果图：&lt;br /&gt;
   &lt;img src=&#34;sources/navigationbar/navShadowLineHide.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;还有一种做法，一行代码就可以达到效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//方法二：
self.navigationController.navigationBar.clipsToBounds = YES;  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;想要知道更详细的内容可以参考这个页面：&lt;a href=&#34;http://stackoverflow.com/questions/19226965/how-to-hide-ios7-uinavigationbar-1px-bottom-line&#34;&gt;How to hide iOS7 UINavigationBar 1px bottom line&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置导航条底部线条的颜色&lt;br /&gt;
   有了上面的基础，设置导航栏线条的颜色就变得很简单了。&lt;br /&gt;
   首先，我做了个UIImage的分类：通过颜色转成UIImage；&lt;br /&gt;
   然后，用上面的方案来设置导航栏底部线条。&lt;/p&gt;

&lt;p&gt;颜色转图片的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation UIImage (ColorImage)


+ (UIImage *)imageWithColor:(UIColor *)color
{
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();


    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);


    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();


    return image;
}


@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置导航栏底部线条颜色的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UINavigationBar *navigationBar = self.navigationController.navigationBar;
[navigationBar setBackgroundImage:[[UIImage alloc] init]
                        forBarPosition:UIBarPositionAny
                            barMetrics:UIBarMetricsDefault];
//此处使底部线条颜色为红色
[navigationBar setShadowImage:[UIImage imageWithColor:[UIColor redColor]]]; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依照惯例，看下效果图：&lt;br /&gt;
     &lt;img src=&#34;sources/navigationbar/anvShadowSet.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当然还有其他的方式也可以做到，如&lt;code&gt;addSubview&lt;/code&gt;,&lt;code&gt;addSubLayer&lt;/code&gt;等。感兴趣的话可以参考下这个页面：&lt;a href=&#34;http://stackoverflow.com/questions/19101361/ios7-change-uinavigationbar-border-color&#34;&gt;iOS7 - Change UINavigationBar border color&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在导航栏上添加多个按钮&lt;br /&gt;
  以微信打开网页时的效果为例，效果图如下，有两个按钮：返回和关闭。&lt;br /&gt;
    &lt;img src=&#34;sources/navigationbar/dianpschreenshot.png&#34; alt=&#34;center&#34; width=&#34;500&#34;&gt;&lt;/p&gt;

&lt;p&gt;有下面两种方式可供选择，但是最终还是要用到&lt;code&gt;leftBarButtonItems&lt;/code&gt;这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define UserMethod1 0


UIBarButtonItem *closeItem = [[UIBarButtonItem alloc] initWithTitle:@&amp;quot;关闭&amp;quot; style:UIBarButtonItemStylePlain target:self action:@selector(closeAction)];
if (UserMethod1) {
    //方法一:
    self.navigationItem.leftBarButtonItems = @[closeItem];
    //要求显示默认的返回按钮，但是文字会显示默认的Back，暂时还不知道这个文字怎么改
    self.navigationItem.leftItemsSupplementBackButton = YES;
}
else {
    //方法二
    UIButton* leftButton = [UIButton buttonWithType:UIButtonTypeSystem];
    leftButton.backgroundColor = [UIColor clearColor];
    leftButton.frame = CGRectMake(0, 0, 45, 40);
    [leftButton setImage:[UIImage imageNamed:@&amp;quot;LeftButton_back_Icon&amp;quot;] forState:UIControlStateNormal];
    [leftButton setTitle:@&amp;quot;返回&amp;quot; forState:UIControlStateNormal];
    leftButton.tintColor = [UIColor whiteColor];
    leftButton.autoresizesSubviews = YES;
    leftButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
    leftButton.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleLeftMargin;
    [leftButton addTarget:self action:@selector(goToBack) forControlEvents:UIControlEventTouchUpInside];
    UIBarButtonItem* backItem = [[UIBarButtonItem alloc] initWithCustomView:leftButton];


    self.navigationItem.leftBarButtonItems = @[backItem,closeItem];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，运行的效果图如下：&lt;br /&gt;
    &lt;img src=&#34;sources/navigationbar/addbtnOnNavBar.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;方法一用到了&lt;code&gt;leftItemsSupplementBackButton&lt;/code&gt; 这个属性，会显示系统默认的返回按钮，但是文字也是显示默认的Back文字，目前还没找到怎么修改这个文字，如果有谁知道，还请不吝赐教；所以我暂时还是建议大家用方法二。相应的还有 &lt;code&gt;rightBarButtonItems&lt;/code&gt; 这个属性，如果要在导航栏右侧展示多个按钮的话，可以设置这个属性。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在导航栏上添加分段控件&lt;/p&gt;

&lt;p&gt;这次，以QQ为例，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UISegmentedControl *segControl = [[UISegmentedControl alloc] initWithItems:@[@&amp;quot;消息&amp;quot;,@&amp;quot;电话&amp;quot;]];
segControl.tintColor = [UIColor colorWithRed:0.07 green:0.72 blue:0.96 alpha:1];
[segControl setSelectedSegmentIndex:0];
self.navigationItem.titleView = segControl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，就是设置 &lt;code&gt;titleView&lt;/code&gt; 这个属性，当然，你也可以把这个属性设置为你自定义的View.&lt;br /&gt;
  &lt;img src=&#34;sources/navigationbar/NavTitleView.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导航栏全局属性设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//全局设置导航栏主题
- (void)setNavigationControllerAppearance {
    [UINavigationBar appearance].barStyle  = UIBarStyleBlack;
    [[UINavigationBar appearance] setBarTintColor:[UIColor colorWithWhite:0.1 alpha:0.5]];
    [[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局设置导航栏的好处有两个：一是不用对每个 &lt;code&gt;NavigationBar&lt;/code&gt; 进行设置；二是方便做主题管理，切换主题，只需要更改全局设置即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;与导航栏相关的一些开源组件&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ninjinkun/NJKWebViewProgress&#34;&gt;NJKWebViewProgress&lt;/a&gt; - 类似于Safiri加载网页时的进度显示&lt;br /&gt;
&lt;img src=&#34;sources/navigationbar/njgWebprogress.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/forkingdog/FDFullscreenPopGesture&#34;&gt;FDFullscreenPopGesture&lt;/a&gt; 一个丝滑的全屏滑动返回手势&lt;br /&gt;
    原文介绍&lt;a href=&#34;http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/&#34;&gt;链接&lt;/a&gt;&lt;br /&gt;
    &lt;img src=&#34;sources/navigationbar/snapshot0.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;h5&gt;&lt;code&gt;UINavigationItem&lt;/code&gt; 和 &lt;code&gt;UINavigationBar&lt;/code&gt; 关系分&lt;/h5&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关系分析 &lt;code&gt;UIBarItem&lt;/code&gt; -&amp;gt; &lt;code&gt;UIBarButtonItem&lt;/code&gt; -&amp;gt; &lt;code&gt;UINavigationItem&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UIBarItem&lt;/code&gt;: 类是一个可以放置在Bar之上的所有小控件类的抽象类。继承了该基类所有子类在外观上类似于一个Button，它们都有一个标题，图片，动作以及目标，这点可以从其子类的初始化方法处看到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;UIBarButtonItem&lt;/code&gt;: 专门用来放在 &lt;code&gt;UIToolbar&lt;/code&gt; 或者 &lt;code&gt;UINavigationBar&lt;/code&gt; 的特殊 &lt;code&gt;button&lt;/code&gt;. 基本行为跟 &lt;code&gt;button&lt;/code&gt; 是一样的。另外从IOS5开始的 &lt;code&gt;Customizing Appearance&lt;/code&gt; 增加了一系列的方法调整显示。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;UINavigationItem: NSObject&lt;/code&gt;: 包含了当前页面导航栏上需要显示的全部信息 &lt;code&gt;title,prompt,titleView,leftBarButtonItem,rightBarButtonItem,backBarButonItem&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;UINavigationBar :UIView&lt;/code&gt; :  NavigaitonBar 就是导航栏，位于屏幕的上方，管理整个NavigationController的navigationItem，即类似navigationcontroller一样提供了一个栈来管理item。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;UINavigtionController :UIViewController&lt;/code&gt;: 包含：viewcontrollers、navigationbar、toolbar&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;navigationbar：UIView&lt;/code&gt;: 包含：items(UINavigationItem)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;viewController&lt;/code&gt;:  包含navigationitem，toolItem.  这两个属性控制了当前页面当前页面的navigationbar，toolbar的外观。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关系综述&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;navigationcontroller&lt;/code&gt; 直接控制 &lt;code&gt;viewcontrollers&lt;/code&gt;，然后包含的 &lt;code&gt;navigationbar&lt;/code&gt; 形成整个nv的导航栏，bar并包含整个&lt;code&gt;navigationItem&lt;/code&gt; 的栈,管理整个nv的  navigationitem（ NSArray *items 属性）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;navigationItem&lt;/code&gt; 包含了bar视图的全部元素（如&lt;code&gt;title,tileview,backBarButtonItem&lt;/code&gt;等），受当前&lt;code&gt;viewcontroller&lt;/code&gt;管理，即bar形成整个nv的导航视图，然后每个nv页面的导航栏元素由所在页面的 &lt;code&gt;navigationItem&lt;/code&gt; 管理。即设置当前页面的左右barbutton，用 &lt;code&gt;self.navigationItem.leftBarButtonItem&lt;/code&gt; 等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/brasbug/UINavigationBar.git&#34;&gt;Code Demo&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>React Native如何做跨平台设计</title>
            <link>http://blog.flywithme.top/2016/04/28/ReactNativeRD/</link>
            <pubDate>Thu, 28 Apr 2016 10:54:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2016/04/28/ReactNativeRD/</guid>
            <description>

&lt;h5 id=&#34;facebook-开源:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;Facebook 开源&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Facebook 在它的F8开发者大会上开源了它的F8大会App，甚至还配上了教程，我组织了一个翻译小队对这个教程进行了翻译。虽然比百万哥晚了几天，但总算还是完成了，欢迎大家Review。项目地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/brasbug/Building-the-F8-2016-App-CN/&#34;&gt;https://github.com/brasbug/Building-the-F8-2016-App-CN/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文出自教程第二篇，介绍React Native在设计跨平台应用时的一些原则和技巧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React Native 的一大优势是：可以只用一种语法编写分别运行在 iOS 和 Android 平台上的程序，且可重用部分应用逻辑。&lt;/p&gt;

&lt;p&gt;然而，与“一次编写，到处运行”的理念不同的是，React Native 的哲学是“一次学习，到处编写”。如此一来，即使用 React Native 编写不同平台的程序，也可以尽可能贴合每个平台的特性。&lt;/p&gt;

&lt;p&gt;从 UI 的角度来看，每个平台都有自己独特的视觉风格、UI 范例甚或是技术层面的功能，那我们设计出一个统一的 UI 基础组件，然后再按照各平台特性进行调整岂不乐乎？&lt;/p&gt;

&lt;h6 id=&#34;准备工作:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;准备工作&lt;/h6&gt;

&lt;p&gt;在后续的所有教程中，我们会仔细解读 App 的源代码，请克隆一份源代码到本地可访问的路径，然后根据配置说明在本地运行 App。在本章的教程中，你只需要阅读相关源代码。源代码地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/brasbug/f8app&#34;&gt;https://github.com/brasbug/f8app&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&#34;react-native-思维模式:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;React Native 思维模式&lt;/h6&gt;

&lt;p&gt;在你写任何 React 代码之前，请认真思考这个至关重要的问题：&lt;strong&gt;如何才能尽可能多地重用代码?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;React Native 的理念是针对每个平台分而治之，代码重用的做法看起来与之相违背，好像我们就应该为每个平台定制其专属的视觉组件一样，但实际上我们仍需努力让每个平台上的代码尽可能多地统一。&lt;/p&gt;

&lt;p&gt;构建一套 React Native 应用视觉组件的关键点在于如何最好地实现平台抽象。开发人员和设计师可以列出应用中需要重用的组件，例如按钮、容器、列表行，头部等等，只有在必要的时候才单独为每个平台设计特定的组件。&lt;/p&gt;

&lt;p&gt;当然，有一些组件相对于其它组件而言更为复杂，我们先一起来看看 F8 应用中不同的组件有什么区别。&lt;/p&gt;

&lt;h6 id=&#34;小组件:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;小组件&lt;/h6&gt;

&lt;p&gt;请看 F8 应用的示例图：
&lt;img src=&#34;sources/reactnative/reactnativeiOSAndroid.png&#34; alt=&#34;react native iOSAndroid.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 iOS 版本中，我们用 iOS 系统中很常见的圆角边框风格来切分 Tab 控制；在 Android 版本中，我们用下划线的风格来标示这个组件。而这两个控制组件的功能其实完全相同。&lt;/p&gt;

&lt;p&gt;所以，即使两者样式稍有不同，但是实现的功能相同，所以我们可以用同一套代码抽象此处的逻辑，从而可以尽可能多地重用代码。&lt;/p&gt;

&lt;p&gt;我们针对像这样的小组件做了很多跨平台重用逻辑代码的案例，比如一个简单的文本按钮，在每个平台上我们都会设计不同的 hover 和 active 状态的样式，但是除开这些视觉上的细微的差异外，逻辑功能完全相同。所以我们总结了一个抽象 React Native 视觉组件的最佳实践方法：设计一套相同的逻辑代码，然后在控制语句中编写其余需要差异化的部分。&lt;/p&gt;

&lt;p&gt;以下是这个组件的示例代码（来自 &lt;F8SegmentedControl&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Segment extends React.Component {
  props: {
    value: string;
    isSelected: boolean;
    selectionColor: string;
    onPress: () =&amp;gt; void;
  };

  render() {
    var selectedButtonStyle;
    if (this.props.isSelected) {
      selectedButtonStyle = { borderColor: this.props.selectionColor };
    }
    var deselectedLabelStyle;
    if (!this.props.isSelected &amp;amp;&amp;amp; Platform.OS === &#39;android&#39;) {
      deselectedLabelStyle = styles.deselectedLabel;
    }
    var title = this.props.value &amp;amp;&amp;amp; this.props.value.toUpperCase();

    var accessibilityTraits = [&#39;button&#39;];
    if (this.props.isSelected) {
      accessibilityTraits.push(&#39;selected&#39;);
    }

    return (
      &amp;lt;TouchableOpacity
        accessibilityTraits={accessibilityTraits}
        activeOpacity={0.8}
        onPress={this.props.onPress}
        style={[styles.button, selectedButtonStyle]}&amp;gt;
        &amp;lt;Text style={[styles.label, deselectedLabelStyle]}&amp;gt;
          {title}
        &amp;lt;/Text&amp;gt;
      &amp;lt;/TouchableOpacity&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，我们为每一种平台分别应用了不同的样式（用到了 React Native 的 &lt;strong&gt;Platform 模块&lt;/strong&gt;）。各平台中的 Tab 按钮都应用了相同的通用样式，同时也根据各平台特性定制了独占样式（同样出自 &lt;F8SegmentedControl&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var styles = StyleSheet.create({
  container: {
    flexDirection: &#39;row&#39;,
    backgroundColor: &#39;transparent&#39;,
    ios: {
      paddingBottom: 6,
      justifyContent: &#39;center&#39;,
      alignItems: &#39;center&#39;,
    },
    android: {
      paddingLeft: 60,
    },
  },
  button: {
    borderColor: &#39;transparent&#39;,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
    backgroundColor: &#39;transparent&#39;,
    ios: {
      height: HEIGHT,
      paddingHorizontal: 20,
      borderRadius: HEIGHT / 2,
      borderWidth: 1,
    },
    android: {
      paddingBottom: 6,
      paddingHorizontal: 10,
      borderBottomWidth: 3,
      marginRight: 10,
    },
  },
  label: {
    letterSpacing: 1,
    fontSize: 12,
    color: &#39;white&#39;,
  },
  deselectedLabel: {
    color: &#39;rgba(255, 255, 255, 0.7)&#39;,
  },
});    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中我们使用了一个改编自 &lt;strong&gt;React Native StyleSheet API&lt;/strong&gt; 的函数 F8StyleSheet，它可以针对各平台分别进行样式转换操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export function create(styles: Object): {[name: string]: number} {
  const platformStyles = {};
  Object.keys(styles).forEach((name) =&amp;gt; {
    let {ios, android, ...style} = {...styles[name]};
    if (ios &amp;amp;&amp;amp; Platform.OS === &#39;ios&#39;) {
      style = {...style, ...ios};
    }
    if (android &amp;amp;&amp;amp; Platform.OS === &#39;android&#39;) {
      style = {...style, ...android};
    }
    platformStyles[name] = style;
  });
  return StyleSheet.create(platformStyles);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个 F8StyleSheet 函数中我们解析了前面示例代码中的 styles 对象，如果我们发现了匹配当前平台的 ios 或 android键值，就会应用相应的样式，如果都没有，则应用默认样式。以此看来，减少代码重复的另一种做法是：尽可能多地重用通用样式代码。&lt;/p&gt;

&lt;p&gt;现在，我们已经可以在我们的App中重用这个组件了，它也可以根据不同的平台自动匹配相应的样式。&lt;/p&gt;

&lt;h6 id=&#34;分离复杂差异:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;分离复杂差异&lt;/h6&gt;

&lt;p&gt;如果一个组件在各平台上的差异不仅仅是样式的不同，也存在大量的逻辑代码差异，那我们就需要换一种方式了。正如下图所示，iOS 和 Android 平台中最高阶的菜单导航组件就有非常大的差异：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/reactnative/reactnativeiOSAndroid02.png&#34; alt=&#34;react native02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正如你所见，在 iOS 版本中我们在屏幕底部放了一个固定的 Tab，而在 Android 版本中，我们却实现了一种可划出的侧边栏。这两种组件其实是本质上的不同，况且一般来说，在 Android 应用中，这种侧边栏通常还会包含更多的菜单选项，例如：退出登录。&lt;/p&gt;

&lt;p&gt;你当然可以将这两种菜单模式写到一个组件中去，但是这个组件会变得异常臃肿，所有的差异不得不通过大量的分支语句来实现，你一定会在不久的将来对这段代码感到陌生难懂。&lt;/p&gt;

&lt;p&gt;其实，我们可以用 React Native 内建的平台特定的扩展来解决这个问题。我们可以创建两个独立的应用，在下面的示例中我们会创建两个组件，分别命名为：&lt;code&gt;F8TabsView.ios.js&lt;/code&gt; 和 &lt;code&gt;F8TabsView.android.js&lt;/code&gt;。React Native 会自动检测当前平台并根据扩展命名加载相应的组件。&lt;/p&gt;

&lt;h6 id=&#34;内建ui组件:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;内建UI组件&lt;/h6&gt;

&lt;p&gt;在每一个 FBTabsView 组件中，我们也可以重用一些内建的 React Native UI 组件，Android 版本使用的是&lt;code&gt;DrawerLayoutAndroid&lt;/code&gt;（很显然，只在 Android 中可用）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render(){
 return(
   &amp;lt;DrawerLayoutAndroid
     ref=&amp;quot;drawer&amp;quot;
     drawerWidth={300}
     drawerPosition={DrawerLayoutAndroid.positions.Left}
     renderNavigationView={this.renderNavigationView}&amp;gt;
     &amp;lt;View style={style.content} key={this.props.activeTab}&amp;gt;
     {this.renderContent()}
     &amp;lt;View&amp;gt;
     &amp;lt;/DrawerLayoutAndroid&amp;gt;
 );
}     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第8行代码中，我们在当前的类中显式地为 drawer 组件指定了 renderNavigationView() 函数。这个函数会返回 drawer 中渲染出来的内容。在这个示例中，我们渲染的是一个包含在自定义 MenuItem 组件(点击查看 &lt;code&gt;MenuItem.js&lt;/code&gt;)中的 &lt;code&gt;View&lt;/code&gt; 组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;renderNavigationView() {
...
 return (
      &amp;lt;View style={styles.drawer}&amp;gt;
        &amp;lt;Image
          style={styles.header}
          source={require(&#39;./img/drawer-header.png&#39;)}&amp;gt;
          {accountItem}
        &amp;lt;/Image&amp;gt;
        &amp;lt;MenuItem
          title=&amp;quot;Schedule&amp;quot;
          selected={this.props.tab === &#39;schedule&#39;}
          onPress={this.onTabSelect.bind(this, &#39;schedule&#39;)}
          icon={scheduleIcon}
          selectedIcon={scheduleIconSelected}
        /&amp;gt;
        {myF8Item}
        &amp;lt;MenuItem
          title=&amp;quot;Maps&amp;quot;
          selected={this.props.tab === &#39;map&#39;}
          onPress={this.onTabSelect.bind(this, &#39;map&#39;)}
          icon={require(&#39;./maps/img/maps-icon.png&#39;)}
          selectedIcon={require(&#39;./maps/img/maps-icon-active.png&#39;)}
        /&amp;gt;
        &amp;lt;MenuItem
          title=&amp;quot;Notifications&amp;quot;
          selected={this.props.tab === &#39;notifications&#39;}
          onPress={this.onTabSelect.bind(this, &#39;notifications&#39;)}
          badge={this.props.notificationsBadge}
          icon={require(&#39;./notifications/img/notifications-icon.png&#39;)}
          selectedIcon={require(&#39;./notifications/img/notifications-icon-active.png&#39;)}
        /&amp;gt;
        &amp;lt;MenuItem
          title=&amp;quot;Info&amp;quot;
          selected={this.props.tab === &#39;info&#39;}
          onPress={this.onTabSelect.bind(this, &#39;info&#39;)}
          icon={require(&#39;./info/img/info-icon.png&#39;)}
          selectedIcon={require(&#39;./info/img/info-icon-active.png&#39;)}
        /&amp;gt;
        {loginItem}
      &amp;lt;/View&amp;gt;
 );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比之下，iOS 版本直接在 render() 函数中使用了一个不同的内建组件，&lt;code&gt;TabBarIOS&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render() {
    var scheduleIcon = this.props.day === 1
      ? require(&#39;./schedule/img/schedule-icon-1.png&#39;)
      : require(&#39;./schedule/img/schedule-icon-2.png&#39;);
    var scheduleIconSelected = this.props.day === 1
      ? require(&#39;./schedule/img/schedule-icon-1-active.png&#39;)
      : require(&#39;./schedule/img/schedule-icon-2-active.png&#39;);
    return (
      &amp;lt;TabBarIOS tintColor={F8Colors.darkText}&amp;gt;
        &amp;lt;TabBarItemIOS
          title=&amp;quot;Schedule&amp;quot;
          selected={this.props.tab === &#39;schedule&#39;}
          onPress={this.onTabSelect.bind(this, &#39;schedule&#39;)}
          icon={scheduleIcon}
          selectedIcon={scheduleIconSelected}&amp;gt;
          &amp;lt;GeneralScheduleView
            navigator={this.props.navigator}
            onDayChange={this.handleDayChange}
          /&amp;gt;
        &amp;lt;/TabBarItemIOS&amp;gt;
        &amp;lt;TabBarItemIOS
          title=&amp;quot;My F8&amp;quot;
          selected={this.props.tab === &#39;my-schedule&#39;}
          onPress={this.onTabSelect.bind(this, &#39;my-schedule&#39;)}
          icon={require(&#39;./schedule/img/my-schedule-icon.png&#39;)}
          selectedIcon={require(&#39;./schedule/img/my-schedule-icon-active.png&#39;)}&amp;gt;
          &amp;lt;MyScheduleView
            navigator={this.props.navigator}
            onJumpToSchedule={() =&amp;gt; this.props.onTabSelect(&#39;schedule&#39;)}
          /&amp;gt;
        &amp;lt;/TabBarItemIOS&amp;gt;
        &amp;lt;TabBarItemIOS
          title=&amp;quot;Maps&amp;quot;
          selected={this.props.tab === &#39;map&#39;}
          onPress={this.onTabSelect.bind(this, &#39;map&#39;)}
          icon={require(&#39;./maps/img/maps-icon.png&#39;)}
          selectedIcon={require(&#39;./maps/img/maps-icon-active.png&#39;)}&amp;gt;
          &amp;lt;F8MapView /&amp;gt;
        &amp;lt;/TabBarItemIOS&amp;gt;
        &amp;lt;TabBarItemIOS
          title=&amp;quot;Notifications&amp;quot;
          selected={this.props.tab === &#39;notifications&#39;}
          onPress={this.onTabSelect.bind(this, &#39;notifications&#39;)}
          badge={this.props.notificationsBadge || null}
          icon={require(&#39;./notifications/img/notifications-icon.png&#39;)}
          selectedIcon={require(&#39;./notifications/img/notifications-icon-active.png&#39;)}&amp;gt;
          &amp;lt;F8NotificationsView navigator={this.props.navigator} /&amp;gt;
        &amp;lt;/TabBarItemIOS&amp;gt;
        &amp;lt;TabBarItemIOS
          title=&amp;quot;Info&amp;quot;
          selected={this.props.tab === &#39;info&#39;}
          onPress={this.onTabSelect.bind(this, &#39;info&#39;)}
          icon={require(&#39;./info/img/info-icon.png&#39;)}
          selectedIcon={require(&#39;./info/img/info-icon-active.png&#39;)}&amp;gt;
          &amp;lt;F8InfoView navigator={this.props.navigator} /&amp;gt;
        &amp;lt;/TabBarItemIOS&amp;gt;
      &amp;lt;/TabBarIOS&amp;gt;
    );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显而易见，尽管 iOS 菜单接受了相同的数据，但是它的结构略有不同。我们并没有用一个独立的函数创建菜单元素，而是将这些元素作为父级菜单的子元素插入进来，正如 &lt;code&gt;TabBarItemIOS&lt;/code&gt; 组件这样。 这里的 &lt;code&gt;TabBarItem&lt;/code&gt; 与 &lt;code&gt;Android&lt;/code&gt; 中 的 &lt;code&gt;MenuItem&lt;/code&gt; 本质上是相同的，唯一的区别是在 &lt;code&gt;Android&lt;/code&gt; 组件中我们会定义一个独立的主&lt;strong&gt;View 组件&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;View 
  style={styles.content} 
  key={this.props.activeTab}&amp;gt;
  {this.renderContent()}
&amp;lt;/View&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后当一个 tab 改变时改变这个组件（通过 &lt;code&gt;renderContent()&lt;/code&gt; 函数），而 iOS 组件则会有多个分离的 View 组件，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;GeneralScheduleView
  navigator={this.props.navigator}
  onDayChange={this.handleDayChange}
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是 TabBarItem 的一部分，可以点击使它们可见。&lt;/p&gt;

&lt;h6 id=&#34;设计迭代周期:b9c82b73251bbe881a94ee3406d810b1&#34;&gt;设计迭代周期&lt;/h6&gt;

&lt;p&gt;当你构建任何应用，无论是在移动平台还是 web 环境下，调整适配的 UI 元素是非常痛苦的。如果工程师和设计师共同协作，会使整个过程慢下来。&lt;/p&gt;

&lt;p&gt;React Native 包含了一个&lt;strong&gt;实时重载&lt;/strong&gt;的 debug 功能，可以当 JavaScript 改变时触发刷新应用。这可以在极大程度上减少设计迭代过程，一旦改变了组件样式并保存后，你会立即看到更新的样式。&lt;/p&gt;

&lt;p&gt;但是如果组件在不同条件下看起来不同怎么办呢？举个例子，一个按钮组件可能有一个默认样式，也分别包含按下、执行任务中、执行任务完成时的样式。&lt;/p&gt;

&lt;p&gt;为了避免每次都与应用交互，我们内建了一个用于 debug 视觉效果的 Playgroud 组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Playground extends React.Component {
  constructor() {
    super();
    const content = [];
    const define = (name: string, render: Function) =&amp;gt; {
      content.push(&amp;lt;Example key={name} render={render} /&amp;gt;);
    };
    // var Module = require(&#39;F8PageControl&#39;);
    var Module = require(&#39;F8Header&#39;);
    // var Module = require(&#39;./tabs/schedule/AddToScheduleButton&#39;);
    // var Module = require(&#39;./rating/Header&#39;);
    Module.__cards__(define);
    this.state = {content};
  }

  render() {
    return (
      &amp;lt;View style={{backgroundColor: &#39;#336699&#39;, flex: 1,}}&amp;gt;
        {this.state.content}
      &amp;lt;/View&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实我们只是创建了一个可交换加载的空视图，将其与一些示例定义整合到其中一个 UI 组件中，正如下面这段&lt;code&gt;AddToScheduleButton.js&lt;/code&gt; 所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = AddToScheduleButton;
module.exports.__cards__ = (define) =&amp;gt; {
  let f;
  setInterval(() =&amp;gt; f &amp;amp;&amp;amp; f(), 1000);

  define(&#39;Inactive&#39;, (state = true, update) =&amp;gt;
    &amp;lt;AddToScheduleButton isAdded={state} onPress={() =&amp;gt; update(!state)} /&amp;gt;);

  define(&#39;Active&#39;, (state = false, update) =&amp;gt;
    &amp;lt;AddToScheduleButton isAdded={state} onPress={() =&amp;gt; update(!state)} /&amp;gt;);

  define(&#39;Animated&#39;, (state = false, update) =&amp;gt; {
    f = () =&amp;gt; update(!state);
    return &amp;lt;AddToScheduleButton isAdded={state} /&amp;gt;;
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以将这个应用转化为一个 UI 预览工具：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/reactnative/reactnativeiOSAndroid3.gif&#34; alt=&#34;react native03&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这个示例中为这个按钮定义了按下和抬起两种状态，第三个按钮在这两者的状态之间不断循环，以此来预览过渡的动画效果。&lt;/p&gt;

&lt;p&gt;现在，我们可以跟设计师一起快速调整基础组件的视觉样式了。&lt;/p&gt;

&lt;p&gt;如果想用这个功能，&lt;code&gt;&amp;lt;Playground&amp;gt;&lt;/code&gt;组件必须在任何 React Native 应用中都可用，我们需要在 setup() 函数中交换一些代码来加载 &lt;Playground&gt; 组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* from js/setup.js */
render() {  
  ...
  return (
    &amp;lt;Provider store={this.state.store}&amp;gt;
      &amp;lt;F8App /&amp;gt;
    &amp;lt;/Provider&amp;gt;
  );
}

变为

/* in js/setup.js */
render() {
  ...
  return (
    &amp;lt;Provider store={this.state.store}&amp;gt;
      &amp;lt;Playground /&amp;gt;
    &amp;lt;/Provider&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以修改 &lt;Playground&gt; 组件，使其能够改变引入的其它组件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;amp;mid=2651112134&amp;amp;idx=1&amp;amp;sn=c26ceb682e361ae33bc1eb5348e5e7bb&amp;amp;scene=1&amp;amp;srcid=0427SeJXKKZSAvVR2M52qOsw&amp;amp;key=b28b03434249256ba8ea0cb4d56d79d314519c90f31a529f8d632996958f4eaca1cbdad191c223497b256c6ceea8391c&amp;amp;ascene=0&amp;amp;uin=MTg5NzM2MjkyMA%3D%3D&amp;amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.11.4+build(15E65&#34;&gt;转载 From&lt;/a&gt;&amp;amp;version=11020201&amp;amp;pass_ticket=Nu5nSZlfui6B7G7DcB%2F6TCakJdlOAf3o9ND1eoSVkm2wZBUGQjsZFgKkrsou%2Bk4%2B)&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
