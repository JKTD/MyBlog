<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.54.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Vue上线后，history页面点击刷新按钮报错404问题 &middot; Fly With Bug</title>

  
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.topcss/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.topcss/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.topcss/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.topcss/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://blog.flywithme.top/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="http://blog.flywithme.top/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Fly With Bug" />

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.flywithme.top"><h1>Fly With Bug</h1></a>
      <p class="lead">
       漫步走在沙滩上 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.flywithme.top">Home</a> </li>
        <li><a href="http://blog.flywithme.top/post/"> 归档 </a></li><li><a href="http://blog.flywithme.top/about/"> 关于我 </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Vue上线后，history页面点击刷新按钮报错404问题</h1>
  <time datetime=2018-12-24T07:14:17&#43;0800 class="post-date">Mon, Dec 24, 2018</time>
  <pre><code class="language-vue-router```">如果不想要很丑的 hash，可以用路由的 **history 模式** ，这种模式充分利用 ```history.pushState``` API 来完成 URL 跳转而无须重新加载页面。

</code></pre>

<p>const router = new VueRouter({
  mode: &lsquo;history&rsquo;,
  routes: [&hellip;]
})</p>

<pre><code>
当你使用 ```history``` 模式时，URL 就像正常的 url，例如 ```http://yoursite.com/user/id```，也好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 ```http://oursite.com/user/id``` 就会返回 404，这就不好看了。
所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 ```index.html``` 页面，这个页面就是你 app 依赖的页面。

#### **go gin框架配置示例**
由于我使用go的gin框架做服务器，示例代码如下
[源码地址](https://github.com/flywithbug-docmanager/docmanager) 
</code></pre>

<p>func NoRoute(c *gin.Context) {
    path := strings.Split(c.Request.URL.Path, &ldquo;/&rdquo;)
    if (path[1] != &ldquo;&rdquo;) &amp;&amp; (path[1] == &ldquo;api&rdquo;) {
        aRes := model.NewResponse()
        aRes.Code = http.StatusNotFound
        aRes.Msg = &ldquo;no route&rdquo;
        c.JSON(http.StatusNotFound, aRes)
    } else {
        c.HTML(http.StatusOK, &ldquo;index.html&rdquo;, &ldquo;&rdquo;)
    }
}</p>

<p>r := gin.New()
r.Use(middleware.Logger(), gin.Recovery())
r.Use(static.Serve(&ldquo;/&rdquo;, static.LocalFile(staticPath, true)))
r.LoadHTMLGlob(staticPath + &ldquo;/index.html&rdquo;)
r.NoRoute(handler.NoRoute)</p>

<pre><code>
----------------------------------------------------

### [官网配置例](https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90) 

##### Apache
</code></pre>

<p><IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule></p>

<pre><code>
除了 ```mod_rewrite```，你也可以使用 ```FallbackResource```。

##### nginx
</code></pre>

<p>location / {
  try_files $uri $uri/ /index.html;
}</p>

<p>一、
location /{
    root   /data/nginx/html;
    index  index.html index.htm;
    error_page 404 /index.html;
}</p>

<p>二、
location /{
    root   /data/nginx/html;
    index  index.html index.htm;
    if (!-e $request_filename) {
        rewrite ^/(.*) /index.html last;
        break;
    }
}</p>

<p>三、
server {
    listen       8888;#默认端口是80，如果端口没被占用可以不用修改
    server_name  localhost;
    root        E:/vue/my_project/dist;#vue项目的打包后的dist
    location / {
        try_files $uri $uri/ @router;#需要指向下面的@router否则会出现vue的路由在nginx中刷新出现404
        index  index.html index.htm;
    }
    #对应上面的@router，主要原因是路由的路径资源并不是一个真实的路径，所以无法找到具体的文件
    #因此需要rewrite到index.html中，然后交给路由在处理请求资源
    location @router {
        rewrite ^.*$ /index.html last;
    }
    #&hellip;&hellip;.其他部分省略
}</p>

<pre><code>
##### 原生 Node.js
</code></pre>

<p>const http = require(&lsquo;http&rsquo;)
const fs = require(&lsquo;fs&rsquo;)
const httpPort = 80</p>

<p>http.createServer((req, res) =&gt; {
  fs.readFile(&lsquo;index.htm&rsquo;, &lsquo;utf-8&rsquo;, (err, content) =&gt; {
    if (err) {
      console.log(&lsquo;We cannot open &ldquo;index.htm&rdquo; file.&rsquo;)
    }</p>

<pre><code>res.writeHead(200, {
  'Content-Type': 'text/html; charset=utf-8'
})

res.end(content)
</code></pre>

<p>})
}).listen(httpPort, () =&gt; {
  console.log(&lsquo;Server listening on: <a href="http://localhost:%s'">http://localhost:%s'</a>, httpPort)
})</p>

<pre><code>
##### 基于 Node.js 的 Express
对于 Node.js/Express，请考虑使用 [connect-history-api-fallback](https://github.com/bripkens/connect-history-api-fallback) 中间件。

##### Internet Information Services (IIS)
安装 IIS UrlRewrite
在你的网站根目录中创建一个 ``` web.config```  文件，内容如下：
</code></pre>

<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;
<configuration>
  <system.webServer>
    <rewrite>
      <rules>
        <rule name="Handle History Mode and custom 404/500" stopProcessing="true">
          <match url="(.*)" />
          <conditions logicalGrouping="MatchAll">
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
          </conditions>
          <action type="Rewrite" url="/" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>
</configuration></p>

<pre><code>
##### Caddy
</code></pre>

<p>rewrite {
    regexp .*
    to {path} /
}</p>

<pre><code>
##### Firebase 主机
在你的 ``` firebase.json```  中加入：
</code></pre>

<p>{
  &ldquo;hosting&rdquo;: {
    &ldquo;public&rdquo;: &ldquo;dist&rdquo;,
    &ldquo;rewrites&rdquo;: [
      {
        &ldquo;source&rdquo;: &ldquo;**&ldquo;,
        &ldquo;destination&rdquo;: &ldquo;/index.html&rdquo;
      }
    ]
  }
}</p>

<pre><code>
##### 警告
给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。
</code></pre>

<p>const router = new VueRouter({
  mode: &lsquo;history&rsquo;,
  routes: [
    { path: &lsquo;*&lsquo;, component: NotFoundComponent }
  ]
})
```</p>

<p>或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 <a href="https://ssr.vuejs.org/zh/">Vue 服务端渲染文档</a>。</p>

</div>


    </main>

    
  </body>
</html>
