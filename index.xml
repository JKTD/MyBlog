<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Fri, 08 Mar 2019 19:25:15 CST</updated>
        
        <item>
            <title>Longest Palindromic Substring 最长回文子串</title>
            <link>http://blog.flywithme.top/2019/03-08/Palindromic/</link>
            <pubDate>Fri, 08 Mar 2019 19:25:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/Palindromic/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;babad&amp;quot;
输出: &amp;quot;bab&amp;quot;
注意: &amp;quot;aba&amp;quot; 也是一个有效答案。

输入: &amp;quot;cbbd&amp;quot;
输出: &amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/longest-palindromic-substring/&#34;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>寻找两个有序数组的中位数</title>
            <link>http://blog.flywithme.top/2019/03-08/findmedian/</link>
            <pubDate>Fri, 08 Mar 2019 16:12:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/findmedian/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br /&gt;
   请你找出这两个有序数组的中位数。&lt;br /&gt;
   要求算法的&lt;font color=red size=5&gt;时间复杂度为 O(log(m + n))&lt;/font&gt;&lt;br /&gt;
   你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Input:nums1 = [1, 3]
      nums2 = [2]
Output: 2.0

Input: nums1 = [1, 2]
       nums2 = [3, 4]
Output:  (2 + 3)/2 = 2.5


Input: nums1 = [1,2,3,7,8,9,10]
       nums2 = [-2,-1,4,5,7,9]
Output:  5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;分割两个数组，分为leftA,rightA, leftB,rightB,
 leftA+leftB的长度等于rightA+rightB
 左边数组的最大值等于右边数组的最小值时，就找到了中间值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m := len(nums1)
    n := len(nums2)
    if m == 0 {
        return medianof(nums2)
    }
    if n == 0 {
        return medianof(nums1)
    }
    if m &amp;gt; n { //确保nums1数组长度比nums2边短
        findMedianSortedArrays(nums2,nums1)
    }
    halflen := (m + n +1)/2
    iMin := 0 //nums1的起始分割点 iMin &amp;lt; m的总长
    iMax := m

    //使用二分法查找分割点
    for iMin &amp;lt;= iMax {
        i := (iMin + iMax)/2
        j := halflen - i
        if i &amp;lt; iMax &amp;amp;&amp;amp; nums2[j - 1] &amp;gt; nums1[i] {
            //取值位置偏小，需要右移最小位置
            iMin =  i + 1
        }else if i &amp;gt; iMin &amp;amp;&amp;amp;  nums1[i -1] &amp;gt; nums2[j] {
            iMax = i -1   //i的位置太大
        }else {
            maxLeft := 0
            if i == 0 {
                maxLeft = nums2[j - 1]
            }else if j == 0 {
                maxLeft = nums1[i -1]
            }else {
                maxLeft = maxInt(nums1[i-1],nums2[j-1])
            }
            if (m + n)%2 ==1 {
                return float64(maxLeft)
            }

            minRight := 0
            if i == m {
                minRight = nums2[j]
            }else if j == n {
                minRight = nums1[i]
            }else {
                minRight = minInt(nums1[i],nums2[j])
            }
            return float64(maxLeft +minRight)/2.0
        }
    }
    return 0.0
}

func medianof(nums []int)float64  {
    l := len(nums)
    if l == 0 {
        return 0
    }
    if l%2 == 0 {
        return float64(nums[l/2-1]+nums[l/2])/2.0
    }
    return float64(nums[l/2])
}

func minInt(a,b int)int  {
    if a &amp;gt; b {
        return b
    }
    return a
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/median-of-two-sorted-arrays/&#34;&gt; Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Add Strings 字符串相加</title>
            <link>http://blog.flywithme.top/2019/03-07/addtwostring/</link>
            <pubDate>Thu, 07 Mar 2019 21:21:38 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/addtwostring/</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#note&#34;&gt;Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#注意&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution&#34;&gt;Solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution-02&#34;&gt;Solution 02&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;h6 id=&#34;description&#34;&gt;Description&lt;/h6&gt;

&lt;p&gt;Given two non-negative integers num1 and num2 represented as string,
   return the sum of num1 and num2.&lt;br /&gt;
   给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。&lt;/p&gt;

&lt;h6 id=&#34;note&#34;&gt;Note&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;The length of both num1 and num2 is &amp;lt; 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Both num1 and num2 contains only digits 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;both num1 and num2 does not contain any leading zero.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;注意&#34;&gt;注意&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;num1 和num2 的长度都小于 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都只包含数字 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都不包含任何前导零。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;example&#34;&gt;Example&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: 579
Explanation: &amp;quot;123 + &amp;quot;456&amp;quot; = &amp;quot;579&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution&#34;&gt;Solution&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;//直接处理字符串相加
func addTwoString1(num1 string,num2 string)string  {
    carry := 0
    maxLen := maxInt(len(num2),len(num1))
    result := make([]byte,maxLen+1)
    for i := 0 ; i &amp;lt; maxLen; i ++ {
        sum := carry
        if len(num1) &amp;gt; i {
            v1 ,_ := strconv.Atoi(string(num1[len(num1) -i -1]))
            sum += v1
        }
        if len(num2) &amp;gt; i {
            v2 ,_ := strconv.Atoi(string(num2[len(num2) -i -1]))
            sum += v2
        }
        carry = sum/10
        result[maxLen - i] = []byte(strconv.Itoa(sum%10))[0]
    }
    if carry &amp;gt; 0 {
        result[0] = []byte(strconv.Itoa(carry))[0]
    }else {
        return string(result[1:])
    }
    return  string(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution-02&#34;&gt;Solution 02&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val  int
    Next *ListNode
}


//两字符串相加
func addTwoString(num1 string,num2 string)string  {
    l1 := makeListNode(num1)
    l2 := makeListNode(num2)
    l3 := addTwoNumbers(l1,l2)
    return  listNodeToString(l3)
}

//字符串转换为数字链表
func makeListNode(s string)*ListNode  {
    node := new(ListNode)
    current := node
    for i := len(s) - 1; i &amp;gt;=0; i -- {
        current.Next = new(ListNode)
        current.Val ,_ = strconv.Atoi(string(s[i]))
        current = current.Next
    }
    return node
}

//数字链表转为字符串
func listNodeToString(l *ListNode)string  {
    result := &amp;quot;&amp;quot;
    for l != nil {
        if l.Next != nil || l.Val != 0 {
            result  = fmt.Sprintf(&amp;quot;%d%s&amp;quot;,l.Val,result)
        }
        l = l.Next
    }
    return result
}

 //计算结果   
func addTwoNumbers(l1 *ListNode,l2 *ListNode) *ListNode  {
    head := &amp;amp;ListNode{0,nil}
    current := head
    carry := 0
    for l1 != nil || l2 != nil || carry &amp;gt; 0 {
        sum := carry
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        carry = sum /10
        current.Next = new(ListNode)
        current.Next.Val = sum%10
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>字符串相乘</title>
            <link>http://blog.flywithme.top/2019/03-07/multiplystrings/</link>
            <pubDate>Thu, 07 Mar 2019 19:29:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/multiplystrings/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given two non-negative integers num1 and num2 represented as strings,
return the product of num1 and num2, also represented as a string..
  Note:
  The length of both num1 and num2 is &amp;lt; 110.
  Both num1 and num2 contain only digits 0-9.
  Both num1 and num2 do not contain any leading zero, except the number 0 itself.
  You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;p&gt;说明：
  num1 和 num2 的长度小于110。
  num1 和 num2 只包含数字 0-9。
  num1 和 num2 均不以零开头，除非是数字 0 本身。
  不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot;
Output: &amp;quot;6&amp;quot;

Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: &amp;quot;56088&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>最长无重复字符的子串</title>
            <link>http://blog.flywithme.top/2019/03-07/Longest-Substring-Without-Repeating-Characters-/</link>
            <pubDate>Thu, 07 Mar 2019 18:32:33 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/Longest-Substring-Without-Repeating-Characters-/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;给一个字符串，找出最长的非重复字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: &amp;quot;abcabcbb&amp;quot;
Output: 3 
Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. 

Input: &amp;quot;bbbbb&amp;quot;
Output: 1
Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.

Input: &amp;quot;pwwkew&amp;quot;
Output: 3
Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. 
             Note that the answer must be a substring, 
             &amp;quot;pwke&amp;quot; is a subsequence and not a substring.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func lengthOfLongestSubstring(s string) int {
    location := [256]int{} 
    for i := range location {
        location[i] = -1 
    }
    maxLen, left := 0, -1
    for i := 0; i &amp;lt; len(s); i++ {
        if location[s[i]] &amp;gt;= left {
            left = location[s[i]] +1
        } else if i + 1-left &amp;gt; maxLen {
            maxLen = i + 1 - left
        }
        location[s[i]] = i
    }

    return maxLen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;func lengthOfLongestSubstring(s string) int {
    max ,left := 0,-1
    c := [256]int{}
    for i := range c{
        c[i]= -1
    }
    for i := 0; i &amp;lt; len(s); i ++ {
        left = maxInt(left, c[s[i]])
        c[s[i]] = i
        max = maxInt(max,i-left)
    }
    return max
}

func maxInt(a, b int) int {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: &amp;quot;汉字要怎么处理是怎么样的&amp;quot;
Output: 8 
Explanation: The answer is &amp;quot;汉字要怎么处理是&amp;quot;, with the length of 8. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;  &lt;font size=3&gt;查询包含汉字的字符串需要使用golang的 &lt;code&gt;rune&lt;/code&gt; 关键字&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//带有汉字的最长不重复字符
func lengthOfLongestRunSubString(s string)int  {
    maxLen,left := 0,-1
    lastOccurred := make(map[rune]int)
    for i, ch := range []rune(s) {
        if lastI,ok := lastOccurred[ch];ok &amp;amp;&amp;amp; lastI &amp;gt;= left {
            left = lastOccurred[ch]
        }
        if i - left &amp;gt; maxLen {
            maxLen = i - left
        }
        lastOccurred[ch] = i
    }
    return maxLen
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Add Two Numbers 两个数字相加</title>
            <link>http://blog.flywithme.top/2019/03-07/addtwonum/</link>
            <pubDate>Thu, 07 Mar 2019 18:24:19 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/addtwonum/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single digit.
Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero,
except the number 0 itself.&lt;/p&gt;

&lt;p&gt;给两个非空链表，表示两个非负的整数，数字是以相反的顺序存储，每个节点包含一个数字。
求两个数字的和，并以链表的形式返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
Explanation: 342 + 465 = 807.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    head := &amp;amp;ListNode{0,nil}
    current := head
    carry := 0
    for l1 != nil || l2 != nil || carry &amp;gt; 0 {
        sum := carry
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        carry = sum/10
        current.Next = new(ListNode)
        current.Next.Val = sum%10
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Two Sum 两数之和</title>
            <link>http://blog.flywithme.top/2019/03-07/leetcode_twosum/</link>
            <pubDate>Thu, 07 Mar 2019 18:12:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/leetcode_twosum/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;给一个整数数组，和一个目标值，查询数组中两个数之和为目标值的数据位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //使用空间换时间，查询之后放入map中，可以减少时间复杂度
func TwoSumMap1(nums []int,target int)[]int   {
    maps := map[int]int{}
    for i ,value := range  nums {
        member := target - value
        if j,ok := maps[member];ok  {
            return []int{j,i}
        }
        maps[value] = i
    }
    return nil
}

//双重遍历数组，拿数组中元素进行运算
 //耗时较多
 func twoSum(nums []int, target int) []int {
    for i := 0; i &amp;lt; len(nums);i ++ {
        for j := i +1; j &amp;lt; len(nums); j ++{
            if nums[i] + nums[j] == target {
                return []int{i,j}
            }
        }
    }
    return nil
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>go bin执行问题记录</title>
            <link>http://blog.flywithme.top/2019/02/24/gobin/</link>
            <pubDate>Sun, 24 Feb 2019 08:40:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/02/24/gobin/</guid>
            <description>&lt;p&gt;因为&lt;code&gt;${GOPATH}/bin&lt;/code&gt;目录下的执行文件无法被中断直接执行 需要Source之后才能使用，
只是在 &lt;code&gt;.bash_profile&lt;/code&gt;文件里如此设置 需要Source之后才能被命令行识别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOBIN=/Users/ori/go/bin
export PATH=$PATH:$GOBIN

export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
export  PATH=~/code/flutter/flutter/bin:$PATH

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最好的处理方式还是直接把&lt;code&gt;${GOPATH}/bin&lt;/code&gt;目录下的执行文件移动到go的Root的bin目录中更好&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mv $GOPATH/bin/** /usr/local/go/bin&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Nginx 配置 HTTPS 服务器</title>
            <link>http://blog.flywithme.top/2019/01/15/nginx/</link>
            <pubDate>Tue, 15 Jan 2019 14:38:32 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/01/15/nginx/</guid>
            <description>

&lt;p&gt;Nginx 配置 HTTPS 并不复杂，主要有两个步骤：签署第三方可信任的 SSL 证书 和 配置 HTTPS&lt;/p&gt;

&lt;p&gt;我的证书是在腾讯云上申请的&lt;a href=&#34;https://console.cloud.tencent.com/ssl&#34;&gt;地址&lt;/a&gt;
 &lt;img src=&#34;http://blog.flywithme.top/sources/nginx/FF1BD64F-62AD-4FDB-AE5A-B51C5FBB125C.png&#34; alt=&#34;cer&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;nginx-conf-配置内容&#34;&gt;nginx.conf 配置内容&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;
	
   upstream move{
        server 127.0.0.1:9120;
   }


   server {
        listen       80;
        listen       443 ssl;
	ssl_certificate   certificate_bundle.crt;
	ssl_certificate_key  certificate.key;

	client_max_body_size 20M;
    client_body_buffer_size 1M;
    #charset koi8-r;

    #access_log  logs/host.access.log  main;
        

	location /(css|js|fonts|img)/ {
        	access_log off;
        	expires 1d;
       	 	root &amp;quot;/root/vue-admin/dist&amp;quot;;
        	try_files $uri @backend;
	}

	location / {
        	try_files /_not_exists_ @backend;
	}

	location @backend {
        	proxy_set_header X-Forwarded-For $remote_addr;
       	 	proxy_set_header Host            $http_host;
        	proxy_pass http://127.0.0.1:9801;
    	}	

	location /im/ {
    		client_max_body_size 20M;
   		proxy_pass http://127.0.0.1:9002;
	}

  }
 

    include /etc/nginx/conf.d/*.conf;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>mongodb 维护小记</title>
            <link>http://blog.flywithme.top/2019/01/13/mongodump/</link>
            <pubDate>Sun, 13 Jan 2019 10:45:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/01/13/mongodump/</guid>
            <description>

&lt;h3 id=&#34;数据库迁移&#34;&gt;数据库迁移&lt;/h3&gt;

&lt;p&gt;把当前服务器备份下来的数据迁移到另一个host服务器上，目录Path是当前备份的根目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodump -u user -p pass -d doc_manager -o doc.dmp
mongorestore -h host ./doc.dmp/doc_manager -u auth -p pass -d docmanager
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;本地处理&#34;&gt;本地处理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//              dump命令             数据库用户 密码     数据库名字      备份目录
/usr/local/mongodb/bin/mongodump -u user -p pass -d docmanager  -o ../dump

//              restore命令             数据库用户名 密码   数据库名字   备份目录      覆盖
/usr/local/mongodb/bin/mongorestore -u 用户名 -p 密码 -d docmanager doc_manager --drop

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;创建数据库管理员&#34;&gt;创建数据库管理员&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//进入mongo命令行
mongo
db.auth(&amp;quot;use&amp;quot;,&amp;quot;pass&amp;quot;)

use log
db.createUser(
		{
			user: &amp;quot;user&amp;quot;,
			pwd: &amp;quot;pass&amp;quot;,
			roles: [{ role: &amp;quot;readWrite&amp;quot;, db: &amp;quot;log&amp;quot; }]
		}
	)



&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;错误处理&#34;&gt;错误处理&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//   mongodb非正常关闭后
about to fork child process, waiting until server is ready for connections.
forked process: 9936
ERROR: child process failed, exited with error number 48

//处理方式
//删除mongo数据库文件夹中的 
killall mongod
rm /data/mongo/mongod.lock

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Vue上线后，history页面点击刷新按钮报错404问题</title>
            <link>http://blog.flywithme.top/2018/12/24/vue_webserver/</link>
            <pubDate>Mon, 24 Dec 2018 07:14:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/24/vue_webserver/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-vue-router```&#34;&gt;如果不想要很丑的 hash，可以用路由的 **history 模式** ，这种模式充分利用 ```history.pushState``` API 来完成 URL 跳转而无须重新加载页面。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const router = new VueRouter({
  mode: &amp;lsquo;history&amp;rsquo;,
  routes: [&amp;hellip;]
})&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
当你使用 ```history``` 模式时，URL 就像正常的 url，例如 ```http://yoursite.com/user/id```，也好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 ```http://oursite.com/user/id``` 就会返回 404，这就不好看了。
所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 ```index.html``` 页面，这个页面就是你 app 依赖的页面。

#### **go gin框架配置示例**
由于我使用go的gin框架做服务器，示例代码如下
[源码地址](https://github.com/flywithbug-docmanager/docmanager) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func NoRoute(c *gin.Context) {
    path := strings.Split(c.Request.URL.Path, &amp;ldquo;/&amp;rdquo;)
    if (path[1] != &amp;ldquo;&amp;rdquo;) &amp;amp;&amp;amp; (path[1] == &amp;ldquo;api&amp;rdquo;) {
        aRes := model.NewResponse()
        aRes.Code = http.StatusNotFound
        aRes.Msg = &amp;ldquo;no route&amp;rdquo;
        c.JSON(http.StatusNotFound, aRes)
    } else {
        c.HTML(http.StatusOK, &amp;ldquo;index.html&amp;rdquo;, &amp;ldquo;&amp;rdquo;)
    }
}&lt;/p&gt;

&lt;p&gt;r := gin.New()
r.Use(middleware.Logger(), gin.Recovery())
r.Use(static.Serve(&amp;ldquo;/&amp;rdquo;, static.LocalFile(staticPath, true)))
r.LoadHTMLGlob(staticPath + &amp;ldquo;/index.html&amp;rdquo;)
r.NoRoute(handler.NoRoute)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
----------------------------------------------------

### [官网配置例](https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90) 

##### Apache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
&lt;/IfModule&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
除了 ```mod_rewrite```，你也可以使用 ```FallbackResource```。

##### nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;location / {
  try_files $uri $uri/ /index.html;
}&lt;/p&gt;

&lt;p&gt;一、
location /{
    root   /data/nginx/html;
    index  index.html index.htm;
    error_page 404 /index.html;
}&lt;/p&gt;

&lt;p&gt;二、
location /{
    root   /data/nginx/html;
    index  index.html index.htm;
    if (!-e $request_filename) {
        rewrite ^/(.*) /index.html last;
        break;
    }
}&lt;/p&gt;

&lt;p&gt;三、
server {
    listen       8888;#默认端口是80，如果端口没被占用可以不用修改
    server_name  localhost;
    root        E:/vue/my_project/dist;#vue项目的打包后的dist
    location / {
        try_files $uri $uri/ @router;#需要指向下面的@router否则会出现vue的路由在nginx中刷新出现404
        index  index.html index.htm;
    }
    #对应上面的@router，主要原因是路由的路径资源并不是一个真实的路径，所以无法找到具体的文件
    #因此需要rewrite到index.html中，然后交给路由在处理请求资源
    location @router {
        rewrite ^.*$ /index.html last;
    }
    #&amp;hellip;&amp;hellip;.其他部分省略
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### 原生 Node.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const http = require(&amp;lsquo;http&amp;rsquo;)
const fs = require(&amp;lsquo;fs&amp;rsquo;)
const httpPort = 80&lt;/p&gt;

&lt;p&gt;http.createServer((req, res) =&amp;gt; {
  fs.readFile(&amp;lsquo;index.htm&amp;rsquo;, &amp;lsquo;utf-8&amp;rsquo;, (err, content) =&amp;gt; {
    if (err) {
      console.log(&amp;lsquo;We cannot open &amp;ldquo;index.htm&amp;rdquo; file.&amp;rsquo;)
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.writeHead(200, {
  &#39;Content-Type&#39;: &#39;text/html; charset=utf-8&#39;
})

res.end(content)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;})
}).listen(httpPort, () =&amp;gt; {
  console.log(&amp;lsquo;Server listening on: &lt;a href=&#34;http://localhost:%s&#39;&#34;&gt;http://localhost:%s&#39;&lt;/a&gt;, httpPort)
})&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### 基于 Node.js 的 Express
对于 Node.js/Express，请考虑使用 [connect-history-api-fallback](https://github.com/bripkens/connect-history-api-fallback) 中间件。

##### Internet Information Services (IIS)
安装 IIS UrlRewrite
在你的网站根目录中创建一个 ``` web.config```  文件，内容如下：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&lt;configuration&gt;
  &lt;system.webServer&gt;
    &lt;rewrite&gt;
      &lt;rules&gt;
        &lt;rule name=&#34;Handle History Mode and custom 404/500&#34; stopProcessing=&#34;true&#34;&gt;
          &lt;match url=&#34;(.*)&#34; /&gt;
          &lt;conditions logicalGrouping=&#34;MatchAll&#34;&gt;
            &lt;add input=&#34;{REQUEST_FILENAME}&#34; matchType=&#34;IsFile&#34; negate=&#34;true&#34; /&gt;
            &lt;add input=&#34;{REQUEST_FILENAME}&#34; matchType=&#34;IsDirectory&#34; negate=&#34;true&#34; /&gt;
          &lt;/conditions&gt;
          &lt;action type=&#34;Rewrite&#34; url=&#34;/&#34; /&gt;
        &lt;/rule&gt;
      &lt;/rules&gt;
    &lt;/rewrite&gt;
  &lt;/system.webServer&gt;
&lt;/configuration&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### Caddy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rewrite {
    regexp .*
    to {path} /
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### Firebase 主机
在你的 ``` firebase.json```  中加入：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{
  &amp;ldquo;hosting&amp;rdquo;: {
    &amp;ldquo;public&amp;rdquo;: &amp;ldquo;dist&amp;rdquo;,
    &amp;ldquo;rewrites&amp;rdquo;: [
      {
        &amp;ldquo;source&amp;rdquo;: &amp;ldquo;**&amp;ldquo;,
        &amp;ldquo;destination&amp;rdquo;: &amp;ldquo;/index.html&amp;rdquo;
      }
    ]
  }
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### 警告
给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const router = new VueRouter({
  mode: &amp;lsquo;history&amp;rsquo;,
  routes: [
    { path: &amp;lsquo;*&amp;lsquo;, component: NotFoundComponent }
  ]
})
```&lt;/p&gt;

&lt;p&gt;或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 &lt;a href=&#34;https://ssr.vuejs.org/zh/&#34;&gt;Vue 服务端渲染文档&lt;/a&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>vue 路由重载之后导致history页面刷新空白问题fix</title>
            <link>http://blog.flywithme.top/2018/12/24/vue-element02/</link>
            <pubDate>Sun, 23 Dec 2018 06:57:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/24/vue-element02/</guid>
            <description>&lt;p&gt;在vue项目的实际操作中，路由表配置需要根据用户角色进行动态过滤，
在每次刷新页面之后 更新用户权限表，然后根据权限表刷新动态配置
但是在刷新完路由表之后 再刷新页面发现页面一片空白。&lt;/p&gt;

&lt;p&gt;hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;next({ ...to, replace: true })  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//路由权限配置源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import router from &#39;@/router&#39;
import store from &#39;@/store&#39;
import { Message } from &#39;element-ui&#39;
import NProgress from &#39;nprogress&#39; // progress bar
import &#39;nprogress/nprogress.css&#39;// progress bar style
import { getToken } from &#39;./utils/auth&#39; // getToken from cookie

NProgress.configure({ showSpinner: false })// NProgress Configuration

// permission judge function
function hasPermission(roles, permissionRoles) {
  if (roles.indexOf(&#39;admin&#39;) &amp;gt;= 0) return true // admin permission passed directly
  if (!permissionRoles) return true
  return roles.some(role =&amp;gt; permissionRoles.indexOf(role) &amp;gt;= 0)
}


const whiteList = [&#39;/login&#39;,&#39;/auth-redirect&#39;]

router.beforeEach((to, from ,next) =&amp;gt; {
  NProgress.start()
  if (getToken()){  //判断是否登录
    if (to.path === &#39;/login&#39;){
      next({path:&#39;/&#39;})
      NProgress.done()
    }else {
      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch(&#39;GetUserInfo&#39;).then(user =&amp;gt; {
          store.dispatch(&#39;GenerateRoutes&#39;,user.roles).then(() =&amp;gt; {
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) =&amp;gt; {
          store.dispatch(&#39;FedLogOut&#39;).then(() =&amp;gt; {
            Message.error(err || &#39;Verification failed, please login again&#39;)
            next({ path: &#39;/&#39; })
          })
        })
      } else {
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓
        if (hasPermission(store.getters.roles, to.meta.roles)) {
          next()
        } else {
          next({ path: &#39;/401&#39;, replace: true, query: { noGoBack: true }})
        }
      }
    }
  }else {
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next(`/login?redirect=${to.path}`) // 否则全部重定向到登录页
      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it
    }
  }
})



router.afterEach(() =&amp;gt; {
  NProgress.done() // finish progress bar
})
    

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>vue-element-admin 踩坑日记 01</title>
            <link>http://blog.flywithme.top/2018/12/22/vue-element-admin01/</link>
            <pubDate>Sat, 22 Dec 2018 06:57:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/22/vue-element-admin01/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://panjiachen.github.io/vue-element-admin&#34;&gt;vue-element-admin&lt;/a&gt; 是一个后台集成解决方案，
它基于 vue 和 element。它使用了最新的前端技术栈，
内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，
提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。&lt;/p&gt;

&lt;p&gt;通过vue-element-admin 的源代码学习掌握Vue的一些基础知识&lt;/p&gt;

&lt;h5 id=&#34;svg-图片加载&#34;&gt;SVG 图片加载&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;src/components目录下创建文件夹结构如下
  &lt;img src=&#34;http://blog.flywithme.top/sources/vue/1458ED9C-2172-42AE-B350-131FDD080B19.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;br /&gt;
SvgIcon下创建index.vue文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;svg :class=&amp;quot;svgClass&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;use :xlink:href=&amp;quot;iconName&amp;quot;/&amp;gt;
  &amp;lt;/svg&amp;gt;
&amp;lt;/template&amp;gt;
    
&amp;lt;script&amp;gt;
export default {
  name: &#39;SvgIcon&#39;,
  props: {
    iconClass: {
      type: String,
      required: true
    },
    className: {
      type: String,
      default: &#39;&#39;
    }
  },
  computed: {
    iconName() {
      return `#icon-${this.iconClass}`
    },
    svgClass() {
      if (this.className) {
        return &#39;svg-icon &#39; + this.className
      } else {
        return &#39;svg-icon&#39;
      }
    }
  }
}
&amp;lt;/script&amp;gt;
    
&amp;lt;style scoped&amp;gt;
.svg-icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在src目录下创建文件夹结构如图&lt;br /&gt;
 &lt;img src=&#34;http://blog.flywithme.top/sources/vue/C4C47129-A335-4E5C-B076-2C1167B78492.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;br /&gt;
svg 文件夹下放icon表情文件(.svg格式的文件)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;index.js文件内容如下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    import Vue from &#39;vue&#39;
    import SvgIcon from &#39;@/components/SvgIcon&#39;// svg组件
    
    // register globally
    Vue.component(&#39;svg-icon&#39;, SvgIcon)
    
    const req = require.context(&#39;./svg&#39;, false, /\.svg$/)
    const requireAll = requireContext =&amp;gt; requireContext.keys().map(requireContext)
    requireAll(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;svgo.yml文件内容如下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# replace default config

# multipass: true
# full: true

plugins:

  # - name
  #
  # or:
  # - name: false
  # - name: true
  #
  # or:
  # - name:
  #     param1: 1
  #     param2: 2

- removeAttrs:
    attrs:
      - &#39;fill&#39;
      - &#39;fill-rule&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改配置文件 package.json文件
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;在scriptes 属性下添加一行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;svgo&amp;quot;: &amp;quot;svgo -f src/icons/svg --config=src/icons/svgo.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改build目录下webpack.base.conf.js文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;修改module-&amp;gt;rules下元素&lt;/strong&gt;
  如图示修改
 &lt;img src=&#34;http://blog.flywithme.top/sources/vue/90A23CD9-00AD-4A94-A9E6-7F0C088E7B16.png&#34; alt=&#34;文件结构&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      test: /\.svg$/,
      loader: &#39;svg-sprite-loader&#39;,
      include: [resolve(&#39;src/icons&#39;)],
      options: {
        symbolId: &#39;icon-[name]&#39;
      }
    },
    {
      test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
      loader: &#39;url-loader&#39;,
      exclude: [resolve(&#39;src/icons&#39;)],
      options: {
        limit: 10000,
        name: utils.assetsPath(&#39;img/[name].[hash:7].[ext]&#39;)
      }
    },
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>gin api 跨域问题,cors</title>
            <link>http://blog.flywithme.top/2018/12/18/blocked-by-CORS-policy/</link>
            <pubDate>Tue, 18 Dec 2018 03:35:24 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/18/blocked-by-CORS-policy/</guid>
            <description>&lt;p&gt;当一个资源从与该资源本身所在的服务器&lt;strong&gt;不同的域或端口&lt;/strong&gt;请求一个资源时，资源会发起一个跨域 HTTP 请求。&lt;/p&gt;

&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨域 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循&lt;strong&gt;同源策略&lt;/strong&gt;。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件。&lt;/p&gt;

&lt;p&gt;跨域资源共享标准：规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 &lt;code&gt;OPTIONS&lt;/code&gt; 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-contrib/cors&amp;quot;
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
)

func main() {
	router := gin.Default()
	// CORS for https://foo.com and https://github.com origins, allowing:
	// - PUT and PATCH methods
	// - Origin header
	// - Credentials share
	// - Preflight requests cached for 12 hours
	router.Use(cors.New(cors.Config{
		AllowOrigins:     []string{&amp;quot;https://foo.com&amp;quot;},
		AllowMethods:     []string{&amp;quot;PUT&amp;quot;, &amp;quot;PATCH&amp;quot;},
		AllowHeaders:     []string{&amp;quot;Origin&amp;quot;},
		ExposeHeaders:    []string{&amp;quot;Content-Length&amp;quot;},
		AllowCredentials: true,
		AllowOriginFunc: func(origin string) bool {
			return origin == &amp;quot;https://github.com&amp;quot;
		},
		MaxAge: 12 * time.Hour,
	}))
	router.Run()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>MongoDB 用户名密码登录</title>
            <link>http://blog.flywithme.top/2018/12/10/mongodb/</link>
            <pubDate>Mon, 10 Dec 2018 06:53:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/12/10/mongodb/</guid>
            <description>

&lt;h5 id=&#34;mongodb-authentication&#34;&gt;MongoDB authentication&lt;/h5&gt;

&lt;p&gt;MongoDB 默认直接连接，无须身份验证，如果当前机器可以公网访问，且不注意Mongodb 端口（默认 27017）的开放状态，那么Mongodb就会产生安全风险，被利用此配置漏洞，入侵数据库。&lt;/p&gt;

&lt;h5 id=&#34;容易遭受入侵的环境&#34;&gt;容易遭受入侵的环境&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用默认 mongod 命令启动 Mongodb&lt;/li&gt;
&lt;li&gt;机器可以被公网访问&lt;/li&gt;
&lt;li&gt;在公网上开放了 Mongodb 端口
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;开启用户名和密码验证&#34;&gt;开启用户名和密码验证&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;终端启动数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//参数默认可以不加，若有自定义参数，才要加上，下同
mongod --port 27017 --dbpath /data/db1  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;连接 mongo后创建用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongo --port 27017
use admin
db.createUser(
  {
    user: &amp;quot;adminUser&amp;quot;,
    pwd: &amp;quot;adminPass&amp;quot;,
    roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ]
  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启 mongod 数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --auth --port 27017 --dbpath /data/db1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;连接数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongo --port 27017 -u &amp;quot;adminUser&amp;quot; -p &amp;quot;adminPass&amp;quot; --authenticationDatabase &amp;quot;admin&amp;quot;

mongo --port 27017
    
use admin
db.auth(&amp;quot;adminUser&amp;quot;, &amp;quot;adminPass&amp;quot;)
    
// 输出 1 表示验证成功
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建普通用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use foo
    
db.createUser(
  {
    user: &amp;quot;simpleUser&amp;quot;,
    pwd: &amp;quot;simplePass&amp;quot;,
    roles: [ { role: &amp;quot;readWrite&amp;quot;, db: &amp;quot;foo&amp;quot; },
             { role: &amp;quot;read&amp;quot;, db: &amp;quot;bar&amp;quot; } ]
  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用普通用户连接数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
