<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Fri, 15 Mar 2019 20:15:55 CST</updated>
        
        <item>
            <title>028_实现strStr()</title>
            <link>http://blog.flywithme.top/2019/03-15/028_implementstr/</link>
            <pubDate>Fri, 15 Mar 2019 20:15:55 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/028_implementstr/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot;
输出: 2

输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot;
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。&lt;/p&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//暴力比较
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        equle := true
        for j := 0; j &amp;lt; len(needle); j ++ {
            if needle[j]!= haystack[i] {
                equle = false
                break
            }
        }
        if equle {
            return i
        }
    }

    return -1
}


//字符串截取比较(可能不符合题设)
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    if len(needle) &amp;gt; len(haystack) {
        return -1
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        if i + len(needle) &amp;gt; len(haystack) {
            return -1
        }
        if needle == haystack[i:i+len(needle)]{
            return i
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>027_移除元素</title>
            <link>http://blog.flywithme.top/2019/03-15/027_remove_element/</link>
            <pubDate>Fri, 15 Mar 2019 20:02:23 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/027_remove_element/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;示例1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    为什么返回数值是整数，但输出的答案是数组呢?
    请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
    你可以想象内部操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func removeElement(nums []int, val int) int {
      index := 0
    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i]!= val {
            nums[index] = nums[i]
            index++
        }
    }
    return index
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>026-删除排序数组中的重复项</title>
            <link>http://blog.flywithme.top/2019/03-15/remove-duplicates-from-sorted-array/</link>
            <pubDate>Fri, 15 Mar 2019 19:47:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/remove-duplicates-from-sorted-array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    为什么返回数值是整数，但输出的答案是数组呢?
    请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
    你可以想象内部操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func removeDuplicates(nums []int) int {
    if len(nums)&amp;lt;=1 {
        return 1
    }
    index := 0
    for i := 1; i &amp;lt; len(nums); i ++ {
        if nums[index] != nums[i] {
            index++
            nums[index] = nums[i]
        }
    }
    return index+1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>025-k个一组翻转链表</title>
            <link>http://blog.flywithme.top/2019/03-15/reverse-node/</link>
            <pubDate>Fri, 15 Mar 2019 14:00:23 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/reverse-node/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func reverseKGroup(head *ListNode, k int) *ListNode {
    if k &amp;lt;= 0 {
        return head
    }
    pre,end,next := reverseNode(head,k)
    for next != nil {
        end.Next,end,next = reverseNode(next,k)
    }
    return pre
}

func lenNode(head *ListNode)int  {
    count := 0
    node := head
    for node!= nil{
        count++
        node = node.Next
    }
    return count
}


func reverseNode(head *ListNode,k int)(pre*ListNode,end *ListNode,next *ListNode)  {
    if lenNode(head) &amp;lt; k {
        return head,nil,nil
    }
    i := 0
    //翻转，头变尾巴
    end = head
    for head != nil &amp;amp;&amp;amp; i &amp;lt; k {
        next = head.Next
        head.Next = pre
        pre = head
        head = next
        i ++
    }
    end.Next = next
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-nodes-in-k-group/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>024-两两交换链表中的节点 Swap Nodes in Pairs</title>
            <link>http://blog.flywithme.top/2019/03-14/swap-nodes-in-pairs/</link>
            <pubDate>Thu, 14 Mar 2019 14:33:24 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-14/swap-nodes-in-pairs/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;

&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 
返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    next := head.Next
    head.Next = swapPairs(next.Next)
    next.Next = head
    return next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/swap-nodes-in-pairs/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>023-合并K个排序链表 Merge k Sorted Lists</title>
            <link>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</link>
            <pubDate>Wed, 13 Mar 2019 23:38:57 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}


func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    if len(lists) == 1 {
        return lists[0]
    }
    result := lists[0]
    for i := 1; i &amp;lt; len(lists);i ++ {
        result = mergeTwoList(result,lists[i])
    }
    return result
}

func mergeTwoList(left *ListNode,right *ListNode)*ListNode  {
    if left == nil{
        return right
    }
    if right == nil {
        return left
    }
    result := new(ListNode)
    if left.Val &amp;gt; right.Val {
        result = right
        result.Next = mergeTwoList(left,right.Next)
    }else  {
        result = left
        result.Next = mergeTwoList(left.Next,right)
    }
    return result
}




func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-k-sorted-lists/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>022-括号生成</title>
            <link>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</link>
            <pubDate>Wed, 13 Mar 2019 22:08:04 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给出 n = 3，生成结果为：
[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//
func generateParenthesis1(n int) []string {
    var result  []string
    addparents(&amp;amp;result,n,n,&amp;quot;&amp;quot;)
    return result
}

func addparents(result *[]string,left,right int,str string)  {
    if left == 0 &amp;amp;&amp;amp; right == 0 {
        *result = append(*result,str)
    }
    if left  &amp;gt; 0{
         addparents(result,left-1,right,str+ &amp;quot;(&amp;quot;)
    }
    if right &amp;gt; 0 &amp;amp;&amp;amp; left &amp;lt; right {
        addparents(result,left,right-1,str+ &amp;quot;)&amp;quot;)
    }
}




//暴力遍历
func generateParenthesis(n int) []string {
    var result []string
    para := &amp;quot;()&amp;quot;
    for i := 0 ;i &amp;lt; n ;i ++ {
        result = generationPar(result,para)
    }
    maps := map[string]bool{}
    list := make([]string,0)
    for _,item := range result {
        if !maps[item] {
            list = append(list, item)
            maps[item] = true
        }
    }
    return list
}

func generationPar(seeds []string ,para string)[]string  {
    if len(seeds) == 0 {
        return []string{para}
    }
    var result []string
    for _,item := range seeds {
        for i := 0 ;i &amp;lt; len(item) ; i ++ {
            left := item[0:i]
            right := item[i:]
            result = append(result, left+para+right)
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/generate-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>021-合并两个有序链表</title>
            <link>http://blog.flywithme.top/2019/03-13/merge-two-sorted-list/</link>
            <pubDate>Wed, 13 Mar 2019 20:35:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/merge-two-sorted-list/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
     Next *ListNode
}


func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}


//遍历
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    head := new(ListNode)
    current := head
    for l1 != nil || l2 != nil {
        if l1 == nil {
            current.Next = l2
            break
        }
        if l2 == nil {
            current.Next = l1
            break
        }
        if  l1.Val &amp;lt; l2.Val {
            current.Next = l1
            l1 = l1.Next
        }else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    return head.Next
}


//递归
func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    result := new(ListNode)
    if l1.Val &amp;gt; l2.Val {
        result = l2
        result.Next = mergeTwoLists(l1,l2.Next)
    }else {
        result = l1
        result.Next = mergeTwoLists(l1.Next,l2)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-two-sorted-lists/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>020-有效的括号</title>
            <link>http://blog.flywithme.top/2019/03-13/validparentheses/</link>
            <pubDate>Wed, 13 Mar 2019 20:31:26 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/validparentheses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个只包括 &lt;code&gt;&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;&lt;/code&gt; 的字符串，判断字符串是否有效。
有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
    注意空字符串可被认为是有效字符串。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;()&amp;quot;
输出: true

输入: &amp;quot;()[]{}&amp;quot;
输出: true

输入: &amp;quot;(]&amp;quot;
输出: false

输入: &amp;quot;([)]&amp;quot;
输出: false

输入: &amp;quot;{[]}&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    parenthessMap = map[int]int{&#39;)&#39;:&#39;(&#39;,&#39;}&#39;:&#39;{&#39;,&#39;]&#39;:&#39;[&#39;}
)

func isValid(s string) bool {
    var list []int
    for i := range s {
        v := s[i]
        switch v {
        case &#39;{&#39;,&#39;(&#39;,&#39;[&#39;:
            list = append(list, int(v))
        case &#39;}&#39;,&#39;)&#39;,&#39;]&#39;:
            if len(list) == 0 {
                return false
            }
            para := parenthessMap[int(v)]
            if int(list[len(list)-1]) == para {
                list = list[:len(list)-1]
            }else {
                return false
            }
        }
    }
    return len(list) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>019-删除链表的倒数第N个节点</title>
            <link>http://blog.flywithme.top/2019/03-13/removenthend/</link>
            <pubDate>Wed, 13 Mar 2019 18:23:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/removenthend/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;

&lt;p&gt;说明：
给定的 n 保证是有效的。
进阶：
你能尝试使用一趟扫描实现吗？&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}


func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := new(ListNode)
    dummy.Next = head
    left := dummy
    right := dummy
    for i := 0 ;i &amp;lt; n; i ++ {
        if right.Next == nil {
            return nil
        }
        right = right.Next
    }
    for right.Next != nil {
        right = right.Next
        left = left.Next
    }
    left.Next = left.Next.Next
    return dummy.Next
}


//testing
func TestRemoveNNode(t *testing.T)  {
    list := []int{1,2,3,4,5}
    node := formatList2Node(list)
    newNode  := removeNthFromEnd(node,2)
    for newNode != nil {
        fmt.Println(newNode.Val)
        newNode = newNode.Next
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>018-四数之和 4Sum</title>
            <link>http://blog.flywithme.top/2019/03-13/4sum/</link>
            <pubDate>Wed, 13 Mar 2019 17:13:18 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/4sum/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，
使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
 注意：
 答案中不可以包含重复的四元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    maps := map[int]int{}
    maps2 := map[string]bool{}
    for i,v := range nums {
        maps[v] = i
    }
    var list  [][]int
    for i := 0 ; i &amp;lt; len(nums) ; i ++ {
        for j := i +1;j &amp;lt; len(nums); j ++ {
            for k := j +1 ; k &amp;lt; len(nums); k ++ {
                member := target - nums[i] - nums[j] - nums[k]
                if index,ok := maps[member];ok &amp;amp;&amp;amp; index != i &amp;amp;&amp;amp; index != j &amp;amp;&amp;amp; index != k {
                    valuess := []int{nums[i],nums[j],nums[k],member}
                    sort.Ints(valuess)
                    key := strconv.Itoa(valuess[0]) + strconv.Itoa(valuess[1])+strconv.Itoa(valuess[2])+strconv.Itoa(valuess[3])
                    if _,ok := maps2[key];!ok {
                        list = append(list, valuess)
                        maps2[key] = true
                    }
                }
            }
        }
    }
    return list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/4sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>017-电话号码的字母组合</title>
            <link>http://blog.flywithme.top/2019/03-13/lettercombphone/</link>
            <pubDate>Wed, 13 Mar 2019 16:01:16 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/lettercombphone/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 &lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/WechatIMG97.jpeg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;23&amp;quot;
输出：[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].
说明:
 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    padMaps = map[int][]int{
        &#39;2&#39;:{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;},
        &#39;3&#39;:{&#39;d&#39;,&#39;e&#39;,&#39;f&#39;},
        &#39;4&#39;:{&#39;g&#39;,&#39;h&#39;,&#39;i&#39;},
        &#39;5&#39;:{&#39;j&#39;,&#39;k&#39;,&#39;l&#39;},
        &#39;6&#39;:{&#39;m&#39;,&#39;n&#39;,&#39;o&#39;},
        &#39;7&#39;:{&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;},
        &#39;8&#39;:{&#39;t&#39;,&#39;u&#39;,&#39;v&#39;},
        &#39;9&#39;:{&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;},
    }
)


func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return nil
    }
    var list [][]int
    for i := range digits{
        if value,ok := padMaps[int(digits[i])];ok  {
            list = append(list, value)
        }
    }
    var results []string
    for i := 0 ;i &amp;lt; len(list);i ++ {
        results = combinations(results,list[i])
    }
    return results
}
//字符串组合
func combinations(left []string,right []int)[]string  {
    if len(right) == 0 {
        return left
    }
    var result  []string
    if len(left) == 0 {
        for i := range right {
            result = append(result, string(right[i]))
        }
    }else {
        for i := range left{
            for j := range right {
                result = append(result, left[i]+string(right[j]))
            }
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/letter-combinations-of-a-phone-number/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>016-最接近的三数之和</title>
            <link>http://blog.flywithme.top/2019/03-13/3sumclosest/</link>
            <pubDate>Wed, 13 Mar 2019 13:27:30 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sumclosest/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包括 n 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，
使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSumClosest(nums []int, target int) int {
    closestSum := math.MaxInt32
    sort.Ints(nums)
    for i := 0;i &amp;lt; len(nums)-2;i ++ {
        left,right := i +1,len(nums)-1
        for left &amp;lt; right {
            sum := nums[i] + nums[left] + nums[right]
            if numAbs(closestSum,target) &amp;gt; numAbs(sum,target) {
                closestSum = sum
            }
            if sum &amp;lt; target {
                left++
            }else if sum &amp;gt; target {
                right--
            }else {
                return sum
            }
        }
    }
    return closestSum
}

func numAbs(a,b int)int  {
    if a &amp;gt; b {
        return a - b
    }
    return b - a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum-closest/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>015-三数之和 3Sum</title>
            <link>http://blog.flywithme.top/2019/03-13/3sum/</link>
            <pubDate>Wed, 13 Mar 2019 01:42:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sum/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，
使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSum(nums []int) [][]int {
    return threeSum1(nums,0)
}

func sortNums(nums []int)  {
    for i := 0;i &amp;lt; len(nums);i ++ {
        for j := i +1 ; j &amp;lt; len(nums);j ++ {
            if nums[i] &amp;gt; nums[j] {
                nums[i],nums[j] = nums[j],nums[i]
            }
        }
    }
}

func threeSum1(nums []int ,target int) [][]int {
    sortNums(nums)
    var list [][]int
    maps := make(map[int]int,len(nums))
    for i,v := range nums{
        maps[v] = i
    }
    valuess := make([]int,3)
    maps2 := map[string]bool{}
    for i := 0 ; i &amp;lt; len(nums); i ++ {
        if nums[i] &amp;gt; target {
            break
        }
        for j := i + 1; j &amp;lt; len(nums); j ++ {
            member := target - nums[i] - nums[j]
            if k,ok := maps[member];ok &amp;amp;&amp;amp; k != i &amp;amp;&amp;amp; k != j {
                valuess = []int{member,nums[i],nums[j]}
                sortNums(valuess)
                key := fmt.Sprintf(&amp;quot;%d%d%d&amp;quot;,valuess[0],valuess[1],valuess[2])
                if _,ok := maps2[key];ok {
                    continue
                }else {
                    maps2[key] = true
                    list = append(list, []int{valuess[0],valuess[1],valuess[2]})
                }
            }
        }
    }
    return list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>010-最长公共前缀</title>
            <link>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</link>
            <pubDate>Wed, 13 Mar 2019 01:23:07 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]
输出: &amp;quot;&amp;quot;
解释: 输入不存在公共前缀。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return &amp;quot;&amp;quot;
    }
    prefix := strs[0]
    for i := 1;i &amp;lt; len(strs);i ++ {
        prefix = comparePrefix(prefix,strs[i])
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

func comparePrefix(left ,right string)string  {
    if len(left)&amp;gt;len(right) {
        left,right = right,left
    }
    value := &amp;quot;&amp;quot;
    for i := range left {
        if left[0:i+1] == right[0:i+1] {
            value = left[0:i+1]
        }else {
            break
        }
    }
    return value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-common-prefix/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
