<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Wed, 13 Mar 2019 23:38:57 CST</updated>
        
        <item>
            <title>合并K个排序链表 Merge k Sorted Lists</title>
            <link>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</link>
            <pubDate>Wed, 13 Mar 2019 23:38:57 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}


func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    if len(lists) == 1 {
        return lists[0]
    }
    result := lists[0]
    for i := 1; i &amp;lt; len(lists);i ++ {
        result = mergeTwoList(result,lists[i])
    }
    return result
}

func mergeTwoList(left *ListNode,right *ListNode)*ListNode  {
    if left == nil{
        return right
    }
    if right == nil {
        return left
    }
    result := new(ListNode)
    if left.Val &amp;gt; right.Val {
        result = right
        result.Next = mergeTwoList(left,right.Next)
    }else  {
        result = left
        result.Next = mergeTwoList(left.Next,right)
    }
    return result
}




func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-k-sorted-lists/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>括号生成</title>
            <link>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</link>
            <pubDate>Wed, 13 Mar 2019 22:08:04 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给出 n = 3，生成结果为：
[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//
func generateParenthesis1(n int) []string {
    var result  []string
    addparents(&amp;amp;result,n,n,&amp;quot;&amp;quot;)
    return result
}

func addparents(result *[]string,left,right int,str string)  {
    if left == 0 &amp;amp;&amp;amp; right == 0 {
        *result = append(*result,str)
    }
    if left  &amp;gt; 0{
         addparents(result,left-1,right,str+ &amp;quot;(&amp;quot;)
    }
    if right &amp;gt; 0 &amp;amp;&amp;amp; left &amp;lt; right {
        addparents(result,left,right-1,str+ &amp;quot;)&amp;quot;)
    }
}




//暴力遍历
func generateParenthesis(n int) []string {
    var result []string
    para := &amp;quot;()&amp;quot;
    for i := 0 ;i &amp;lt; n ;i ++ {
        result = generationPar(result,para)
    }
    maps := map[string]bool{}
    list := make([]string,0)
    for _,item := range result {
        if !maps[item] {
            list = append(list, item)
            maps[item] = true
        }
    }
    return list
}

func generationPar(seeds []string ,para string)[]string  {
    if len(seeds) == 0 {
        return []string{para}
    }
    var result []string
    for _,item := range seeds {
        for i := 0 ;i &amp;lt; len(item) ; i ++ {
            left := item[0:i]
            right := item[i:]
            result = append(result, left+para+right)
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/generate-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>合并两个有序链表</title>
            <link>http://blog.flywithme.top/2019/03-13/merge-two-sorted-list/</link>
            <pubDate>Wed, 13 Mar 2019 20:35:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/merge-two-sorted-list/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
     Next *ListNode
}


func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}


//遍历
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    head := new(ListNode)
    current := head
    for l1 != nil || l2 != nil {
        if l1 == nil {
            current.Next = l2
            break
        }
        if l2 == nil {
            current.Next = l1
            break
        }
        if  l1.Val &amp;lt; l2.Val {
            current.Next = l1
            l1 = l1.Next
        }else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    return head.Next
}


//递归
func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    result := new(ListNode)
    if l1.Val &amp;gt; l2.Val {
        result = l2
        result.Next = mergeTwoLists(l1,l2.Next)
    }else {
        result = l1
        result.Next = mergeTwoLists(l1.Next,l2)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-two-sorted-lists/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>有效的括号</title>
            <link>http://blog.flywithme.top/2019/03-13/validparentheses/</link>
            <pubDate>Wed, 13 Mar 2019 20:31:26 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/validparentheses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个只包括 &lt;code&gt;&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;&lt;/code&gt; 的字符串，判断字符串是否有效。
有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
    注意空字符串可被认为是有效字符串。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;()&amp;quot;
输出: true

输入: &amp;quot;()[]{}&amp;quot;
输出: true

输入: &amp;quot;(]&amp;quot;
输出: false

输入: &amp;quot;([)]&amp;quot;
输出: false

输入: &amp;quot;{[]}&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    parenthessMap = map[int]int{&#39;)&#39;:&#39;(&#39;,&#39;}&#39;:&#39;{&#39;,&#39;]&#39;:&#39;[&#39;}
)

func isValid(s string) bool {
    var list []int
    for i := range s {
        v := s[i]
        switch v {
        case &#39;{&#39;,&#39;(&#39;,&#39;[&#39;:
            list = append(list, int(v))
        case &#39;}&#39;,&#39;)&#39;,&#39;]&#39;:
            if len(list) == 0 {
                return false
            }
            para := parenthessMap[int(v)]
            if int(list[len(list)-1]) == para {
                list = list[:len(list)-1]
            }else {
                return false
            }
        }
    }
    return len(list) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>删除链表的倒数第N个节点</title>
            <link>http://blog.flywithme.top/2019/03-13/removenthend/</link>
            <pubDate>Wed, 13 Mar 2019 18:23:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/removenthend/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;

&lt;p&gt;说明：
给定的 n 保证是有效的。
进阶：
你能尝试使用一趟扫描实现吗？&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}


func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := new(ListNode)
    dummy.Next = head
    left := dummy
    right := dummy
    for i := 0 ;i &amp;lt; n; i ++ {
        if right.Next == nil {
            return nil
        }
        right = right.Next
    }
    for right.Next != nil {
        right = right.Next
        left = left.Next
    }
    left.Next = left.Next.Next
    return dummy.Next
}


//testing
func TestRemoveNNode(t *testing.T)  {
    list := []int{1,2,3,4,5}
    node := formatList2Node(list)
    newNode  := removeNthFromEnd(node,2)
    for newNode != nil {
        fmt.Println(newNode.Val)
        newNode = newNode.Next
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>四数之和 4Sum</title>
            <link>http://blog.flywithme.top/2019/03-13/4sum/</link>
            <pubDate>Wed, 13 Mar 2019 17:13:18 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/4sum/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，
使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
 注意：
 答案中不可以包含重复的四元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    maps := map[int]int{}
    maps2 := map[string]bool{}
    for i,v := range nums {
        maps[v] = i
    }
    var list  [][]int
    for i := 0 ; i &amp;lt; len(nums) ; i ++ {
        for j := i +1;j &amp;lt; len(nums); j ++ {
            for k := j +1 ; k &amp;lt; len(nums); k ++ {
                member := target - nums[i] - nums[j] - nums[k]
                if index,ok := maps[member];ok &amp;amp;&amp;amp; index != i &amp;amp;&amp;amp; index != j &amp;amp;&amp;amp; index != k {
                    valuess := []int{nums[i],nums[j],nums[k],member}
                    sort.Ints(valuess)
                    key := strconv.Itoa(valuess[0]) + strconv.Itoa(valuess[1])+strconv.Itoa(valuess[2])+strconv.Itoa(valuess[3])
                    if _,ok := maps2[key];!ok {
                        list = append(list, valuess)
                        maps2[key] = true
                    }
                }
            }
        }
    }
    return list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/4sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>电话号码的字母组合</title>
            <link>http://blog.flywithme.top/2019/03-13/lettercombphone/</link>
            <pubDate>Wed, 13 Mar 2019 16:01:16 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/lettercombphone/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 &lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/WechatIMG97.jpeg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：&amp;quot;23&amp;quot;
输出：[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].
说明:
 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    padMaps = map[int][]int{
        &#39;2&#39;:{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;},
        &#39;3&#39;:{&#39;d&#39;,&#39;e&#39;,&#39;f&#39;},
        &#39;4&#39;:{&#39;g&#39;,&#39;h&#39;,&#39;i&#39;},
        &#39;5&#39;:{&#39;j&#39;,&#39;k&#39;,&#39;l&#39;},
        &#39;6&#39;:{&#39;m&#39;,&#39;n&#39;,&#39;o&#39;},
        &#39;7&#39;:{&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;},
        &#39;8&#39;:{&#39;t&#39;,&#39;u&#39;,&#39;v&#39;},
        &#39;9&#39;:{&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;},
    }
)


func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return nil
    }
    var list [][]int
    for i := range digits{
        if value,ok := padMaps[int(digits[i])];ok  {
            list = append(list, value)
        }
    }
    var results []string
    for i := 0 ;i &amp;lt; len(list);i ++ {
        results = combinations(results,list[i])
    }
    return results
}
//字符串组合
func combinations(left []string,right []int)[]string  {
    if len(right) == 0 {
        return left
    }
    var result  []string
    if len(left) == 0 {
        for i := range right {
            result = append(result, string(right[i]))
        }
    }else {
        for i := range left{
            for j := range right {
                result = append(result, left[i]+string(right[j]))
            }
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/letter-combinations-of-a-phone-number/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>最接近的三数之和</title>
            <link>http://blog.flywithme.top/2019/03-13/3sumclosest/</link>
            <pubDate>Wed, 13 Mar 2019 13:27:30 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sumclosest/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包括 n 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，
使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSumClosest(nums []int, target int) int {
    closestSum := math.MaxInt32
    sort.Ints(nums)
    for i := 0;i &amp;lt; len(nums)-2;i ++ {
        left,right := i +1,len(nums)-1
        for left &amp;lt; right {
            sum := nums[i] + nums[left] + nums[right]
            if numAbs(closestSum,target) &amp;gt; numAbs(sum,target) {
                closestSum = sum
            }
            if sum &amp;lt; target {
                left++
            }else if sum &amp;gt; target {
                right--
            }else {
                return sum
            }
        }
    }
    return closestSum
}

func numAbs(a,b int)int  {
    if a &amp;gt; b {
        return a - b
    }
    return b - a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum-closest/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>三数之和 3Sum</title>
            <link>http://blog.flywithme.top/2019/03-13/3sum/</link>
            <pubDate>Wed, 13 Mar 2019 01:42:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sum/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，
使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSum(nums []int) [][]int {
    return threeSum1(nums,0)
}

func sortNums(nums []int)  {
    for i := 0;i &amp;lt; len(nums);i ++ {
        for j := i +1 ; j &amp;lt; len(nums);j ++ {
            if nums[i] &amp;gt; nums[j] {
                nums[i],nums[j] = nums[j],nums[i]
            }
        }
    }
}

func threeSum1(nums []int ,target int) [][]int {
    sortNums(nums)
    var list [][]int
    maps := make(map[int]int,len(nums))
    for i,v := range nums{
        maps[v] = i
    }
    valuess := make([]int,3)
    maps2 := map[string]bool{}
    for i := 0 ; i &amp;lt; len(nums); i ++ {
        if nums[i] &amp;gt; target {
            break
        }
        for j := i + 1; j &amp;lt; len(nums); j ++ {
            member := target - nums[i] - nums[j]
            if k,ok := maps[member];ok &amp;amp;&amp;amp; k != i &amp;amp;&amp;amp; k != j {
                valuess = []int{member,nums[i],nums[j]}
                sortNums(valuess)
                key := fmt.Sprintf(&amp;quot;%d%d%d&amp;quot;,valuess[0],valuess[1],valuess[2])
                if _,ok := maps2[key];ok {
                    continue
                }else {
                    maps2[key] = true
                    list = append(list, []int{valuess[0],valuess[1],valuess[2]})
                }
            }
        }
    }
    return list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>最长公共前缀</title>
            <link>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</link>
            <pubDate>Wed, 13 Mar 2019 01:23:07 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]
输出: &amp;quot;&amp;quot;
解释: 输入不存在公共前缀。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return &amp;quot;&amp;quot;
    }
    prefix := strs[0]
    for i := 1;i &amp;lt; len(strs);i ++ {
        prefix = comparePrefix(prefix,strs[i])
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

func comparePrefix(left ,right string)string  {
    if len(left)&amp;gt;len(right) {
        left,right = right,left
    }
    value := &amp;quot;&amp;quot;
    for i := range left {
        if left[0:i+1] == right[0:i+1] {
            value = left[0:i+1]
        }else {
            break
        }
    }
    return value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-common-prefix/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>罗马数字转整数</title>
            <link>http://blog.flywithme.top/2019/03-13/roman2int/</link>
            <pubDate>Wed, 13 Mar 2019 00:57:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/roman2int/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
 - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/p&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;III&amp;quot;
输出: 3

输入: &amp;quot;IV&amp;quot;
输出: 4

输入: &amp;quot;IX&amp;quot;
输出: 9

输入: &amp;quot;LVIII&amp;quot;
输出: 58
解释: L = 50, V= 5, III = 3.

输入: &amp;quot;MCMXCIV&amp;quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    romanMap = map[string]int{
        &amp;quot;I&amp;quot;:1,&amp;quot;IV&amp;quot;:4,&amp;quot;V&amp;quot;:5,&amp;quot;IX&amp;quot;:9,
        &amp;quot;X&amp;quot;:10,&amp;quot;XL&amp;quot;:40,&amp;quot;L&amp;quot;:50,&amp;quot;XC&amp;quot;:90,
        &amp;quot;C&amp;quot;:100,&amp;quot;CD&amp;quot;:400,&amp;quot;D&amp;quot;:500,
        &amp;quot;CM&amp;quot;:900,&amp;quot;M&amp;quot;:1000,
    }
)

func romanToInt(s string) int {
    result := 0
    for i := 0; i &amp;lt; len(s);i ++ {
        value := s[i:i+1]
        if _,ok := romanMap[value];!ok {
            return 0
        }
        if i &amp;lt; len(s) - 1 {
            value2 := s[i+1:i +2]
            if romanMap[value2] &amp;gt; romanMap[value] {
                result += romanMap[value+value2]
                i = i+1
                continue
            }
        }
        result += romanMap[value]
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/roman-to-integer&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>整数转罗马数字</title>
            <link>http://blog.flywithme.top/2019/03-12/int2roman/</link>
            <pubDate>Tue, 12 Mar 2019 23:32:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-12/int2roman/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
 - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/p&gt;

&lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 3
输出: &amp;quot;III&amp;quot;

输入: 4
输出: &amp;quot;IV&amp;quot;

输入: 58
输出: &amp;quot;LVIII&amp;quot;
解释: L = 50, V = 5, III = 3.

输入: 1994
输出: &amp;quot;MCMXCIV&amp;quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//遍历出1-10，10—100，100-1000的特殊点
var (
    romanMap = map[int]string{
        1:&amp;quot;I&amp;quot;,2:&amp;quot;II&amp;quot;,3:&amp;quot;III&amp;quot;,4:&amp;quot;IV&amp;quot;,5:&amp;quot;V&amp;quot;,6:&amp;quot;VI&amp;quot;,7:&amp;quot;VII&amp;quot;,8:&amp;quot;VIII&amp;quot;,9:&amp;quot;IX&amp;quot;,
        10:&amp;quot;X&amp;quot;,20:&amp;quot;XX&amp;quot;,30:&amp;quot;XXX&amp;quot;,40:&amp;quot;XL&amp;quot;,50:&amp;quot;L&amp;quot;,60:&amp;quot;LX&amp;quot;,70:&amp;quot;LXX&amp;quot;,80:&amp;quot;LXXX&amp;quot;,90:&amp;quot;XC&amp;quot;,
        100:&amp;quot;C&amp;quot;,200:&amp;quot;CC&amp;quot;,300:&amp;quot;CCC&amp;quot;,400:&amp;quot;CD&amp;quot;,500:&amp;quot;D&amp;quot;,600:&amp;quot;DC&amp;quot;,700:&amp;quot;DCC&amp;quot;,800:&amp;quot;DCCC&amp;quot;,900:&amp;quot;CM&amp;quot;,
        1000:&amp;quot;M&amp;quot;,2000:&amp;quot;MM&amp;quot;,3000:&amp;quot;MMM&amp;quot;}
)

func intToRoman(num int) string {
    if num &amp;gt;3999 || num &amp;lt; 1 {
        return &amp;quot;&amp;quot;
    }
    result := &amp;quot;&amp;quot;
    flag := 1

    for num &amp;gt; 0 {
        value := num%10
        result = romanMap[value*flag] + result
        num,flag = num/10,flag*10
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/integer-to-roman/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>盛最多水的容器 Container With Most Water</title>
            <link>http://blog.flywithme.top/2019/03-12/containermostwater/</link>
            <pubDate>Tue, 12 Mar 2019 18:23:25 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-12/containermostwater/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。
在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。
 &lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/question_11.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,8,6,2,5,4,8,3,7]
Output: 49
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//01 暴力破解
func maxArea(height []int) int {
    maxArea := 0
    for i := 0; i &amp;lt; len(height);i ++ {
        for j := i +1;j &amp;lt; len(height); j ++ {
            maxArea = maxInt(maxArea,minInt(height[i],height[j]) *(j - i))
        }
    }
    return maxArea
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
func minInt(a,b int)int  {
    if a &amp;gt; b {
        return b
    }
    return a
}

//02 双指针计算
func maxArea1(height []int) int {
    maxArea := 0
    left := 0
    right := len(height)-1
    for left &amp;lt; right {
        maxArea = maxInt(maxArea,minInt(height[left],height[right])*(right - left))
        if height[left]&amp;lt;height[right] {
            left++
        }else {
            right--
        }
    }
    return maxArea
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Regular Expression Matching</title>
            <link>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</link>
            <pubDate>Sun, 10 Mar 2019 20:52:09 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;.&#39; 匹配任意单个字符。
&#39;*&#39; 匹配零个或多个前面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:
   s 可能为空，且只包含从 a-z 的小写字母。
   p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a&amp;quot;
输出: false
解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。


输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a*&amp;quot;
输出: true
解释: &#39;*&#39; 代表可匹配零个或多个前面的元素, 即可以匹配 &#39;a&#39; 。因此, 重复 &#39;a&#39; 一次, 字符串可变为 &amp;quot;aa&amp;quot;。

输入:
s = &amp;quot;ab&amp;quot;
p = &amp;quot;.*&amp;quot;
输出: true
解释: &amp;quot;.*&amp;quot; 表示可匹配零个或多个(&#39;*&#39;)任意字符(&#39;.&#39;)。

输入:
s = &amp;quot;aab&amp;quot;
p = &amp;quot;c*a*b&amp;quot;
输出: true
解释: &#39;c&#39; 可以不被重复, &#39;a&#39; 可以被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。


输入:
s = &amp;quot;mississippi&amp;quot;
p = &amp;quot;mis*is*p*.&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isMatch(s string, p string) bool {
    if p == &amp;quot;.*&amp;quot; {
        return true
    }
    if s == p {
        return true
    }
    if p == &amp;quot;&amp;quot; {
        return false
    }
    return match(s, p, 0, 0)
}

func match(s, p string, strIndex, patIndex int) bool {
    if patIndex == len(p) {
        return strIndex == len(s)
    }else {
        //第二个字符为*
        if patIndex &amp;lt; len(p) -1 &amp;amp;&amp;amp; p[patIndex+1:patIndex+2]== &amp;quot;*&amp;quot;{
            //若第一个字符匹配，则继续匹配后续；若第一个字符不匹配，正则后移两位
            if strIndex &amp;lt; len(s) &amp;amp;&amp;amp;
                (p[patIndex:patIndex+1] == &amp;quot;.&amp;quot;||s[strIndex:strIndex+1]==p[patIndex:patIndex+1]) {
                return match(s,p,strIndex,patIndex+2) || 
                       match(s,p,strIndex+1,patIndex)|| 
                       match(s,p,strIndex+1,patIndex+2)
            }else {
                return match(s,p,strIndex,patIndex+2)
            }
        }else if strIndex&amp;lt; len(s) &amp;amp;&amp;amp; 
        (p[patIndex:patIndex+1]==&amp;quot;.&amp;quot; || s[strIndex:strIndex+1]==p[patIndex:patIndex+1]){
            return match(s, p, strIndex+1, patIndex+1)
        }
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/regular-expression-matching/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>回文数</title>
            <link>http://blog.flywithme.top/2019/03-10/palindromeNumber/</link>
            <pubDate>Sun, 10 Mar 2019 20:35:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/palindromeNumber/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 121
输出: true


输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isPalindrome(x int) bool {
    if x &amp;lt; 0  {
        return false
    }
    if x %10 == 0 &amp;amp;&amp;amp; x != 0 {
        return false
    }
    result := 0

    for x &amp;gt; result {
        result = result*10 + x%10
        x = x/10
    }
    if result == x || x == result/10{
         return true
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
