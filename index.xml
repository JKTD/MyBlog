<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sun, 17 Mar 2019 01:00:47 CST</updated>
        
        <item>
            <title>036. Valid Sudoku</title>
            <link>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</link>
            <pubDate>Sun, 17 Mar 2019 01:00:47 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</guid>
            <description></description>
        </item>
        
        <item>
            <title>034.在排序数组中查找元素的第一个和最后一个位置 Find First and Last Position of Element in Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</link>
            <pubDate>Sun, 17 Mar 2019 00:35:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//O(log n)复杂度
func searchRange(nums []int, target int) []int {
    result := []int{-1,-1}
    if len(nums) == 0{
        return result
    }
    left ,right := 0,len(nums)
    for left &amp;lt; right {
        mid := (left+right)/2
        if nums[mid] &amp;gt;= target {
            right = mid
        }else {
            left = mid+1
        }
    }
    if left &amp;gt;= len(nums) {
        return result
    }
    if nums[left] != target {
        return result
    }
    result[0] = left
    right = len(nums)
    for left &amp;lt; right {
        mid := (left + right)/2
        if nums[mid] &amp;gt; target {
            right = mid
        }else {
            left = mid+1
        }
    }
    result[1] = right-1
    return result
}


//O(n)复杂度
func searchRange1(nums []int, target int) []int {
    result := []int{-1,-1}
    for i :=0;i &amp;lt; len(nums) ;i ++ {
        if nums[i] == target {
            result[0] = i
            break
        }
    }
    if result[0] == -1 {
        return result
    }

    for i := len(nums)-1;i &amp;gt;=0 ;i -- {
        if nums[i] == target {
            result[1] = i
            break
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>035.搜索插入位置 Search Insert Position</title>
            <link>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</link>
            <pubDate>Sun, 17 Mar 2019 00:34:05 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 7
输出: 4

输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func searchInsert(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }
    if target &amp;gt; nums[len(nums)-1] {
        return len(nums)
    }
    if target &amp;lt; nums[0] {
        return 0
    }
    left ,right := 0,len(nums)-1
    for left &amp;lt;= right {
        mid := (left+right)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] &amp;lt; target {
            left = mid +1
        }else {
            right = mid-1
        }
    }
    return left
}


func searchInsert1(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }

    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i] &amp;gt;= target {
            return i
        }
    }
    return len(nums)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>033.搜索旋转排序数组 Search in Rotated Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</link>
            <pubDate>Sat, 16 Mar 2019 20:26:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组&lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为&lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func search(nums []int, target int) int {
   low,high := 0,len(nums)-1
    if len(nums) == 0 {
        return -1
    }
    if nums[0] ==  target {
        return 0
    }
    for low &amp;lt; high {
        mid := (low+high)/2
        if nums[mid] == target {
            return mid
        }
        if nums[low] == target {
            return low
        }
        if nums[high] == target {
            return high
        }
        if nums[low] &amp;lt; nums[mid] {
            if nums[low] &amp;lt; target &amp;amp;&amp;amp; nums[mid] &amp;gt; target {
                high = mid-1
            }else {
                low = mid+1
            }
        }else {
            if nums[high] &amp;gt; target &amp;amp;&amp;amp; nums[mid] &amp;lt; target {
                low = mid+1
            }else {
                high = mid-1
            }
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>032_最长有效括号</title>
            <link>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</link>
            <pubDate>Sat, 16 Mar 2019 18:46:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;(()&amp;quot;
输出: 2
解释: 最长有效括号子串为 &amp;quot;()&amp;quot;

输入: &amp;quot;)()())&amp;quot;
输出: 4
解释: 最长有效括号子串为 &amp;quot;()()&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func maxInt(a,b int)int  {
    if a &amp;gt; b  {
        return a
    }
    return b
}

//动态规划
func longestValidParentheses(s string) int {
    max := 0
    dp := make([]int,len(s))
    for i := 1;i &amp;lt;len(s); i ++ {
        if s[i] == &#39;)&#39;{
            if s[i-1] ==&#39;(&#39; {
                if i &amp;gt;=2 {
                    dp[i] = dp[i-2]+2
                }else {
                    dp[i] = 2
                }
            }else if i - dp[i -1] &amp;gt; 0 &amp;amp;&amp;amp; s[i - dp[i-1] -1]== &#39;(&#39; {
                if  i - dp[i-1] &amp;gt;= 2 {
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2]  +2
                }else {
                    dp[i] = dp[i-1] + 2
                }
            }
            max = maxInt(max,dp[i])
        }
    }
    return max
}

//Using stack 栈，
func longestValidParentheses2(s string) int {
    var stack []int
    max := 0
    stack = append(stack,-1)
    for i := 0; i &amp;lt; len(s);i ++ {
        if s[i]==&#39;(&#39; {
            stack = append(stack,i)
        }else {
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                stack = append(stack,i)
            }else {
                max = maxInt(max,i - stack[len(stack)-1])
            }
        }
    }
    return max
}
func longestValidParentheses1(s string) int {
    if len(s)&amp;lt;=1 {
        return 0
    }
    help := make([]bool,len(s))
    var stack  []int
    for i := 0;i &amp;lt; len(s);i ++{
        help[i] = false
    }
    for i := 0; i &amp;lt; len(s); i ++ {
        if s[i] == &#39;(&#39;{
            stack = append(stack,i)
        }else {
            if len(stack) &amp;gt; 0{
                help[i] = true
                help[stack[len(stack)-1]] = true
                stack = stack[:len(stack)-1]
            }
        }
    }
    max,l := 0,0
    for i := 0; i &amp;lt; len(s);i ++ {
        if help[i] {
            l++
        }else {
            if max &amp;lt; l {
                max = l
            }
            l = 0
        }
    }
    return maxInt(max,l)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-valid-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>031_下一个排列</title>
            <link>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</link>
            <pubDate>Sat, 16 Mar 2019 02:50:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func nextPermutation(nums []int)  {
    if len(nums) &amp;lt;= 1 {
        return
    }
    var  i int
    for i = len(nums)-2;i &amp;gt;=0;i-- {
        if nums[i] &amp;lt; nums[i+1] {
            break
        }
    }
    if i == -1 {
        reverseSort(nums)
        return
    }
    var j int
    for j = len(nums)-1; j &amp;gt; i;j -- {
        if nums[j] &amp;gt; nums[i] {
            break
        }
    }
    nums[i],nums[j] = nums[j],nums[i]
    reverseSort(nums[i+1:])
}

func reverseSort(nums []int)  {
    lenth := len(nums)
    for i := 0;i &amp;lt;= lenth;i ++ {
        if i &amp;gt;= lenth - i -1 {
            break
        }
        nums[i],nums[lenth - i - 1] = nums[lenth - i - 1],nums[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>030_串联所有单词的子串</title>
            <link>http://blog.flywithme.top/2019/03-15/030_substring/</link>
            <pubDate>Fri, 15 Mar 2019 21:21:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/030_substring/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：
  s = &amp;quot;barfoothefoobarman&amp;quot;,
  words = [&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 &amp;quot;barfoor&amp;quot; 和 &amp;quot;foobar&amp;quot; 。
输出的顺序不重要, [9,0] 也是有效答案。

输入：
  s = &amp;quot;wordgoodgoodgoodbestword&amp;quot;,
  words = [&amp;quot;word&amp;quot;,&amp;quot;good&amp;quot;,&amp;quot;best&amp;quot;,&amp;quot;word&amp;quot;]
输出：[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//最优解？？？？？//TODO
func findSubstring1(s string, words []string)(ret []int)  {
    if len(words) == 0 {return}
    wl := len(words[0])
    for off :=0;off &amp;lt; wl; off ++ {
        beg,end := off,off
        list := append(make([]string,0),words...)
        loop:
            for end+wl &amp;lt;= len(s) {
                for i ,v := range list{
                    if v == s[end:end+wl] {
                        end +=wl
                        list = append(list[:i],list[i+1:]...)
                        if len(list) == 0{
                            ret = append(ret,beg)
                        }
                        goto loop
                    }
                }
                if beg &amp;lt; end{
                    list = append(list,s[beg:beg+wl])
                }else {
                    end += wl
                }
                beg +=wl
            }
    }
    return
}

//暴力
func findSubstring(s string, words []string)(ret []int)  {
    if len(words) == 0 {
        return
    }

    wLen := len(words[0])

    left := 0
loop:
    beg ,end := left,left
    list := append(make([]string, 0), words...)
loop1:
    for end+wLen &amp;lt;= len(s){
        for i,v := range list {
            if v == s[end:end+len(v)] {
                end +=len(v)
                list = append(list[:i],list[i+1:]...)
                if len(list) == 0 {
                    ret = append(ret,beg)
                    goto loop
                }else {
                    goto loop1
                }
            }
        }
        left++
        goto loop
    }
    return
}



//空间换时间
func findSubstring2(s string, words []string) []int {
    var ret  []int
    if len(words) == 0 || len(s) == 0 {
        return ret
    }
    l := len(words[0])
    size := l * len(words)
    if size &amp;gt; len(s) {
        return ret
    }
    idx := 0
    idxmap := make(map[string]int)
    for _, str := range words {
        _, ok := idxmap[str]
        if ok == false {
            idxmap[str] = idx
            idx++
        }
    }
    rawmap := make([]int, len(idxmap))
    for i := 0; i &amp;lt; len(rawmap); i++ {
        rawmap[i] = 0
    }
    for _, str := range words {
        rawmap[idxmap[str]]++
    }

    stridx := make([]int, len(s)-l+1)
    for i := 0; i &amp;lt; len(stridx); i++ {
        str := s[i : i+l]
        idx, ok := idxmap[str]
        if ok == false {
            stridx[i] = -1
        } else {
            stridx[i] = idx
        }
    }
    for i := 0; i &amp;lt; len(stridx); i++ {
        curmap := make([]int, len(rawmap))
        for i := 0; i &amp;lt; len(rawmap); i++ {
            curmap[i] = rawmap[i]
        }
        for j := 0; j &amp;lt; size &amp;amp;&amp;amp; i+j &amp;lt; len(stridx); j += l {
            if stridx[i+j] == -1 || curmap[stridx[i+j]] == 0 {
                break
            } else {
                curmap[stridx[i+j]]--
            }
            if j == size-l {
                ret = append(ret, i)
            }
        }
    }
    return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/substring-with-concatenation-of-all-words/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>029_两数相除 Divide Two Integers</title>
            <link>http://blog.flywithme.top/2019/03-15/029_divide_two_integers/</link>
            <pubDate>Fri, 15 Mar 2019 20:43:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/029_divide_two_integers/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: dividend = 10, divisor = 3
输出: 3

输入: dividend = 7, divisor = -3
输出: -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
   - 被除数和除数均为 32 位有符号整数。
   - 除数不为 0。
   - 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。
   本题中，如果除法结果溢出，则返回 231 − 1。&lt;/p&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//使用加减法计算
func divide(dividend int, divisor int) int {
    if divisor == 0{
        return 0
    }

    if dividend &amp;lt;= math.MinInt32 &amp;amp;&amp;amp; divisor == -1{
        return math.MaxInt32
    }
    negative := 1
    if dividend &amp;lt; 0 {
        negative = -negative
        dividend = -dividend
    }
    if divisor &amp;lt; 0 {
        negative = -negative
        divisor = -divisor
    }

    count := 0
    for dividend &amp;gt;= divisor {
        dividend = dividend - divisor
        count ++
    }
    if negative &amp;lt; 0 {
        count = -count
    }
    return count
}

//位移，计算速度更快
func divide1(dividend int, divisor int) int {
    if divisor == 0{
        return 0
    }

    if dividend &amp;lt;= math.MinInt32 &amp;amp;&amp;amp; divisor == -1{
        return math.MaxInt32
    }
    negative := 1
    if dividend &amp;lt; 0 {
        negative = -negative
        dividend = -dividend
    }
    if divisor &amp;lt; 0 {
        negative = -negative
        divisor = -divisor
    }

    count := 0
    for dividend &amp;gt;= divisor {
        temp,m := divisor,1
        for dividend &amp;gt;= temp&amp;lt;&amp;lt;1{
            temp,m = temp&amp;lt;&amp;lt;1,m&amp;lt;&amp;lt;1
        }
        dividend -=temp
        count +=m
    }
    if negative &amp;lt; 0 {
        count = -count
    }
    return count
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/divide-two-integers/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>028_实现strStr()</title>
            <link>http://blog.flywithme.top/2019/03-15/028_implementstr/</link>
            <pubDate>Fri, 15 Mar 2019 20:15:55 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/028_implementstr/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot;
输出: 2

输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot;
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。&lt;/p&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//暴力比较
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        equle := true
        for j := 0; j &amp;lt; len(needle); j ++ {
            if needle[j]!= haystack[i] {
                equle = false
                break
            }
        }
        if equle {
            return i
        }
    }

    return -1
}


//字符串截取比较(可能不符合题设)
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    if len(needle) &amp;gt; len(haystack) {
        return -1
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        if i + len(needle) &amp;gt; len(haystack) {
            return -1
        }
        if needle == haystack[i:i+len(needle)]{
            return i
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>027_移除元素</title>
            <link>http://blog.flywithme.top/2019/03-15/027_remove_element/</link>
            <pubDate>Fri, 15 Mar 2019 20:02:23 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/027_remove_element/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;示例1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    为什么返回数值是整数，但输出的答案是数组呢?
    请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
    你可以想象内部操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func removeElement(nums []int, val int) int {
      index := 0
    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i]!= val {
            nums[index] = nums[i]
            index++
        }
    }
    return index
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>026-删除排序数组中的重复项</title>
            <link>http://blog.flywithme.top/2019/03-15/remove-duplicates-from-sorted-array/</link>
            <pubDate>Fri, 15 Mar 2019 19:47:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/remove-duplicates-from-sorted-array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    为什么返回数值是整数，但输出的答案是数组呢?
    请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
    你可以想象内部操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func removeDuplicates(nums []int) int {
    if len(nums)&amp;lt;=1 {
        return 1
    }
    index := 0
    for i := 1; i &amp;lt; len(nums); i ++ {
        if nums[index] != nums[i] {
            index++
            nums[index] = nums[i]
        }
    }
    return index+1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>025-k个一组翻转链表</title>
            <link>http://blog.flywithme.top/2019/03-15/reverse-node/</link>
            <pubDate>Fri, 15 Mar 2019 14:00:23 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/reverse-node/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5

当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5

当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func reverseKGroup(head *ListNode, k int) *ListNode {
    if k &amp;lt;= 0 {
        return head
    }
    pre,end,next := reverseNode(head,k)
    for next != nil {
        end.Next,end,next = reverseNode(next,k)
    }
    return pre
}

func lenNode(head *ListNode)int  {
    count := 0
    node := head
    for node!= nil{
        count++
        node = node.Next
    }
    return count
}


func reverseNode(head *ListNode,k int)(pre*ListNode,end *ListNode,next *ListNode)  {
    if lenNode(head) &amp;lt; k {
        return head,nil,nil
    }
    i := 0
    //翻转，头变尾巴
    end = head
    for head != nil &amp;amp;&amp;amp; i &amp;lt; k {
        next = head.Next
        head.Next = pre
        pre = head
        head = next
        i ++
    }
    end.Next = next
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-nodes-in-k-group/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>024-两两交换链表中的节点 Swap Nodes in Pairs</title>
            <link>http://blog.flywithme.top/2019/03-14/swap-nodes-in-pairs/</link>
            <pubDate>Thu, 14 Mar 2019 14:33:24 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-14/swap-nodes-in-pairs/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;

&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 
返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}

func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    next := head.Next
    head.Next = swapPairs(next.Next)
    next.Next = head
    return next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/swap-nodes-in-pairs/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>023-合并K个排序链表 Merge k Sorted Lists</title>
            <link>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</link>
            <pubDate>Wed, 13 Mar 2019 23:38:57 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/Merge-k-Sorted-Lists/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  1-&amp;gt;4-&amp;gt;5,
  1-&amp;gt;3-&amp;gt;4,
  2-&amp;gt;6
]
输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val int
    Next *ListNode
}


func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    if len(lists) == 1 {
        return lists[0]
    }
    result := lists[0]
    for i := 1; i &amp;lt; len(lists);i ++ {
        result = mergeTwoList(result,lists[i])
    }
    return result
}

func mergeTwoList(left *ListNode,right *ListNode)*ListNode  {
    if left == nil{
        return right
    }
    if right == nil {
        return left
    }
    result := new(ListNode)
    if left.Val &amp;gt; right.Val {
        result = right
        result.Next = mergeTwoList(left,right.Next)
    }else  {
        result = left
        result.Next = mergeTwoList(left.Next,right)
    }
    return result
}




func formatList2Node(list []int)*ListNode  {
    head := new(ListNode)
    current := head
    for i := range list{
        current.Next = new(ListNode)
        current.Next.Val = list[i]
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-k-sorted-lists/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>022-括号生成</title>
            <link>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</link>
            <pubDate>Wed, 13 Mar 2019 22:08:04 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/generate-parenthesses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;给出 n = 3，生成结果为：
[
  &amp;quot;((()))&amp;quot;,
  &amp;quot;(()())&amp;quot;,
  &amp;quot;(())()&amp;quot;,
  &amp;quot;()(())&amp;quot;,
  &amp;quot;()()()&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//
func generateParenthesis1(n int) []string {
    var result  []string
    addparents(&amp;amp;result,n,n,&amp;quot;&amp;quot;)
    return result
}

func addparents(result *[]string,left,right int,str string)  {
    if left == 0 &amp;amp;&amp;amp; right == 0 {
        *result = append(*result,str)
    }
    if left  &amp;gt; 0{
         addparents(result,left-1,right,str+ &amp;quot;(&amp;quot;)
    }
    if right &amp;gt; 0 &amp;amp;&amp;amp; left &amp;lt; right {
        addparents(result,left,right-1,str+ &amp;quot;)&amp;quot;)
    }
}




//暴力遍历
func generateParenthesis(n int) []string {
    var result []string
    para := &amp;quot;()&amp;quot;
    for i := 0 ;i &amp;lt; n ;i ++ {
        result = generationPar(result,para)
    }
    maps := map[string]bool{}
    list := make([]string,0)
    for _,item := range result {
        if !maps[item] {
            list = append(list, item)
            maps[item] = true
        }
    }
    return list
}

func generationPar(seeds []string ,para string)[]string  {
    if len(seeds) == 0 {
        return []string{para}
    }
    var result []string
    for _,item := range seeds {
        for i := 0 ;i &amp;lt; len(item) ; i ++ {
            left := item[0:i]
            right := item[i:]
            result = append(result, left+para+right)
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/generate-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
