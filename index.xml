<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sun, 10 Mar 2019 20:52:09 CST</updated>
        
        <item>
            <title>Regular Expression Matching</title>
            <link>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</link>
            <pubDate>Sun, 10 Mar 2019 20:52:09 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;.&#39; 匹配任意单个字符。
&#39;*&#39; 匹配零个或多个前面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:
   s 可能为空，且只包含从 a-z 的小写字母。
   p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a&amp;quot;
输出: false
解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。


输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a*&amp;quot;
输出: true
解释: &#39;*&#39; 代表可匹配零个或多个前面的元素, 即可以匹配 &#39;a&#39; 。因此, 重复 &#39;a&#39; 一次, 字符串可变为 &amp;quot;aa&amp;quot;。

输入:
s = &amp;quot;ab&amp;quot;
p = &amp;quot;.*&amp;quot;
输出: true
解释: &amp;quot;.*&amp;quot; 表示可匹配零个或多个(&#39;*&#39;)任意字符(&#39;.&#39;)。

输入:
s = &amp;quot;aab&amp;quot;
p = &amp;quot;c*a*b&amp;quot;
输出: true
解释: &#39;c&#39; 可以不被重复, &#39;a&#39; 可以被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。


输入:
s = &amp;quot;mississippi&amp;quot;
p = &amp;quot;mis*is*p*.&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isMatch(s string, p string) bool {
    if p == &amp;quot;.*&amp;quot; {
        return true
    }
    if s == p {
        return true
    }
    if p == &amp;quot;&amp;quot; {
        return false
    }
    return match(s, p, 0, 0)
}

func match(s, p string, strIndex, patIndex int) bool {
    if patIndex == len(p) {
        return strIndex == len(s)
    }else {
        //第二个字符为*
        if patIndex &amp;lt; len(p) -1 &amp;amp;&amp;amp; p[patIndex+1:patIndex+2]== &amp;quot;*&amp;quot;{
            //若第一个字符匹配，则继续匹配后续；若第一个字符不匹配，正则后移两位
            if strIndex &amp;lt; len(s) &amp;amp;&amp;amp;
                (p[patIndex:patIndex+1] == &amp;quot;.&amp;quot;||s[strIndex:strIndex+1]==p[patIndex:patIndex+1]) {
                return match(s,p,strIndex,patIndex+2) || 
                       match(s,p,strIndex+1,patIndex)|| 
                       match(s,p,strIndex+1,patIndex+2)
            }else {
                return match(s,p,strIndex,patIndex+2)
            }
        }else if strIndex&amp;lt; len(s) &amp;amp;&amp;amp; 
        (p[patIndex:patIndex+1]==&amp;quot;.&amp;quot; || s[strIndex:strIndex+1]==p[patIndex:patIndex+1]){
            return match(s, p, strIndex+1, patIndex+1)
        }
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/regular-expression-matching/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>回文数</title>
            <link>http://blog.flywithme.top/2019/03-10/palindromeNumber/</link>
            <pubDate>Sun, 10 Mar 2019 20:35:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/palindromeNumber/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 121
输出: true


输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isPalindrome(x int) bool {
    if x &amp;lt; 0  {
        return false
    }
    if x %10 == 0 &amp;amp;&amp;amp; x != 0 {
        return false
    }
    result := 0

    for x &amp;gt; result {
        result = result*10 + x%10
        x = x/10
    }
    if result == x || x == result/10{
         return true
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>字符串转换整数 (atoi)</title>
            <link>http://blog.flywithme.top/2019/03-10/atoi/</link>
            <pubDate>Sun, 10 Mar 2019 17:53:22 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/atoi/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。
   首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
   当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
   该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
   注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
   在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;leetCode的题目测试用例有问题。不要太在意&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;42&amp;quot;
输出: 42


输入: &amp;quot;   -42&amp;quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

输入: &amp;quot;4193 with words&amp;quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。

输入: &amp;quot;words and 987&amp;quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。

输入: &amp;quot;-91283472332&amp;quot;
输出: -2147483648
解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。    
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//去除空格，判断首字母是否是-，然后开始遍历字符串，是数字串则转换，否则退出


func myAtoi(str string) int {
    negative := 1
    str = strings.TrimSpace(str)
    if strings.HasPrefix(str,&amp;quot;-&amp;quot;){
        negative = -1
        str = str[1:]
    }
    if str == &amp;quot;&amp;quot; {
        return 0
    }

    result := 0
    for _,v := range str {
        value := 0
        switch v {
        case &#39;0&#39;:
            value = 0
        case &#39;1&#39;:
            value = 1
        case &#39;2&#39;:
            value = 2
        case &#39;3&#39;:
            value = 3
        case &#39;4&#39;:
            value = 4
        case &#39;5&#39;:
            value = 5
        case &#39;6&#39;:
            value = 6
        case &#39;7&#39;:
            value = 7
        case &#39;8&#39;:
            value = 8
        case &#39;9&#39;:
            value = 9
        default:
            break
        }
        if result &amp;gt; math.MaxInt32/10 {
            if negative == -1{
                result = math.MinInt32
                negative = 1
            }else {
                result = math.MaxInt32
            }
            break
        }
        result = 10*result + value
    }
    return result*negative
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/string-to-integer-atoi/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Reverse Integer 整数反转</title>
            <link>http://blog.flywithme.top/2019/03-10/Reverse-Integer/</link>
            <pubDate>Sun, 10 Mar 2019 17:42:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/Reverse-Integer/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。
 请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321


输入: -123
输出: -321

输入: 1534236469
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func reverse(x int) int {
    result := 0
    negative := false
    if x &amp;lt; 0 {
        negative = true
        x = -x
    }
    for  x &amp;gt; 0 {
        result = result * 10 + x%10
        x = x/10
    }
    if negative {
        result = - result
    }
    if result &amp;gt; math.MaxInt32 || result &amp;lt; math.MinInt32 {
        return 0
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-integer/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Z 字形变换</title>
            <link>http://blog.flywithme.top/2019/03-09/zigzag-conversion/</link>
            <pubDate>Sat, 09 Mar 2019 14:57:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-09/zigzag-conversion/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
   比如输入字符串为 &amp;ldquo;LEETCODEISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;rdquo;LCIRETOESIIGEDHN&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;

&lt;p&gt;string convert(string s, int numRows);&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 3
输出: &amp;quot;LCIRETOESIIGEDHN&amp;quot;


输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 4
输出: &amp;quot;LDREOEIIECIHNTSG&amp;quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;解题时把结果看成一个长度为numRows的字符串数组，根据Z字结构，判断插入条件，取模为0时必插入，
  不为0时，需要在line和row之和等于numRows-1时插入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func convert(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    if len(s) &amp;lt;= numRows {
        return s
    }
    list := make([]string,numRows)
    index := 0
    left := 0
    for left &amp;lt; len(s){
        for i := 0;i &amp;lt; numRows; i ++ {
            if left &amp;gt;= len(s) {
                break
            }
            j := index%(numRows - 1)
            if j == 0 {
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else if i == numRows - 1 - j{
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }
        }
        index++
    }
    return strings.Join(list,&amp;quot;&amp;quot;)
}

格式化输出
func convertFormat(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    if len(s) &amp;lt;= numRows {
        return s
    }
    list := make([]string,numRows)
    index := 0
    left := 0
    for left &amp;lt; len(s){
        for i := 0;i &amp;lt; numRows; i ++ {
            if left &amp;gt;= len(s) {
                break
            }
            j := index%(numRows - 1)
            if j == 0 {
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else if i == numRows - 1 - j{
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else {
                item := list[i]
                item = item + &amp;quot; &amp;quot;
                list[i] = item
            }
        }
        index++
    }
    return strings.Join(list,&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-02&#34;&gt;Solution 02&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func convert1(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    bLen := math.Min(float64(numRows),float64(len(s)))
    bytes := make([][]byte,int(bLen))
    goingDownFlag := false
    curRow := 0
    for _,v := range s {
        bytes[curRow] =  append(bytes[curRow],byte(v))
        if curRow == 0 || curRow == numRows - 1 {
            goingDownFlag = !goingDownFlag
        }
        if goingDownFlag {
            curRow++
        }else {
            curRow--
        }
    }
    result := &amp;quot;&amp;quot;
    for _,v := range bytes {
        result += string(v)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/zigzag-conversion&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Longest Palindromic Substring 最长回文子串</title>
            <link>http://blog.flywithme.top/2019/03-08/Palindromic/</link>
            <pubDate>Fri, 08 Mar 2019 19:25:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/Palindromic/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
   回文是一个正读和反读都相同的字符串，例如，&amp;rdquo;aba&amp;rdquo; 是回文，而 &amp;ldquo;abc&amp;rdquo; 不是。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;babad&amp;quot;
输出: &amp;quot;bab&amp;quot;
注意: &amp;quot;aba&amp;quot; 也是一个有效答案。

输入: &amp;quot;cbbd&amp;quot;
输出: &amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func longestPalindrome(s string) string {
    if s == &amp;quot;&amp;quot; {
        return &amp;quot;&amp;quot;
    }
    start,end := 0,0
    for i := 0; i &amp;lt; len(s); i ++ {
        len1 := expandAroundCenter(s,i,i)
        len2 := expandAroundCenter(s,i, i +1)
        len := maxInt(len1,len2)
        if len &amp;gt; end-start{
            start = i - (len - 1)/2
            end = i + len/2
        }
    }
    return s[start:end+1]
}

func expandAroundCenter(s string,left,right int)int  {
    L,R := left,right
    for L &amp;gt;= 0 &amp;amp;&amp;amp; R &amp;lt; len(s) &amp;amp;&amp;amp; s[L] == s[R]{
        L--
        R++
    }
    return R-L-1
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/longest-palindromic-substring/&#34;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>寻找两个有序数组的中位数</title>
            <link>http://blog.flywithme.top/2019/03-08/findmedian/</link>
            <pubDate>Fri, 08 Mar 2019 16:12:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/findmedian/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br /&gt;
   请你找出这两个有序数组的中位数。&lt;br /&gt;
   要求算法的&lt;font color=red size=5&gt;时间复杂度为 O(log(m + n))&lt;/font&gt;&lt;br /&gt;
   你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Input:nums1 = [1, 3]
      nums2 = [2]
Output: 2.0

Input: nums1 = [1, 2]
       nums2 = [3, 4]
Output:  (2 + 3)/2 = 2.5


Input: nums1 = [1,2,3,7,8,9,10]
       nums2 = [-2,-1,4,5,7,9]
Output:  5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;分割两个数组，分为leftA,rightA, leftB,rightB,
 leftA+leftB的长度等于rightA+rightB
 左边数组的最大值等于右边数组的最小值时，就找到了中间值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m := len(nums1)
    n := len(nums2)
    if m == 0 {
        return medianof(nums2)
    }
    if n == 0 {
        return medianof(nums1)
    }
    if m &amp;gt; n { //确保nums1数组长度比nums2边短
        findMedianSortedArrays(nums2,nums1)
    }
    halflen := (m + n +1)/2
    iMin := 0 //nums1的起始分割点 iMin &amp;lt; m的总长
    iMax := m

    //使用二分法查找分割点
    for iMin &amp;lt;= iMax {
        i := (iMin + iMax)/2
        j := halflen - i
        if i &amp;lt; iMax &amp;amp;&amp;amp; nums2[j - 1] &amp;gt; nums1[i] {
            //取值位置偏小，需要右移最小位置
            iMin =  i + 1
        }else if i &amp;gt; iMin &amp;amp;&amp;amp;  nums1[i -1] &amp;gt; nums2[j] {
            iMax = i -1   //i的位置太大
        }else {
            maxLeft := 0
            if i == 0 {
                maxLeft = nums2[j - 1]
            }else if j == 0 {
                maxLeft = nums1[i -1]
            }else {
                maxLeft = maxInt(nums1[i-1],nums2[j-1])
            }
            if (m + n)%2 ==1 {
                return float64(maxLeft)
            }

            minRight := 0
            if i == m {
                minRight = nums2[j]
            }else if j == n {
                minRight = nums1[i]
            }else {
                minRight = minInt(nums1[i],nums2[j])
            }
            return float64(maxLeft +minRight)/2.0
        }
    }
    return 0.0
}

func medianof(nums []int)float64  {
    l := len(nums)
    if l == 0 {
        return 0
    }
    if l%2 == 0 {
        return float64(nums[l/2-1]+nums[l/2])/2.0
    }
    return float64(nums[l/2])
}

func minInt(a,b int)int  {
    if a &amp;gt; b {
        return b
    }
    return a
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/median-of-two-sorted-arrays/&#34;&gt; Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Add Strings 字符串相加</title>
            <link>http://blog.flywithme.top/2019/03-07/addtwostring/</link>
            <pubDate>Thu, 07 Mar 2019 21:21:38 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/addtwostring/</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#note&#34;&gt;Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#注意&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution&#34;&gt;Solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution-02&#34;&gt;Solution 02&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;h6 id=&#34;description&#34;&gt;Description&lt;/h6&gt;

&lt;p&gt;Given two non-negative integers num1 and num2 represented as string,
   return the sum of num1 and num2.&lt;br /&gt;
   给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。&lt;/p&gt;

&lt;h6 id=&#34;note&#34;&gt;Note&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;The length of both num1 and num2 is &amp;lt; 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Both num1 and num2 contains only digits 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;both num1 and num2 does not contain any leading zero.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;注意&#34;&gt;注意&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;num1 和num2 的长度都小于 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都只包含数字 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都不包含任何前导零。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;example&#34;&gt;Example&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: 579
Explanation: &amp;quot;123 + &amp;quot;456&amp;quot; = &amp;quot;579&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution&#34;&gt;Solution&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;//直接处理字符串相加
func addTwoString1(num1 string,num2 string)string  {
    carry := 0
    maxLen := maxInt(len(num2),len(num1))
    result := make([]byte,maxLen+1)
    for i := 0 ; i &amp;lt; maxLen; i ++ {
        sum := carry
        if len(num1) &amp;gt; i {
            v1 ,_ := strconv.Atoi(string(num1[len(num1) -i -1]))
            sum += v1
        }
        if len(num2) &amp;gt; i {
            v2 ,_ := strconv.Atoi(string(num2[len(num2) -i -1]))
            sum += v2
        }
        carry = sum/10
        result[maxLen - i] = []byte(strconv.Itoa(sum%10))[0]
    }
    if carry &amp;gt; 0 {
        result[0] = []byte(strconv.Itoa(carry))[0]
    }else {
        return string(result[1:])
    }
    return  string(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution-02&#34;&gt;Solution 02&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val  int
    Next *ListNode
}


//两字符串相加
func addTwoString(num1 string,num2 string)string  {
    l1 := makeListNode(num1)
    l2 := makeListNode(num2)
    l3 := addTwoNumbers(l1,l2)
    return  listNodeToString(l3)
}

//字符串转换为数字链表
func makeListNode(s string)*ListNode  {
    node := new(ListNode)
    current := node
    for i := len(s) - 1; i &amp;gt;=0; i -- {
        current.Next = new(ListNode)
        current.Val ,_ = strconv.Atoi(string(s[i]))
        current = current.Next
    }
    return node
}

//数字链表转为字符串
func listNodeToString(l *ListNode)string  {
    result := &amp;quot;&amp;quot;
    for l != nil {
        if l.Next != nil || l.Val != 0 {
            result  = fmt.Sprintf(&amp;quot;%d%s&amp;quot;,l.Val,result)
        }
        l = l.Next
    }
    return result
}

 //计算结果   
func addTwoNumbers(l1 *ListNode,l2 *ListNode) *ListNode  {
    head := &amp;amp;ListNode{0,nil}
    current := head
    carry := 0
    for l1 != nil || l2 != nil || carry &amp;gt; 0 {
        sum := carry
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        carry = sum /10
        current.Next = new(ListNode)
        current.Next.Val = sum%10
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>字符串相乘</title>
            <link>http://blog.flywithme.top/2019/03-07/multiplystrings/</link>
            <pubDate>Thu, 07 Mar 2019 19:29:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/multiplystrings/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given two non-negative integers num1 and num2 represented as strings,
return the product of num1 and num2, also represented as a string..
  Note:
  The length of both num1 and num2 is &amp;lt; 110.
  Both num1 and num2 contain only digits 0-9.
  Both num1 and num2 do not contain any leading zero, except the number 0 itself.
  You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;p&gt;说明：
  num1 和 num2 的长度小于110。
  num1 和 num2 只包含数字 0-9。
  num1 和 num2 均不以零开头，除非是数字 0 本身。
  不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot;
Output: &amp;quot;6&amp;quot;

Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: &amp;quot;56088&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>最长无重复字符的子串</title>
            <link>http://blog.flywithme.top/2019/03-07/Longest-Substring-Without-Repeating-Characters-/</link>
            <pubDate>Thu, 07 Mar 2019 18:32:33 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/Longest-Substring-Without-Repeating-Characters-/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;给一个字符串，找出最长的非重复字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: &amp;quot;abcabcbb&amp;quot;
Output: 3 
Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. 

Input: &amp;quot;bbbbb&amp;quot;
Output: 1
Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.

Input: &amp;quot;pwwkew&amp;quot;
Output: 3
Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. 
             Note that the answer must be a substring, 
             &amp;quot;pwke&amp;quot; is a subsequence and not a substring.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func lengthOfLongestSubstring(s string) int {
    location := [256]int{} 
    for i := range location {
        location[i] = -1 
    }
    maxLen, left := 0, -1
    for i := 0; i &amp;lt; len(s); i++ {
        if location[s[i]] &amp;gt;= left {
            left = location[s[i]] +1
        } else if i + 1-left &amp;gt; maxLen {
            maxLen = i + 1 - left
        }
        location[s[i]] = i
    }

    return maxLen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;func lengthOfLongestSubstring(s string) int {
    max ,left := 0,-1
    c := [256]int{}
    for i := range c{
        c[i]= -1
    }
    for i := 0; i &amp;lt; len(s); i ++ {
        left = maxInt(left, c[s[i]])
        c[s[i]] = i
        max = maxInt(max,i-left)
    }
    return max
}

func maxInt(a, b int) int {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: &amp;quot;汉字要怎么处理是怎么样的&amp;quot;
Output: 8 
Explanation: The answer is &amp;quot;汉字要怎么处理是&amp;quot;, with the length of 8. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;  &lt;font size=3&gt;查询包含汉字的字符串需要使用golang的 &lt;code&gt;rune&lt;/code&gt; 关键字&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//带有汉字的最长不重复字符
func lengthOfLongestRunSubString(s string)int  {
    maxLen,left := 0,-1
    lastOccurred := make(map[rune]int)
    for i, ch := range []rune(s) {
        if lastI,ok := lastOccurred[ch];ok &amp;amp;&amp;amp; lastI &amp;gt;= left {
            left = lastOccurred[ch]
        }
        if i - left &amp;gt; maxLen {
            maxLen = i - left
        }
        lastOccurred[ch] = i
    }
    return maxLen
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Add Two Numbers 两个数字相加</title>
            <link>http://blog.flywithme.top/2019/03-07/addtwonum/</link>
            <pubDate>Thu, 07 Mar 2019 18:24:19 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/addtwonum/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single digit.
Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero,
except the number 0 itself.&lt;/p&gt;

&lt;p&gt;给两个非空链表，表示两个非负的整数，数字是以相反的顺序存储，每个节点包含一个数字。
求两个数字的和，并以链表的形式返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
Explanation: 342 + 465 = 807.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    head := &amp;amp;ListNode{0,nil}
    current := head
    carry := 0
    for l1 != nil || l2 != nil || carry &amp;gt; 0 {
        sum := carry
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        carry = sum/10
        current.Next = new(ListNode)
        current.Next.Val = sum%10
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两个数字字符串相加&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//转为链表相加
func addTwoString(num1 string,num2 string)string  {
    l1 := makeListNode(num1)
    l2 := makeListNode(num2)
    l3 := addTwoNumbers(l1,l2)
    return  listNodeToString(l3)
}

func makeListNode(s string)*ListNode  {
    node := new(ListNode)
    current := node
    for i := len(s) - 1; i &amp;gt;=0; i -- {
        current.Next = new(ListNode)
        current.Val ,_ = strconv.Atoi(string(s[i]))
        current = current.Next
    }
    return node
}

func listNodeToString(l *ListNode)string  {
    result := &amp;quot;&amp;quot;
    for l != nil {
        if l.Next != nil || l.Val != 0 {
            result  = fmt.Sprintf(&amp;quot;%d%s&amp;quot;,l.Val,result)
        }
        l = l.Next
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两个数字字符串相加2&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//字符串 数字相加
func addTwoString1(num1 string,num2 string)string  {
    carry := 0
    maxLen := maxInt(len(num2),len(num1))
    result := make([]byte,maxLen+1)
    for i := 0 ; i &amp;lt; maxLen; i ++ {
        sum := carry
        if len(num1) &amp;gt; i {
            v1 ,_ := strconv.Atoi(string(num1[len(num1) -i -1]))
            sum += v1
        }
        if len(num2) &amp;gt; i {
            v2 ,_ := strconv.Atoi(string(num2[len(num2) -i -1]))
            sum += v2
        }
        carry = sum/10
        result[maxLen - i] = []byte(strconv.Itoa(sum%10))[0]
    }
    if carry &amp;gt; 0 {
        result[0] = []byte(strconv.Itoa(carry))[0]
    }else {
        return string(result[1:])
    }
    return  string(result)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Two Sum 两数之和</title>
            <link>http://blog.flywithme.top/2019/03-07/leetcode_twosum/</link>
            <pubDate>Thu, 07 Mar 2019 18:12:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/leetcode_twosum/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;给一个整数数组，和一个目标值，查询数组中两个数之和为目标值的数据位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //使用空间换时间，查询之后放入map中，可以减少时间复杂度
func TwoSumMap1(nums []int,target int)[]int   {
    maps := map[int]int{}
    for i ,value := range  nums {
        member := target - value
        if j,ok := maps[member];ok  {
            return []int{j,i}
        }
        maps[value] = i
    }
    return nil
}

//双重遍历数组，拿数组中元素进行运算
 //耗时较多
 func twoSum(nums []int, target int) []int {
    for i := 0; i &amp;lt; len(nums);i ++ {
        for j := i +1; j &amp;lt; len(nums); j ++{
            if nums[i] + nums[j] == target {
                return []int{i,j}
            }
        }
    }
    return nil
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>go bin执行问题记录</title>
            <link>http://blog.flywithme.top/2019/02/24/gobin/</link>
            <pubDate>Sun, 24 Feb 2019 08:40:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/02/24/gobin/</guid>
            <description>&lt;p&gt;因为&lt;code&gt;${GOPATH}/bin&lt;/code&gt;目录下的执行文件无法被中断直接执行 需要Source之后才能使用，
只是在 &lt;code&gt;.bash_profile&lt;/code&gt;文件里如此设置 需要Source之后才能被命令行识别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOBIN=/Users/ori/go/bin
export PATH=$PATH:$GOBIN

export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
export  PATH=~/code/flutter/flutter/bin:$PATH

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最好的处理方式还是直接把&lt;code&gt;${GOPATH}/bin&lt;/code&gt;目录下的执行文件移动到go的Root的bin目录中更好&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mv $GOPATH/bin/** /usr/local/go/bin&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Nginx 配置 HTTPS 服务器</title>
            <link>http://blog.flywithme.top/2019/01/15/nginx/</link>
            <pubDate>Tue, 15 Jan 2019 14:38:32 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/01/15/nginx/</guid>
            <description>

&lt;p&gt;Nginx 配置 HTTPS 并不复杂，主要有两个步骤：签署第三方可信任的 SSL 证书 和 配置 HTTPS&lt;/p&gt;

&lt;p&gt;我的证书是在腾讯云上申请的&lt;a href=&#34;https://console.cloud.tencent.com/ssl&#34;&gt;地址&lt;/a&gt;
 &lt;img src=&#34;http://blog.flywithme.top/sources/nginx/FF1BD64F-62AD-4FDB-AE5A-B51C5FBB125C.png&#34; alt=&#34;cer&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;nginx-conf-配置内容&#34;&gt;nginx.conf 配置内容&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;
	
   upstream move{
        server 127.0.0.1:9120;
   }


   server {
        listen       80;
        listen       443 ssl;
	ssl_certificate   certificate_bundle.crt;
	ssl_certificate_key  certificate.key;

	client_max_body_size 20M;
    client_body_buffer_size 1M;
    #charset koi8-r;

    #access_log  logs/host.access.log  main;
        

	location /(css|js|fonts|img)/ {
        	access_log off;
        	expires 1d;
       	 	root &amp;quot;/root/vue-admin/dist&amp;quot;;
        	try_files $uri @backend;
	}

	location / {
        	try_files /_not_exists_ @backend;
	}

	location @backend {
        	proxy_set_header X-Forwarded-For $remote_addr;
       	 	proxy_set_header Host            $http_host;
        	proxy_pass http://127.0.0.1:9801;
    	}	

	location /im/ {
    		client_max_body_size 20M;
   		proxy_pass http://127.0.0.1:9002;
	}

  }
 

    include /etc/nginx/conf.d/*.conf;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>mongodb 维护小记</title>
            <link>http://blog.flywithme.top/2019/01/13/mongodump/</link>
            <pubDate>Sun, 13 Jan 2019 10:45:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/01/13/mongodump/</guid>
            <description>

&lt;h3 id=&#34;数据库迁移&#34;&gt;数据库迁移&lt;/h3&gt;

&lt;p&gt;把当前服务器备份下来的数据迁移到另一个host服务器上，目录Path是当前备份的根目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodump -u user -p pass -d doc_manager -o doc.dmp
mongorestore -h host ./doc.dmp/doc_manager -u auth -p pass -d docmanager
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;本地处理&#34;&gt;本地处理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//              dump命令             数据库用户 密码     数据库名字      备份目录
/usr/local/mongodb/bin/mongodump -u user -p pass -d docmanager  -o ../dump

//              restore命令             数据库用户名 密码   数据库名字   备份目录      覆盖
/usr/local/mongodb/bin/mongorestore -u 用户名 -p 密码 -d docmanager doc_manager --drop

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;创建数据库管理员&#34;&gt;创建数据库管理员&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//进入mongo命令行
mongo
db.auth(&amp;quot;use&amp;quot;,&amp;quot;pass&amp;quot;)

use log
db.createUser(
		{
			user: &amp;quot;user&amp;quot;,
			pwd: &amp;quot;pass&amp;quot;,
			roles: [{ role: &amp;quot;readWrite&amp;quot;, db: &amp;quot;log&amp;quot; }]
		}
	)



&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;错误处理&#34;&gt;错误处理&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//   mongodb非正常关闭后
about to fork child process, waiting until server is ready for connections.
forked process: 9936
ERROR: child process failed, exited with error number 48

//处理方式
//删除mongo数据库文件夹中的 
killall mongod
rm /data/mongo/mongod.lock

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
