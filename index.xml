<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Wed, 13 Mar 2019 13:27:30 CST</updated>
        
        <item>
            <title>最接近的三数之和</title>
            <link>http://blog.flywithme.top/2019/03-13/3sumclosest/</link>
            <pubDate>Wed, 13 Mar 2019 13:27:30 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sumclosest/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包括 n 个整数的数组 &lt;code&gt;nums&lt;/code&gt; 和 一个目标值 &lt;code&gt;target&lt;/code&gt;。找出 &lt;code&gt;nums&lt;/code&gt; 中的三个整数，
使得它们的和与 &lt;code&gt;target&lt;/code&gt; 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSumClosest(nums []int, target int) int {
    closestSum := math.MaxInt32
    sort.Ints(nums)
    for i := 0;i &amp;lt; len(nums)-2;i ++ {
        left,right := i +1,len(nums)-1
        for left &amp;lt; right {
            sum := nums[i] + nums[left] + nums[right]
            if numAbs(closestSum,target) &amp;gt; numAbs(sum,target) {
                closestSum = sum
            }
            if sum &amp;lt; target {
                left++
            }else if sum &amp;gt; target {
                right--
            }else {
                return sum
            }
        }
    }
    return closestSum
}

func numAbs(a,b int)int  {
    if a &amp;gt; b {
        return a - b
    }
    return b - a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum-closest/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>三数之和 3Sum</title>
            <link>http://blog.flywithme.top/2019/03-13/3sum/</link>
            <pubDate>Wed, 13 Mar 2019 01:42:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/3sum/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，
使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;Note&lt;/h5&gt;

&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func threeSum(nums []int) [][]int {
    return threeSum1(nums,0)
}

func sortNums(nums []int)  {
    for i := 0;i &amp;lt; len(nums);i ++ {
        for j := i +1 ; j &amp;lt; len(nums);j ++ {
            if nums[i] &amp;gt; nums[j] {
                nums[i],nums[j] = nums[j],nums[i]
            }
        }
    }
}

func threeSum1(nums []int ,target int) [][]int {
    sortNums(nums)
    var list [][]int
    maps := make(map[int]int,len(nums))
    for i,v := range nums{
        maps[v] = i
    }
    valuess := make([]int,3)
    maps2 := map[string]bool{}
    for i := 0 ; i &amp;lt; len(nums); i ++ {
        if nums[i] &amp;gt; target {
            break
        }
        for j := i + 1; j &amp;lt; len(nums); j ++ {
            member := target - nums[i] - nums[j]
            if k,ok := maps[member];ok &amp;amp;&amp;amp; k != i &amp;amp;&amp;amp; k != j {
                valuess = []int{member,nums[i],nums[j]}
                sortNums(valuess)
                key := fmt.Sprintf(&amp;quot;%d%d%d&amp;quot;,valuess[0],valuess[1],valuess[2])
                if _,ok := maps2[key];ok {
                    continue
                }else {
                    maps2[key] = true
                    list = append(list, []int{valuess[0],valuess[1],valuess[2]})
                }
            }
        }
    }
    return list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>最长公共前缀</title>
            <link>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</link>
            <pubDate>Wed, 13 Mar 2019 01:23:07 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/longestCommonPrefix/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;ldquo;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]
输出: &amp;quot;&amp;quot;
解释: 输入不存在公共前缀。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return &amp;quot;&amp;quot;
    }
    prefix := strs[0]
    for i := 1;i &amp;lt; len(strs);i ++ {
        prefix = comparePrefix(prefix,strs[i])
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

func comparePrefix(left ,right string)string  {
    if len(left)&amp;gt;len(right) {
        left,right = right,left
    }
    value := &amp;quot;&amp;quot;
    for i := range left {
        if left[0:i+1] == right[0:i+1] {
            value = left[0:i+1]
        }else {
            break
        }
    }
    return value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-common-prefix/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>罗马数字转整数</title>
            <link>http://blog.flywithme.top/2019/03-13/roman2int/</link>
            <pubDate>Wed, 13 Mar 2019 00:57:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-13/roman2int/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
 - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/p&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;III&amp;quot;
输出: 3

输入: &amp;quot;IV&amp;quot;
输出: 4

输入: &amp;quot;IX&amp;quot;
输出: 9

输入: &amp;quot;LVIII&amp;quot;
输出: 58
解释: L = 50, V= 5, III = 3.

输入: &amp;quot;MCMXCIV&amp;quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;var (
    romanMap = map[string]int{
        &amp;quot;I&amp;quot;:1,&amp;quot;IV&amp;quot;:4,&amp;quot;V&amp;quot;:5,&amp;quot;IX&amp;quot;:9,
        &amp;quot;X&amp;quot;:10,&amp;quot;XL&amp;quot;:40,&amp;quot;L&amp;quot;:50,&amp;quot;XC&amp;quot;:90,
        &amp;quot;C&amp;quot;:100,&amp;quot;CD&amp;quot;:400,&amp;quot;D&amp;quot;:500,
        &amp;quot;CM&amp;quot;:900,&amp;quot;M&amp;quot;:1000,
    }
)

func romanToInt(s string) int {
    result := 0
    for i := 0; i &amp;lt; len(s);i ++ {
        value := s[i:i+1]
        if _,ok := romanMap[value];!ok {
            return 0
        }
        if i &amp;lt; len(s) - 1 {
            value2 := s[i+1:i +2]
            if romanMap[value2] &amp;gt; romanMap[value] {
                result += romanMap[value+value2]
                i = i+1
                continue
            }
        }
        result += romanMap[value]
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/roman-to-integer&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>整数转罗马数字</title>
            <link>http://blog.flywithme.top/2019/03-12/int2roman/</link>
            <pubDate>Tue, 12 Mar 2019 23:32:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-12/int2roman/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
 - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/p&gt;

&lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 3
输出: &amp;quot;III&amp;quot;

输入: 4
输出: &amp;quot;IV&amp;quot;

输入: 58
输出: &amp;quot;LVIII&amp;quot;
解释: L = 50, V = 5, III = 3.

输入: 1994
输出: &amp;quot;MCMXCIV&amp;quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//遍历出1-10，10—100，100-1000的特殊点
var (
    romanMap = map[int]string{
        1:&amp;quot;I&amp;quot;,2:&amp;quot;II&amp;quot;,3:&amp;quot;III&amp;quot;,4:&amp;quot;IV&amp;quot;,5:&amp;quot;V&amp;quot;,6:&amp;quot;VI&amp;quot;,7:&amp;quot;VII&amp;quot;,8:&amp;quot;VIII&amp;quot;,9:&amp;quot;IX&amp;quot;,
        10:&amp;quot;X&amp;quot;,20:&amp;quot;XX&amp;quot;,30:&amp;quot;XXX&amp;quot;,40:&amp;quot;XL&amp;quot;,50:&amp;quot;L&amp;quot;,60:&amp;quot;LX&amp;quot;,70:&amp;quot;LXX&amp;quot;,80:&amp;quot;LXXX&amp;quot;,90:&amp;quot;XC&amp;quot;,
        100:&amp;quot;C&amp;quot;,200:&amp;quot;CC&amp;quot;,300:&amp;quot;CCC&amp;quot;,400:&amp;quot;CD&amp;quot;,500:&amp;quot;D&amp;quot;,600:&amp;quot;DC&amp;quot;,700:&amp;quot;DCC&amp;quot;,800:&amp;quot;DCCC&amp;quot;,900:&amp;quot;CM&amp;quot;,
        1000:&amp;quot;M&amp;quot;,2000:&amp;quot;MM&amp;quot;,3000:&amp;quot;MMM&amp;quot;}
)

func intToRoman(num int) string {
    if num &amp;gt;3999 || num &amp;lt; 1 {
        return &amp;quot;&amp;quot;
    }
    result := &amp;quot;&amp;quot;
    flag := 1

    for num &amp;gt; 0 {
        value := num%10
        result = romanMap[value*flag] + result
        num,flag = num/10,flag*10
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/integer-to-roman/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>盛最多水的容器 Container With Most Water</title>
            <link>http://blog.flywithme.top/2019/03-12/containermostwater/</link>
            <pubDate>Tue, 12 Mar 2019 18:23:25 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-12/containermostwater/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。
在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2。
 &lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/question_11.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,8,6,2,5,4,8,3,7]
Output: 49
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//01 暴力破解
func maxArea(height []int) int {
    maxArea := 0
    for i := 0; i &amp;lt; len(height);i ++ {
        for j := i +1;j &amp;lt; len(height); j ++ {
            maxArea = maxInt(maxArea,minInt(height[i],height[j]) *(j - i))
        }
    }
    return maxArea
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
func minInt(a,b int)int  {
    if a &amp;gt; b {
        return b
    }
    return a
}

//02 双指针计算
func maxArea1(height []int) int {
    maxArea := 0
    left := 0
    right := len(height)-1
    for left &amp;lt; right {
        maxArea = maxInt(maxArea,minInt(height[left],height[right])*(right - left))
        if height[left]&amp;lt;height[right] {
            left++
        }else {
            right--
        }
    }
    return maxArea
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Regular Expression Matching</title>
            <link>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</link>
            <pubDate>Sun, 10 Mar 2019 20:52:09 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/Regular-Expression-Matching/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;.&#39; 匹配任意单个字符。
&#39;*&#39; 匹配零个或多个前面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:
   s 可能为空，且只包含从 a-z 的小写字母。
   p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a&amp;quot;
输出: false
解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。


输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a*&amp;quot;
输出: true
解释: &#39;*&#39; 代表可匹配零个或多个前面的元素, 即可以匹配 &#39;a&#39; 。因此, 重复 &#39;a&#39; 一次, 字符串可变为 &amp;quot;aa&amp;quot;。

输入:
s = &amp;quot;ab&amp;quot;
p = &amp;quot;.*&amp;quot;
输出: true
解释: &amp;quot;.*&amp;quot; 表示可匹配零个或多个(&#39;*&#39;)任意字符(&#39;.&#39;)。

输入:
s = &amp;quot;aab&amp;quot;
p = &amp;quot;c*a*b&amp;quot;
输出: true
解释: &#39;c&#39; 可以不被重复, &#39;a&#39; 可以被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。


输入:
s = &amp;quot;mississippi&amp;quot;
p = &amp;quot;mis*is*p*.&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isMatch(s string, p string) bool {
    if p == &amp;quot;.*&amp;quot; {
        return true
    }
    if s == p {
        return true
    }
    if p == &amp;quot;&amp;quot; {
        return false
    }
    return match(s, p, 0, 0)
}

func match(s, p string, strIndex, patIndex int) bool {
    if patIndex == len(p) {
        return strIndex == len(s)
    }else {
        //第二个字符为*
        if patIndex &amp;lt; len(p) -1 &amp;amp;&amp;amp; p[patIndex+1:patIndex+2]== &amp;quot;*&amp;quot;{
            //若第一个字符匹配，则继续匹配后续；若第一个字符不匹配，正则后移两位
            if strIndex &amp;lt; len(s) &amp;amp;&amp;amp;
                (p[patIndex:patIndex+1] == &amp;quot;.&amp;quot;||s[strIndex:strIndex+1]==p[patIndex:patIndex+1]) {
                return match(s,p,strIndex,patIndex+2) || 
                       match(s,p,strIndex+1,patIndex)|| 
                       match(s,p,strIndex+1,patIndex+2)
            }else {
                return match(s,p,strIndex,patIndex+2)
            }
        }else if strIndex&amp;lt; len(s) &amp;amp;&amp;amp; 
        (p[patIndex:patIndex+1]==&amp;quot;.&amp;quot; || s[strIndex:strIndex+1]==p[patIndex:patIndex+1]){
            return match(s, p, strIndex+1, patIndex+1)
        }
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/regular-expression-matching/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>回文数</title>
            <link>http://blog.flywithme.top/2019/03-10/palindromeNumber/</link>
            <pubDate>Sun, 10 Mar 2019 20:35:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/palindromeNumber/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 121
输出: true


输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isPalindrome(x int) bool {
    if x &amp;lt; 0  {
        return false
    }
    if x %10 == 0 &amp;amp;&amp;amp; x != 0 {
        return false
    }
    result := 0

    for x &amp;gt; result {
        result = result*10 + x%10
        x = x/10
    }
    if result == x || x == result/10{
         return true
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>字符串转换整数 (atoi)</title>
            <link>http://blog.flywithme.top/2019/03-10/atoi/</link>
            <pubDate>Sun, 10 Mar 2019 17:53:22 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/atoi/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。
   首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
   当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
   该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
   注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
   在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;leetCode的题目测试用例有问题。不要太在意&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;42&amp;quot;
输出: 42


输入: &amp;quot;   -42&amp;quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

输入: &amp;quot;4193 with words&amp;quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。

输入: &amp;quot;words and 987&amp;quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。

输入: &amp;quot;-91283472332&amp;quot;
输出: -2147483648
解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。    
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//去除空格，判断首字母是否是-，然后开始遍历字符串，是数字串则转换，否则退出


func myAtoi(str string) int {
    negative := 1
    str = strings.TrimSpace(str)
    if strings.HasPrefix(str,&amp;quot;-&amp;quot;){
        negative = -1
        str = str[1:]
    }
    if str == &amp;quot;&amp;quot; {
        return 0
    }

    result := 0
    for _,v := range str {
        value := 0
        switch v {
        case &#39;0&#39;:
            value = 0
        case &#39;1&#39;:
            value = 1
        case &#39;2&#39;:
            value = 2
        case &#39;3&#39;:
            value = 3
        case &#39;4&#39;:
            value = 4
        case &#39;5&#39;:
            value = 5
        case &#39;6&#39;:
            value = 6
        case &#39;7&#39;:
            value = 7
        case &#39;8&#39;:
            value = 8
        case &#39;9&#39;:
            value = 9
        default:
            break
        }
        if result &amp;gt; math.MaxInt32/10 {
            if negative == -1{
                result = math.MinInt32
                negative = 1
            }else {
                result = math.MaxInt32
            }
            break
        }
        result = 10*result + value
    }
    return result*negative
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/string-to-integer-atoi/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Reverse Integer 整数反转</title>
            <link>http://blog.flywithme.top/2019/03-10/Reverse-Integer/</link>
            <pubDate>Sun, 10 Mar 2019 17:42:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-10/Reverse-Integer/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;

&lt;h5 id=&#34;note&#34;&gt;NOTE&lt;/h5&gt;

&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。
 请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321


输入: -123
输出: -321

输入: 1534236469
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func reverse(x int) int {
    result := 0
    negative := false
    if x &amp;lt; 0 {
        negative = true
        x = -x
    }
    for  x &amp;gt; 0 {
        result = result * 10 + x%10
        x = x/10
    }
    if negative {
        result = - result
    }
    if result &amp;gt; math.MaxInt32 || result &amp;lt; math.MinInt32 {
        return 0
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-integer/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Z 字形变换</title>
            <link>http://blog.flywithme.top/2019/03-09/zigzag-conversion/</link>
            <pubDate>Sat, 09 Mar 2019 14:57:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-09/zigzag-conversion/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
   比如输入字符串为 &amp;ldquo;LEETCODEISHIRING&amp;rdquo; 行数为 3 时，排列如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;rdquo;LCIRETOESIIGEDHN&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;

&lt;p&gt;string convert(string s, int numRows);&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 3
输出: &amp;quot;LCIRETOESIIGEDHN&amp;quot;


输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 4
输出: &amp;quot;LDREOEIIECIHNTSG&amp;quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;解题时把结果看成一个长度为numRows的字符串数组，根据Z字结构，判断插入条件，取模为0时必插入，
  不为0时，需要在line和row之和等于numRows-1时插入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func convert(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    if len(s) &amp;lt;= numRows {
        return s
    }
    list := make([]string,numRows)
    index := 0
    left := 0
    for left &amp;lt; len(s){
        for i := 0;i &amp;lt; numRows; i ++ {
            if left &amp;gt;= len(s) {
                break
            }
            j := index%(numRows - 1)
            if j == 0 {
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else if i == numRows - 1 - j{
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }
        }
        index++
    }
    return strings.Join(list,&amp;quot;&amp;quot;)
}

格式化输出
func convertFormat(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    if len(s) &amp;lt;= numRows {
        return s
    }
    list := make([]string,numRows)
    index := 0
    left := 0
    for left &amp;lt; len(s){
        for i := 0;i &amp;lt; numRows; i ++ {
            if left &amp;gt;= len(s) {
                break
            }
            j := index%(numRows - 1)
            if j == 0 {
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else if i == numRows - 1 - j{
                item := list[i]
                item = item + string(s[left])
                left++
                list[i] = item
            }else {
                item := list[i]
                item = item + &amp;quot; &amp;quot;
                list[i] = item
            }
        }
        index++
    }
    return strings.Join(list,&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution-02&#34;&gt;Solution 02&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func convert1(s string, numRows int) string {
    if numRows == 1 {
        return s
    }
    bLen := math.Min(float64(numRows),float64(len(s)))
    bytes := make([][]byte,int(bLen))
    goingDownFlag := false
    curRow := 0
    for _,v := range s {
        bytes[curRow] =  append(bytes[curRow],byte(v))
        if curRow == 0 || curRow == numRows - 1 {
            goingDownFlag = !goingDownFlag
        }
        if goingDownFlag {
            curRow++
        }else {
            curRow--
        }
    }
    result := &amp;quot;&amp;quot;
    for _,v := range bytes {
        result += string(v)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/zigzag-conversion&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Longest Palindromic Substring 最长回文子串</title>
            <link>http://blog.flywithme.top/2019/03-08/Palindromic/</link>
            <pubDate>Fri, 08 Mar 2019 19:25:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/Palindromic/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
   回文是一个正读和反读都相同的字符串，例如，&amp;rdquo;aba&amp;rdquo; 是回文，而 &amp;ldquo;abc&amp;rdquo; 不是。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;babad&amp;quot;
输出: &amp;quot;bab&amp;quot;
注意: &amp;quot;aba&amp;quot; 也是一个有效答案。

输入: &amp;quot;cbbd&amp;quot;
输出: &amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func longestPalindrome(s string) string {
    if s == &amp;quot;&amp;quot; {
        return &amp;quot;&amp;quot;
    }
    start,end := 0,0
    for i := 0; i &amp;lt; len(s); i ++ {
        len1 := expandAroundCenter(s,i,i)
        len2 := expandAroundCenter(s,i, i +1)
        len := maxInt(len1,len2)
        if len &amp;gt; end-start{
            start = i - (len - 1)/2
            end = i + len/2
        }
    }
    return s[start:end+1]
}

func expandAroundCenter(s string,left,right int)int  {
    L,R := left,right
    for L &amp;gt;= 0 &amp;amp;&amp;amp; R &amp;lt; len(s) &amp;amp;&amp;amp; s[L] == s[R]{
        L--
        R++
    }
    return R-L-1
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/longest-palindromic-substring/&#34;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>寻找两个有序数组的中位数</title>
            <link>http://blog.flywithme.top/2019/03-08/findmedian/</link>
            <pubDate>Fri, 08 Mar 2019 16:12:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-08/findmedian/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br /&gt;
   请你找出这两个有序数组的中位数。&lt;br /&gt;
   要求算法的&lt;font color=red size=5&gt;时间复杂度为 O(log(m + n))&lt;/font&gt;&lt;br /&gt;
   你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Input:nums1 = [1, 3]
      nums2 = [2]
Output: 2.0

Input: nums1 = [1, 2]
       nums2 = [3, 4]
Output:  (2 + 3)/2 = 2.5


Input: nums1 = [1,2,3,7,8,9,10]
       nums2 = [-2,-1,4,5,7,9]
Output:  5
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;分割两个数组，分为leftA,rightA, leftB,rightB,
 leftA+leftB的长度等于rightA+rightB
 左边数组的最大值等于右边数组的最小值时，就找到了中间值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m := len(nums1)
    n := len(nums2)
    if m == 0 {
        return medianof(nums2)
    }
    if n == 0 {
        return medianof(nums1)
    }
    if m &amp;gt; n { //确保nums1数组长度比nums2边短
        findMedianSortedArrays(nums2,nums1)
    }
    halflen := (m + n +1)/2
    iMin := 0 //nums1的起始分割点 iMin &amp;lt; m的总长
    iMax := m

    //使用二分法查找分割点
    for iMin &amp;lt;= iMax {
        i := (iMin + iMax)/2
        j := halflen - i
        if i &amp;lt; iMax &amp;amp;&amp;amp; nums2[j - 1] &amp;gt; nums1[i] {
            //取值位置偏小，需要右移最小位置
            iMin =  i + 1
        }else if i &amp;gt; iMin &amp;amp;&amp;amp;  nums1[i -1] &amp;gt; nums2[j] {
            iMax = i -1   //i的位置太大
        }else {
            maxLeft := 0
            if i == 0 {
                maxLeft = nums2[j - 1]
            }else if j == 0 {
                maxLeft = nums1[i -1]
            }else {
                maxLeft = maxInt(nums1[i-1],nums2[j-1])
            }
            if (m + n)%2 ==1 {
                return float64(maxLeft)
            }

            minRight := 0
            if i == m {
                minRight = nums2[j]
            }else if j == n {
                minRight = nums1[i]
            }else {
                minRight = minInt(nums1[i],nums2[j])
            }
            return float64(maxLeft +minRight)/2.0
        }
    }
    return 0.0
}

func medianof(nums []int)float64  {
    l := len(nums)
    if l == 0 {
        return 0
    }
    if l%2 == 0 {
        return float64(nums[l/2-1]+nums[l/2])/2.0
    }
    return float64(nums[l/2])
}

func minInt(a,b int)int  {
    if a &amp;gt; b {
        return b
    }
    return a
}

func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leetCode地址&lt;br /&gt;
&lt;a href=&#34;https://leetcode.com/problems/median-of-two-sorted-arrays/&#34;&gt; Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Add Strings 字符串相加</title>
            <link>http://blog.flywithme.top/2019/03-07/addtwostring/</link>
            <pubDate>Thu, 07 Mar 2019 21:21:38 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/addtwostring/</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#note&#34;&gt;Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#注意&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution&#34;&gt;Solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solution-02&#34;&gt;Solution 02&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;h6 id=&#34;description&#34;&gt;Description&lt;/h6&gt;

&lt;p&gt;Given two non-negative integers num1 and num2 represented as string,
   return the sum of num1 and num2.&lt;br /&gt;
   给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。&lt;/p&gt;

&lt;h6 id=&#34;note&#34;&gt;Note&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;The length of both num1 and num2 is &amp;lt; 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Both num1 and num2 contains only digits 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;both num1 and num2 does not contain any leading zero.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;注意&#34;&gt;注意&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;num1 和num2 的长度都小于 5100.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都只包含数字 0-9.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;num1 和num2 都不包含任何前导零。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&#34;example&#34;&gt;Example&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: 579
Explanation: &amp;quot;123 + &amp;quot;456&amp;quot; = &amp;quot;579&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution&#34;&gt;Solution&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;//直接处理字符串相加
func addTwoString1(num1 string,num2 string)string  {
    carry := 0
    maxLen := maxInt(len(num2),len(num1))
    result := make([]byte,maxLen+1)
    for i := 0 ; i &amp;lt; maxLen; i ++ {
        sum := carry
        if len(num1) &amp;gt; i {
            v1 ,_ := strconv.Atoi(string(num1[len(num1) -i -1]))
            sum += v1
        }
        if len(num2) &amp;gt; i {
            v2 ,_ := strconv.Atoi(string(num2[len(num2) -i -1]))
            sum += v2
        }
        carry = sum/10
        result[maxLen - i] = []byte(strconv.Itoa(sum%10))[0]
    }
    if carry &amp;gt; 0 {
        result[0] = []byte(strconv.Itoa(carry))[0]
    }else {
        return string(result[1:])
    }
    return  string(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;solution-02&#34;&gt;Solution 02&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;type ListNode struct {
    Val  int
    Next *ListNode
}


//两字符串相加
func addTwoString(num1 string,num2 string)string  {
    l1 := makeListNode(num1)
    l2 := makeListNode(num2)
    l3 := addTwoNumbers(l1,l2)
    return  listNodeToString(l3)
}

//字符串转换为数字链表
func makeListNode(s string)*ListNode  {
    node := new(ListNode)
    current := node
    for i := len(s) - 1; i &amp;gt;=0; i -- {
        current.Next = new(ListNode)
        current.Val ,_ = strconv.Atoi(string(s[i]))
        current = current.Next
    }
    return node
}

//数字链表转为字符串
func listNodeToString(l *ListNode)string  {
    result := &amp;quot;&amp;quot;
    for l != nil {
        if l.Next != nil || l.Val != 0 {
            result  = fmt.Sprintf(&amp;quot;%d%s&amp;quot;,l.Val,result)
        }
        l = l.Next
    }
    return result
}

 //计算结果   
func addTwoNumbers(l1 *ListNode,l2 *ListNode) *ListNode  {
    head := &amp;amp;ListNode{0,nil}
    current := head
    carry := 0
    for l1 != nil || l2 != nil || carry &amp;gt; 0 {
        sum := carry
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        carry = sum /10
        current.Next = new(ListNode)
        current.Next.Val = sum%10
        current = current.Next
    }
    return head.Next
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>字符串相乘</title>
            <link>http://blog.flywithme.top/2019/03-07/multiplystrings/</link>
            <pubDate>Thu, 07 Mar 2019 19:29:50 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-07/multiplystrings/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:Given two non-negative integers num1 and num2 represented as strings,
return the product of num1 and num2, also represented as a string..
  Note:
  The length of both num1 and num2 is &amp;lt; 110.
  Both num1 and num2 contain only digits 0-9.
  Both num1 and num2 do not contain any leading zero, except the number 0 itself.
  You must not use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;p&gt;说明：
  num1 和 num2 的长度小于110。
  num1 和 num2 只包含数字 0-9。
  num1 和 num2 均不以零开头，除非是数字 0 本身。
  不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot;
Output: &amp;quot;6&amp;quot;

Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
Output: &amp;quot;56088&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
