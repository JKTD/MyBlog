<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Tue, 02 Apr 2019 14:59:57 CST</updated>
        
        <item>
            <title>gin-swagger</title>
            <link>http://blog.flywithme.top/2019/04-02/gin-swagger/</link>
            <pubDate>Tue, 02 Apr 2019 14:59:57 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/04-02/gin-swagger/</guid>
            <description>

&lt;h3 id=&#34;关于-swagger-官网-https-swagger-io&#34;&gt;关于 Swagger  &lt;a href=&#34;https://swagger.io/&#34;&gt;官网&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以生成一个具有互动性的API控制台，开发者可以用来快速学习和尝试API。&lt;/li&gt;
&lt;li&gt;可以生成客户端SDK代码用于各种不同的平台上的实现。&lt;/li&gt;
&lt;li&gt;文件可以在许多不同的平台上从代码注释中自动生成。&lt;/li&gt;
&lt;li&gt;有一个强大的社区，里面有许多强悍的贡献者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Swagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，
包括了比如 names、order 等 API 信息。&lt;/p&gt;

&lt;p&gt;你可以通过一个文本编辑器来编辑 Swagger 文件，或者你也可以从你的代码注释中自动生成。
各种工具都可以使用 Swagger 文件来生成互动的 API 文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;我这里介绍的是-gin-swagger&#34;&gt;我这里介绍的是 gin-swagger&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/swaggo/gin-swagger&#34;&gt;source&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&#34;首先需要本地安装-swag&#34;&gt;首先需要本地安装 swag&lt;/h6&gt;

&lt;p&gt;1、go get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/swaggo/swag/cmd/swag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若 $GOPATH/bin 没有加入$PATH中，你需要执行将其可执行文件移动到$GOBIN下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv $GOPATH/bin/swag /usr/local/go/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、gopm get 该包有引用golang.org上的包，若无科学上网，你可以使用 gopm 进行安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gopm get -g -v github.com/swaggo/swag/cmd/swag

cd $GOPATH/src/github.com/swaggo/swag/cmd/swag

go install
同理将其可执行文件移动到$GOBIN下
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、 验证是否安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swag -v
swag version v1.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;编辑api注释&#34;&gt;编辑API注释&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Swagger&lt;/code&gt; 中需要将相应的注释或注解编写到方法上，再利用生成器自动生成说明文件
 &lt;code&gt;gin-swagger&lt;/code&gt; 给出的范例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// @Summary Add a new pet to the store
// @Description get string by ID
// @Accept  json
// @Produce  json
// @Param   some_id     path    int     true        &amp;quot;Some ID&amp;quot;
// @Success 200 {string} string &amp;quot;ok&amp;quot;
// @Failure 400 {object} web.APIError &amp;quot;We need ID!!&amp;quot;
// @Failure 404 {object} web.APIError &amp;quot;Can not find ID&amp;quot;
// @Router /testapi/get-string-by-int/{some_id} [get]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以参照 Swagger 的注解规范和范例去编写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // @Summary 新增文章标签
 // @Produce  json
 // @Param name query string true &amp;quot;Name&amp;quot;
 // @Param state query int false &amp;quot;State&amp;quot;
 // @Param created_by query int false &amp;quot;CreatedBy&amp;quot;
 // @Success 200 {string} json &amp;quot;{&amp;quot;code&amp;quot;:200,&amp;quot;data&amp;quot;:{},&amp;quot;msg&amp;quot;:&amp;quot;ok&amp;quot;}&amp;quot;
 // @Router /api/v1/tags [post]
 func AddTag(c *gin.Context) {


 // @Summary 修改文章标签
 // @Produce  json
 // @Param id path int true &amp;quot;ID&amp;quot;
 // @Param name query string true &amp;quot;ID&amp;quot;
 // @Param state query int false &amp;quot;State&amp;quot;
 // @Param modified_by query string true &amp;quot;ModifiedBy&amp;quot;
 // @Success 200 {string} json &amp;quot;{&amp;quot;code&amp;quot;:200,&amp;quot;data&amp;quot;:{},&amp;quot;msg&amp;quot;:&amp;quot;ok&amp;quot;}&amp;quot;
 // @Router /api/v1/tags/{id} [put]
 func EditTag(c *gin.Context) {
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;生成&#34;&gt;生成&lt;/h5&gt;

&lt;p&gt;进入项目根目录中，执行初始化命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  logic git:(master) swag init  
2019/04/02 15:12:32 Generate swagger docs....
2019/04/02 15:12:32 Generate general API Info
2019/04/02 15:12:32 create docs.go at  docs/docs.go
2019/04/02 15:12:32 create swagger.json at  docs/swagger.json
2019/04/02 15:12:32 create swagger.yaml at  docs/swagger.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完毕后会在当前目录下生成docs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  docs/
  ├── docs.go
  └── swagger
      ├── swagger.json
      └── swagger.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化swagger&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  func AddSwaggerRoute(r *gin.Engine, options *conf.Config) {
    docs.SwaggerInfo.Title = &amp;quot;Badger API&amp;quot;
    docs.SwaggerInfo.Description = &amp;quot;Badger server.&amp;quot;
    docs.SwaggerInfo.Version = &amp;quot;1.0&amp;quot;
    docs.SwaggerInfo.Host = options.SwaggerOptions.Domain + options.HttpOptions.HttpPort
    docs.SwaggerInfo.BasePath = options.SwaggerOptions.BasePath
    r.GET(options.SwaggerOptions.SwaggerPath, ginSwagger.WrapHandler(swaggerFiles.Handler))
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>044. 通配符匹配 Wildcard Matching</title>
            <link>http://blog.flywithme.top/2019/03-18/044.-Wildcard-Matching/</link>
            <pubDate>Mon, 18 Mar 2019 22:40:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-18/044.-Wildcard-Matching/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;Hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;给定一个字符串 (&lt;code&gt;s&lt;/code&gt;) 和一个字符模式 (&lt;code&gt;p``) ，实现一个支持&lt;/code&gt;&amp;rsquo;?&amp;rsquo;&lt;code&gt;和&lt;/code&gt;&amp;lsquo;*&amp;rsquo;``` 的通配符匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;?&#39; 可以匹配任何单个字符。
&#39;*&#39; 可以匹配任意字符串（包括空字符串）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个字符串完全匹配才算匹配成功。&lt;/p&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;s 可能为空，且只包含从 a-z 的小写字母。&lt;/li&gt;
&lt;li&gt;p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;a&amp;quot;
输出: false
解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。

输入:
s = &amp;quot;aa&amp;quot;
p = &amp;quot;*&amp;quot;
输出: true
解释: &#39;*&#39; 可以匹配任意字符串。

输入:
s = &amp;quot;cb&amp;quot;
p = &amp;quot;?a&amp;quot;
输出: false
解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。

输入:
s = &amp;quot;adceb&amp;quot;
p = &amp;quot;*a*b&amp;quot;
输出: true
解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &amp;quot;dce&amp;quot;.

输入:
s = &amp;quot;acdcb&amp;quot;
p = &amp;quot;a*c?b&amp;quot;
输入: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/wildcard-matching/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>043.字符串相乘 Multiply Strings</title>
            <link>http://blog.flywithme.top/2019/03-18/043.-Multiply-Strings/</link>
            <pubDate>Mon, 18 Mar 2019 21:05:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-18/043.-Multiply-Strings/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-medium-font&#34;&gt;Description &lt;font color=red size=3&gt;Medium&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt;，
 返回 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明：&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 的长度小于110。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 只包含数字 0-9。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; 均不以零开头，除非是数字 0 本身。&lt;/li&gt;
&lt;li&gt;不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot;
输出: &amp;quot;6&amp;quot;

输入: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot;
输出: &amp;quot;56088&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func multiply(num1 string, num2 string) string {
    if num1 == &amp;quot;0&amp;quot; || num2 == &amp;quot;0&amp;quot; {
        return &amp;quot;0&amp;quot;
    }
    result := &amp;quot;0&amp;quot;
    for i := len(num2)-1;i &amp;gt;=0;i -- {
        temp := &amp;quot;0&amp;quot;
        for j := 0;j &amp;lt; int(num2[i] - 48);j ++ {
            temp = addTwoString(temp,num1)
        }
        num1 +=&amp;quot;0&amp;quot;
        result =  addTwoString(result,temp)
    }
    return result
}


func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}

//字符串
func addTwoString(num1 string,num2 string)string  {
    carry := 0
    maxLen := maxInt(len(num2),len(num1))
    result := make([]byte,maxLen+1)
    for i := 0 ; i &amp;lt; maxLen; i ++ {
        sum := carry
        if len(num1) &amp;gt; i {
            v1  :=  num1[len(num1) -i -1] - 48
            sum += int(v1)
        }
        if len(num2) &amp;gt; i {
            v2 := num2[len(num2) -i -1] - 48
            sum += int(v2)
        }
        carry = sum/10
        result[maxLen - i] = byte(sum%10 + 48)
    }
    if carry &amp;gt; 0 {
        result[0] = byte(carry+48)
    }else {
        return string(result[1:])
    }
    return  string(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/multiply-strings/submissions/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>042.接雨水 Trapping Rain Water</title>
            <link>http://blog.flywithme.top/2019/03-18/042.-Trapping-Rain-Water/</link>
            <pubDate>Mon, 18 Mar 2019 18:30:58 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-18/042.-Trapping-Rain-Water/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;Hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
 &lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/rainwatertrap.png&#34; alt=&#34;trap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
感谢 Marcos 贡献此图。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func trap(height []int) int {
    if len(height) &amp;lt; 3 {
        return 0
    }
    left ,right := 0,len(height)-1
    lMax,rMax :=0,0
    total := 0
    for left &amp;lt; right {
        lMax = maxInt(lMax,height[left])
        if lMax  &amp;gt; height[left]{
            total += lMax - height[left]
        }
        rMax = maxInt(rMax,height[right])
        if rMax &amp;gt; height[right] {
            total += rMax - height[right]
        }
        if height[left] &amp;lt; height[right] {
            left++
        }else {
            right--
        }
    }
    return total
}



func maxInt(a,b int)int  {
    if a &amp;gt; b {
        return a
    }
    return b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>041.缺失的第一个正数 First Missing Positive</title>
            <link>http://blog.flywithme.top/2019/03-17/041.-First-Missing-Positive/</link>
            <pubDate>Sun, 17 Mar 2019 22:06:49 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/041.-First-Missing-Positive/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;Hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,0]
输出: 3

输入: [3,4,-1,1]
输出: 2

输入: [7,8,9,11,12]
输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func firstMissingPositive(nums []int) int {
    if len(nums) == 0 {
        return 1
    }
    lenth := len(nums)
    for i := 0;i &amp;lt; lenth; {
        v := nums[i]
        if v &amp;gt; 0 &amp;amp;&amp;amp; v &amp;lt; lenth &amp;amp;&amp;amp; v != nums[v-1] {
            nums[i],nums[v-1]=  nums[v-1],nums[i]
        }else {
            i ++
        }
    }
    for i := 0 ; i &amp;lt; len(nums);i ++ {
        if nums[i] != i +1 {
            return i+1
        }
    }
    return len(nums)+1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>040. Combination Sum II 组合总和 II</title>
            <link>http://blog.flywithme.top/2019/03-17/040.-Combination-Sum-II/</link>
            <pubDate>Sun, 17 Mar 2019 20:30:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/040.-Combination-Sum-II/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-medium-font&#34;&gt;Description &lt;font color=red size=3&gt;Medium&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;定一个无重复元素的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。
&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用一次&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有数字（包括 &lt;code&gt;target&lt;/code&gt;）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func combinationSum2(candidates []int, target int) [][]int {
    var rest  [][]int
    maps := map[string]bool{}
    for i := 0;i &amp;lt; len(candidates);i ++ {
        if target - candidates[i] &amp;gt; 0 {
            for _,rst_ := range combinationSum2(candidates[i+1:],target-candidates[i]) {
                temp := make([]int,len(rst_)+1)
                copy(temp,rst_)
                temp[len(rst_)] = candidates[i]
                key := string(toByte(temp))
                if _,ok := maps[key];!ok {
                    rest = append(rest,temp)
                    maps[key] = true
                }
            }
        }else if target - candidates[i] == 0{
            temp := []int{candidates[i]}
            key := string(toByte(temp))
            if _,ok := maps[key];!ok {
                rest = append(rest,temp)
                maps[key] = true
            }
        }
    }
    return rest
}

func toByte(numbs []int)[]byte  {
    sort.Ints(numbs)
    bytes := make([]byte,len(numbs))
    for i,v := range numbs{
        bytes[i]=byte(v)
    }
    return bytes
}






//solution 2
func combinationSum(candidates []int, target int) [][]int {
    sort.Ints(candidates)
    path := make([]int,len(candidates))
    return find(candidates,path,target,0,0)
}

func find(candidates,path []int,target,index,pathIndx int)[][]int  {
    var result [][]int
    for i := index;i &amp;lt; len(candidates);i ++ {
        v := candidates[i]
        if i &amp;gt; index &amp;amp;&amp;amp; v == candidates[i-1] {
            continue
        }
        if v == target {
            found := make([]int,0,pathIndx+1)
            found = append(found,path[0:pathIndx]...)
            found = append(found,v)
            result = append(result,found)
        }else if v &amp;lt; target {
            path[pathIndx] = v
            found := find(candidates,path,target-v,i+1,pathIndx+1)
            result = append(result,found...)
        }else {
            break
        }
    }
    return result

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>039.组合总和 Combination Sum</title>
            <link>http://blog.flywithme.top/2019/03-17/039.-Combination-Sum/</link>
            <pubDate>Sun, 17 Mar 2019 19:07:10 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/039.-Combination-Sum/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-medium-font&#34;&gt;Description &lt;font color=red size=3&gt;Medium&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;定一个无重复元素的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。
&lt;code&gt;candidates&lt;/code&gt; 中的数字可以无限制重复被选取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有数字（包括 &lt;code&gt;target&lt;/code&gt;）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func combinationSum(candidates []int, target int) [][]int {
    var rest  [][]int
    for i := 0;i &amp;lt; len(candidates);i ++ {
        if target - candidates[i] &amp;gt; 0{
            for _,rst_ := range combinationSum(candidates[i:],target-candidates[i]) {
                tmp := make([]int,len(rst_)+1)
                copy(tmp,rst_)
                tmp[len(rst_)] = candidates[i]
                rest = append(rest,tmp)
            }
        }else if target - candidates[i] == 0{
            rest = append(rest,[]int{candidates[i]})
        }
    }
    return rest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>038.报数 Count and Say</title>
            <link>http://blog.flywithme.top/2019/03-17/038.-Count-and-Say/</link>
            <pubDate>Sun, 17 Mar 2019 16:27:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/038.-Count-and-Say/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-easy-font&#34;&gt;Description &lt;font color=red size=3&gt;easy&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.     1
2.     11
3.     21
4.     1211
5.     111221 

1 被读作  &amp;quot;one 1&amp;quot;  (&amp;quot;一个一&amp;quot;) , 即 11。
11 被读作 &amp;quot;two 1s&amp;quot; (&amp;quot;两个一&amp;quot;）, 即 21。
21 被读作 &amp;quot;one 2&amp;quot;,  &amp;quot;one 1&amp;quot; （&amp;quot;一个二&amp;quot; ,  &amp;quot;一个一&amp;quot;) , 即 1211。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;
 整数顺序将表示为一个字符串。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1
输出: &amp;quot;1&amp;quot;

输入: 4
输出: &amp;quot;1211&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func countAndSay(n int) string {
    if n == 0 {
        return &amp;quot;&amp;quot;
    }
    if n == 1 {
        return strconv.Itoa(1)
    }
    result := &amp;quot;1&amp;quot;
    for i := 0 ;i &amp;lt; n-1 ;i ++ {
        result = say(result)
    }
    return result
}

func say(str string)string  {
    if str == &amp;quot;&amp;quot;{
        return &amp;quot;&amp;quot;
    }
    var list []byte
    count := 0
    for i := range str{
        if len(list) != 0 &amp;amp;&amp;amp; str[i] == list[len(list)-1]{
            count++
            list[len(list)-2] = byte(count + 48)
        }else {
            count = 1
            list = append(list,  byte(count+ 48))
            list = append(list,str[i])
        }
    }
    return string(list)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-and-say/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>037. 解数独 Sudoku Solver</title>
            <link>http://blog.flywithme.top/2019/03-17/037.-Sudoku-Solver/</link>
            <pubDate>Sun, 17 Mar 2019 01:46:37 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/037.-Sudoku-Solver/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;编写一个程序，通过已填充的空格来解决数独问题。&lt;/p&gt;

&lt;p&gt;一个数独的解法需遵循如下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;/li&gt;
&lt;li&gt;空白格用 &lt;code&gt;&#39;.&#39;&lt;/code&gt; 表示。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudo.png&#34; alt=&#34;sudo&#34; /&gt;
&lt;font  size=2&gt;一个数独&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudoku_solver.png&#34; alt=&#34;sudo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;font  size=2&gt;&lt;strong&gt;答案被标称红色&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独序列只包含数字 1-9 和字符 &amp;lsquo;.&amp;rsquo; 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独永远是 9x9 形式的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: 把点换成数字
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func solveSudoku(board [][]byte)  {
    if board == nil  || len(board) != 9 || len(board[0]) != 9  {
        return
    }
    helper(board)
}

func helper(board [][]byte)bool  {
    for row := range board {
        for col := range board[row] {
            if board[row][col] == &#39;.&#39; {
                for num := &#39;1&#39;;num &amp;lt;= &#39;9&#39;;num ++ {
                    if isValid(board,byte(row),byte(col),byte(num)) {
                        board[row][col] = byte(num)
                        if helper(board) {
                            return true
                        }else {
                            board[row][col] = &#39;.&#39;
                        }
                    }
                }
                return false
            }

        }
    }
    return true
}

func isValid(board [][]byte,row,col int ,num byte)bool  {
    //check row &amp;amp; col
    for i := 0;i &amp;lt; 9 ; i  ++ {
        if board[i][col] == num {
            return false
        }
        if board[row][i] == num {
            return false
        }
    }
    //check block
    for  i := (row/3)*3;i &amp;lt; (row/3)*3 +3;i ++ {
        for j := (col/3)*3; j &amp;lt; (col/3)*3 +3;j ++ {
            if board[i][j] == num {
                return false
            }
        }

    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sudoku-solver/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>036.有效的数独 Valid Sudoku</title>
            <link>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</link>
            <pubDate>Sun, 17 Mar 2019 01:00:47 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudo.png&#34; alt=&#34;sudo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一个部分填充的有效的数独。&lt;br /&gt;
数独部分空格内已填入了数字，空白格用 &lt;code&gt;&#39;.&#39;&lt;/code&gt; 表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独序列只包含数字 1-9 和字符 &amp;lsquo;.&amp;rsquo; 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独永远是 9x9 形式的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: true

输入:
[
  [&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isValidSudoku(board [][]byte) bool {
    rows,cols,boxes :=   make([]map[byte]bool,9),make([]map[byte]bool,9),make([]map[byte]bool,9)
    for i := 0 ;i &amp;lt; 9;i ++ {
        rows[i] = make(map[byte]bool)
        cols[i] = make(map[byte]bool)
        boxes[i] = make(map[byte]bool)
    }
    for row := range  board {
        for col ,num := range board[row] {
            if num == &#39;.&#39; {
                continue
            }
            boxIndex := (row/3)*3 +col/3
            if rows[row][num] || cols[col][num] || boxes[boxIndex][num] {
                return false
            }
            rows[row][num] = true
            cols[col][num] = true
            boxes[boxIndex][num] = true
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-sudoku/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>034.在排序数组中查找元素的第一个和最后一个位置 Find First and Last Position of Element in Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</link>
            <pubDate>Sun, 17 Mar 2019 00:35:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//O(log n)复杂度
func searchRange(nums []int, target int) []int {
    result := []int{-1,-1}
    if len(nums) == 0{
        return result
    }
    left ,right := 0,len(nums)
    for left &amp;lt; right {
        mid := (left+right)/2
        if nums[mid] &amp;gt;= target {
            right = mid
        }else {
            left = mid+1
        }
    }
    if left &amp;gt;= len(nums) {
        return result
    }
    if nums[left] != target {
        return result
    }
    result[0] = left
    right = len(nums)
    for left &amp;lt; right {
        mid := (left + right)/2
        if nums[mid] &amp;gt; target {
            right = mid
        }else {
            left = mid+1
        }
    }
    result[1] = right-1
    return result
}


//O(n)复杂度
func searchRange1(nums []int, target int) []int {
    result := []int{-1,-1}
    for i :=0;i &amp;lt; len(nums) ;i ++ {
        if nums[i] == target {
            result[0] = i
            break
        }
    }
    if result[0] == -1 {
        return result
    }

    for i := len(nums)-1;i &amp;gt;=0 ;i -- {
        if nums[i] == target {
            result[1] = i
            break
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>035.搜索插入位置 Search Insert Position</title>
            <link>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</link>
            <pubDate>Sun, 17 Mar 2019 00:34:05 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 7
输出: 4

输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func searchInsert(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }
    if target &amp;gt; nums[len(nums)-1] {
        return len(nums)
    }
    if target &amp;lt; nums[0] {
        return 0
    }
    left ,right := 0,len(nums)-1
    for left &amp;lt;= right {
        mid := (left+right)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] &amp;lt; target {
            left = mid +1
        }else {
            right = mid-1
        }
    }
    return left
}


func searchInsert1(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }

    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i] &amp;gt;= target {
            return i
        }
    }
    return len(nums)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>033.搜索旋转排序数组 Search in Rotated Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</link>
            <pubDate>Sat, 16 Mar 2019 20:26:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组&lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为&lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func search(nums []int, target int) int {
   low,high := 0,len(nums)-1
    if len(nums) == 0 {
        return -1
    }
    if nums[0] ==  target {
        return 0
    }
    for low &amp;lt; high {
        mid := (low+high)/2
        if nums[mid] == target {
            return mid
        }
        if nums[low] == target {
            return low
        }
        if nums[high] == target {
            return high
        }
        if nums[low] &amp;lt; nums[mid] {
            if nums[low] &amp;lt; target &amp;amp;&amp;amp; nums[mid] &amp;gt; target {
                high = mid-1
            }else {
                low = mid+1
            }
        }else {
            if nums[high] &amp;gt; target &amp;amp;&amp;amp; nums[mid] &amp;lt; target {
                low = mid+1
            }else {
                high = mid-1
            }
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>032_最长有效括号</title>
            <link>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</link>
            <pubDate>Sat, 16 Mar 2019 18:46:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;(()&amp;quot;
输出: 2
解释: 最长有效括号子串为 &amp;quot;()&amp;quot;

输入: &amp;quot;)()())&amp;quot;
输出: 4
解释: 最长有效括号子串为 &amp;quot;()()&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func maxInt(a,b int)int  {
    if a &amp;gt; b  {
        return a
    }
    return b
}

//动态规划
func longestValidParentheses(s string) int {
    max := 0
    dp := make([]int,len(s))
    for i := 1;i &amp;lt;len(s); i ++ {
        if s[i] == &#39;)&#39;{
            if s[i-1] ==&#39;(&#39; {
                if i &amp;gt;=2 {
                    dp[i] = dp[i-2]+2
                }else {
                    dp[i] = 2
                }
            }else if i - dp[i -1] &amp;gt; 0 &amp;amp;&amp;amp; s[i - dp[i-1] -1]== &#39;(&#39; {
                if  i - dp[i-1] &amp;gt;= 2 {
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2]  +2
                }else {
                    dp[i] = dp[i-1] + 2
                }
            }
            max = maxInt(max,dp[i])
        }
    }
    return max
}

//Using stack 栈，
func longestValidParentheses2(s string) int {
    var stack []int
    max := 0
    stack = append(stack,-1)
    for i := 0; i &amp;lt; len(s);i ++ {
        if s[i]==&#39;(&#39; {
            stack = append(stack,i)
        }else {
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                stack = append(stack,i)
            }else {
                max = maxInt(max,i - stack[len(stack)-1])
            }
        }
    }
    return max
}
func longestValidParentheses1(s string) int {
    if len(s)&amp;lt;=1 {
        return 0
    }
    help := make([]bool,len(s))
    var stack  []int
    for i := 0;i &amp;lt; len(s);i ++{
        help[i] = false
    }
    for i := 0; i &amp;lt; len(s); i ++ {
        if s[i] == &#39;(&#39;{
            stack = append(stack,i)
        }else {
            if len(stack) &amp;gt; 0{
                help[i] = true
                help[stack[len(stack)-1]] = true
                stack = stack[:len(stack)-1]
            }
        }
    }
    max,l := 0,0
    for i := 0; i &amp;lt; len(s);i ++ {
        if help[i] {
            l++
        }else {
            if max &amp;lt; l {
                max = l
            }
            l = 0
        }
    }
    return maxInt(max,l)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-valid-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>031_下一个排列</title>
            <link>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</link>
            <pubDate>Sat, 16 Mar 2019 02:50:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func nextPermutation(nums []int)  {
    if len(nums) &amp;lt;= 1 {
        return
    }
    var  i int
    for i = len(nums)-2;i &amp;gt;=0;i-- {
        if nums[i] &amp;lt; nums[i+1] {
            break
        }
    }
    if i == -1 {
        reverseSort(nums)
        return
    }
    var j int
    for j = len(nums)-1; j &amp;gt; i;j -- {
        if nums[j] &amp;gt; nums[i] {
            break
        }
    }
    nums[i],nums[j] = nums[j],nums[i]
    reverseSort(nums[i+1:])
}

func reverseSort(nums []int)  {
    lenth := len(nums)
    for i := 0;i &amp;lt;= lenth;i ++ {
        if i &amp;gt;= lenth - i -1 {
            break
        }
        nums[i],nums[lenth - i - 1] = nums[lenth - i - 1],nums[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
