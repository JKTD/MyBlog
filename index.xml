<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Fly With Me on Fly With Me</title>
        <link>http://blog.flywithme.top/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Sun, 17 Mar 2019 22:06:49 CST</updated>
        
        <item>
            <title>041.缺失的第一个正数 First Missing Positive</title>
            <link>http://blog.flywithme.top/2019/03-17/041.-First-Missing-Positive/</link>
            <pubDate>Sun, 17 Mar 2019 22:06:49 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/041.-First-Missing-Positive/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;Hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,2,0]
输出: 3

输入: [3,4,-1,1]
输出: 2

输入: [7,8,9,11,12]
输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func firstMissingPositive(nums []int) int {
    if len(nums) == 0 {
        return 1
    }
    lenth := len(nums)
    for i := 0;i &amp;lt; lenth; {
        v := nums[i]
        if v &amp;gt; 0 &amp;amp;&amp;amp; v &amp;lt; lenth &amp;amp;&amp;amp; v != nums[v-1] {
            nums[i],nums[v-1]=  nums[v-1],nums[i]
        }else {
            i ++
        }
    }
    for i := 0 ; i &amp;lt; len(nums);i ++ {
        if nums[i] != i +1 {
            return i+1
        }
    }
    return len(nums)+1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>040. Combination Sum II 组合总和 II</title>
            <link>http://blog.flywithme.top/2019/03-17/040.-Combination-Sum-II/</link>
            <pubDate>Sun, 17 Mar 2019 20:30:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/040.-Combination-Sum-II/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-medium-font&#34;&gt;Description &lt;font color=red size=3&gt;Medium&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;定一个无重复元素的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。
&lt;code&gt;candidates&lt;/code&gt; 中的每个数字在每个组合中只能使用一次&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有数字（包括 &lt;code&gt;target&lt;/code&gt;）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func combinationSum2(candidates []int, target int) [][]int {
    var rest  [][]int
    maps := map[string]bool{}
    for i := 0;i &amp;lt; len(candidates);i ++ {
        if target - candidates[i] &amp;gt; 0 {
            for _,rst_ := range combinationSum2(candidates[i+1:],target-candidates[i]) {
                temp := make([]int,len(rst_)+1)
                copy(temp,rst_)
                temp[len(rst_)] = candidates[i]
                key := string(toByte(temp))
                if _,ok := maps[key];!ok {
                    rest = append(rest,temp)
                    maps[key] = true
                }
            }
        }else if target - candidates[i] == 0{
            temp := []int{candidates[i]}
            key := string(toByte(temp))
            if _,ok := maps[key];!ok {
                rest = append(rest,temp)
                maps[key] = true
            }
        }
    }
    return rest
}

func toByte(numbs []int)[]byte  {
    sort.Ints(numbs)
    bytes := make([]byte,len(numbs))
    for i,v := range numbs{
        bytes[i]=byte(v)
    }
    return bytes
}






//solution 2
func combinationSum(candidates []int, target int) [][]int {
    sort.Ints(candidates)
    path := make([]int,len(candidates))
    return find(candidates,path,target,0,0)
}

func find(candidates,path []int,target,index,pathIndx int)[][]int  {
    var result [][]int
    for i := index;i &amp;lt; len(candidates);i ++ {
        v := candidates[i]
        if i &amp;gt; index &amp;amp;&amp;amp; v == candidates[i-1] {
            continue
        }
        if v == target {
            found := make([]int,0,pathIndx+1)
            found = append(found,path[0:pathIndx]...)
            found = append(found,v)
            result = append(result,found)
        }else if v &amp;lt; target {
            path[pathIndx] = v
            found := find(candidates,path,target-v,i+1,pathIndx+1)
            result = append(result,found...)
        }else {
            break
        }
    }
    return result

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>039.组合总和 Combination Sum</title>
            <link>http://blog.flywithme.top/2019/03-17/039.-Combination-Sum/</link>
            <pubDate>Sun, 17 Mar 2019 19:07:10 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/039.-Combination-Sum/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-medium-font&#34;&gt;Description &lt;font color=red size=3&gt;Medium&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;定一个无重复元素的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt; 的组合。
&lt;code&gt;candidates&lt;/code&gt; 中的数字可以无限制重复被选取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有数字（包括 &lt;code&gt;target&lt;/code&gt;）都是正整数。&lt;/li&gt;
&lt;li&gt;解集不能包含重复的组合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func combinationSum(candidates []int, target int) [][]int {
    var rest  [][]int
    for i := 0;i &amp;lt; len(candidates);i ++ {
        if target - candidates[i] &amp;gt; 0{
            for _,rst_ := range combinationSum(candidates[i:],target-candidates[i]) {
                tmp := make([]int,len(rst_)+1)
                copy(tmp,rst_)
                tmp[len(rst_)] = candidates[i]
                rest = append(rest,tmp)
            }
        }else if target - candidates[i] == 0{
            rest = append(rest,[]int{candidates[i]})
        }
    }
    return rest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>038.报数 Count and Say</title>
            <link>http://blog.flywithme.top/2019/03-17/038.-Count-and-Say/</link>
            <pubDate>Sun, 17 Mar 2019 16:27:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/038.-Count-and-Say/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-easy-font&#34;&gt;Description &lt;font color=red size=3&gt;easy&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.     1
2.     11
3.     21
4.     1211
5.     111221 

1 被读作  &amp;quot;one 1&amp;quot;  (&amp;quot;一个一&amp;quot;) , 即 11。
11 被读作 &amp;quot;two 1s&amp;quot; (&amp;quot;两个一&amp;quot;）, 即 21。
21 被读作 &amp;quot;one 2&amp;quot;,  &amp;quot;one 1&amp;quot; （&amp;quot;一个二&amp;quot; ,  &amp;quot;一个一&amp;quot;) , 即 1211。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;
 整数顺序将表示为一个字符串。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: 1
输出: &amp;quot;1&amp;quot;

输入: 4
输出: &amp;quot;1211&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func countAndSay(n int) string {
    if n == 0 {
        return &amp;quot;&amp;quot;
    }
    if n == 1 {
        return strconv.Itoa(1)
    }
    result := &amp;quot;1&amp;quot;
    for i := 0 ;i &amp;lt; n-1 ;i ++ {
        result = say(result)
    }
    return result
}

func say(str string)string  {
    if str == &amp;quot;&amp;quot;{
        return &amp;quot;&amp;quot;
    }
    var list []byte
    count := 0
    for i := range str{
        if len(list) != 0 &amp;amp;&amp;amp; str[i] == list[len(list)-1]{
            count++
            list[len(list)-2] = byte(count + 48)
        }else {
            count = 1
            list = append(list,  byte(count+ 48))
            list = append(list,str[i])
        }
    }
    return string(list)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-and-say/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>037. 解数独 Sudoku Solver</title>
            <link>http://blog.flywithme.top/2019/03-17/037.-Sudoku-Solver/</link>
            <pubDate>Sun, 17 Mar 2019 01:46:37 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/037.-Sudoku-Solver/</guid>
            <description>

&lt;h5 id=&#34;description-font-color-red-size-3-hard-font&#34;&gt;Description &lt;font color=red size=3&gt;hard&lt;/font&gt;&lt;/h5&gt;

&lt;p&gt;编写一个程序，通过已填充的空格来解决数独问题。&lt;/p&gt;

&lt;p&gt;一个数独的解法需遵循如下规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;/li&gt;
&lt;li&gt;空白格用 &lt;code&gt;&#39;.&#39;&lt;/code&gt; 表示。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudo.png&#34; alt=&#34;sudo&#34; /&gt;
&lt;font  size=2&gt;一个数独&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudoku_solver.png&#34; alt=&#34;sudo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;font  size=2&gt;&lt;strong&gt;答案被标称红色&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独序列只包含数字 1-9 和字符 &amp;lsquo;.&amp;rsquo; 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独永远是 9x9 形式的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: 把点换成数字
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func solveSudoku(board [][]byte)  {
    if board == nil  || len(board) != 9 || len(board[0]) != 9  {
        return
    }
    helper(board)
}

func helper(board [][]byte)bool  {
    for row := range board {
        for col := range board[row] {
            if board[row][col] == &#39;.&#39; {
                for num := &#39;1&#39;;num &amp;lt;= &#39;9&#39;;num ++ {
                    if isValid(board,byte(row),byte(col),byte(num)) {
                        board[row][col] = byte(num)
                        if helper(board) {
                            return true
                        }else {
                            board[row][col] = &#39;.&#39;
                        }
                    }
                }
                return false
            }

        }
    }
    return true
}

func isValid(board [][]byte,row,col int ,num byte)bool  {
    //check row &amp;amp; col
    for i := 0;i &amp;lt; 9 ; i  ++ {
        if board[i][col] == num {
            return false
        }
        if board[row][i] == num {
            return false
        }
    }
    //check block
    for  i := (row/3)*3;i &amp;lt; (row/3)*3 +3;i ++ {
        for j := (col/3)*3; j &amp;lt; (col/3)*3 +3;j ++ {
            if board[i][j] == num {
                return false
            }
        }

    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sudoku-solver/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>036.有效的数独 Valid Sudoku</title>
            <link>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</link>
            <pubDate>Sun, 17 Mar 2019 01:00:47 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/036.-Valid-Sudoku/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/leetcode/sudo.png&#34; alt=&#34;sudo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图是一个部分填充的有效的数独。&lt;br /&gt;
数独部分空格内已填入了数字，空白格用 &lt;code&gt;&#39;.&#39;&lt;/code&gt; 表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个有效的数独（部分已被填充）不一定是可解的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;只需要根据以上规则，验证已经填入的数字是否有效即可。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独序列只包含数字 1-9 和字符 &amp;lsquo;.&amp;rsquo; 。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;给定数独永远是 9x9 形式的。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入:
[
  [&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: true

输入:
[
  [&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;],
  [&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;],
  [&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func isValidSudoku(board [][]byte) bool {
    rows,cols,boxes :=   make([]map[byte]bool,9),make([]map[byte]bool,9),make([]map[byte]bool,9)
    for i := 0 ;i &amp;lt; 9;i ++ {
        rows[i] = make(map[byte]bool)
        cols[i] = make(map[byte]bool)
        boxes[i] = make(map[byte]bool)
    }
    for row := range  board {
        for col ,num := range board[row] {
            if num == &#39;.&#39; {
                continue
            }
            boxIndex := (row/3)*3 +col/3
            if rows[row][num] || cols[col][num] || boxes[boxIndex][num] {
                return false
            }
            rows[row][num] = true
            cols[col][num] = true
            boxes[boxIndex][num] = true
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-sudoku/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>034.在排序数组中查找元素的第一个和最后一个位置 Find First and Last Position of Element in Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</link>
            <pubDate>Sun, 17 Mar 2019 00:35:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/034.-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//O(log n)复杂度
func searchRange(nums []int, target int) []int {
    result := []int{-1,-1}
    if len(nums) == 0{
        return result
    }
    left ,right := 0,len(nums)
    for left &amp;lt; right {
        mid := (left+right)/2
        if nums[mid] &amp;gt;= target {
            right = mid
        }else {
            left = mid+1
        }
    }
    if left &amp;gt;= len(nums) {
        return result
    }
    if nums[left] != target {
        return result
    }
    result[0] = left
    right = len(nums)
    for left &amp;lt; right {
        mid := (left + right)/2
        if nums[mid] &amp;gt; target {
            right = mid
        }else {
            left = mid+1
        }
    }
    result[1] = right-1
    return result
}


//O(n)复杂度
func searchRange1(nums []int, target int) []int {
    result := []int{-1,-1}
    for i :=0;i &amp;lt; len(nums) ;i ++ {
        if nums[i] == target {
            result[0] = i
            break
        }
    }
    if result[0] == -1 {
        return result
    }

    for i := len(nums)-1;i &amp;gt;=0 ;i -- {
        if nums[i] == target {
            result[1] = i
            break
        }
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>035.搜索插入位置 Search Insert Position</title>
            <link>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</link>
            <pubDate>Sun, 17 Mar 2019 00:34:05 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-17/035.-Search-Insert-Position/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 7
输出: 4

输入: [1,3,5,6], 0
输出: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func searchInsert(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }
    if target &amp;gt; nums[len(nums)-1] {
        return len(nums)
    }
    if target &amp;lt; nums[0] {
        return 0
    }
    left ,right := 0,len(nums)-1
    for left &amp;lt;= right {
        mid := (left+right)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] &amp;lt; target {
            left = mid +1
        }else {
            right = mid-1
        }
    }
    return left
}


func searchInsert1(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }

    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i] &amp;gt;= target {
            return i
        }
    }
    return len(nums)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-insert-position/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>033.搜索旋转排序数组 Search in Rotated Sorted Array</title>
            <link>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</link>
            <pubDate>Sat, 16 Mar 2019 20:26:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/033.-Search-in-Rotated-Sorted-Array/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组&lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为&lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func search(nums []int, target int) int {
   low,high := 0,len(nums)-1
    if len(nums) == 0 {
        return -1
    }
    if nums[0] ==  target {
        return 0
    }
    for low &amp;lt; high {
        mid := (low+high)/2
        if nums[mid] == target {
            return mid
        }
        if nums[low] == target {
            return low
        }
        if nums[high] == target {
            return high
        }
        if nums[low] &amp;lt; nums[mid] {
            if nums[low] &amp;lt; target &amp;amp;&amp;amp; nums[mid] &amp;gt; target {
                high = mid-1
            }else {
                low = mid+1
            }
        }else {
            if nums[high] &amp;gt; target &amp;amp;&amp;amp; nums[mid] &amp;lt; target {
                low = mid+1
            }else {
                high = mid-1
            }
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>032_最长有效括号</title>
            <link>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</link>
            <pubDate>Sat, 16 Mar 2019 18:46:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/032_Longest-Valid-Parentheses/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;(()&amp;quot;
输出: 2
解释: 最长有效括号子串为 &amp;quot;()&amp;quot;

输入: &amp;quot;)()())&amp;quot;
输出: 4
解释: 最长有效括号子串为 &amp;quot;()()&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func maxInt(a,b int)int  {
    if a &amp;gt; b  {
        return a
    }
    return b
}

//动态规划
func longestValidParentheses(s string) int {
    max := 0
    dp := make([]int,len(s))
    for i := 1;i &amp;lt;len(s); i ++ {
        if s[i] == &#39;)&#39;{
            if s[i-1] ==&#39;(&#39; {
                if i &amp;gt;=2 {
                    dp[i] = dp[i-2]+2
                }else {
                    dp[i] = 2
                }
            }else if i - dp[i -1] &amp;gt; 0 &amp;amp;&amp;amp; s[i - dp[i-1] -1]== &#39;(&#39; {
                if  i - dp[i-1] &amp;gt;= 2 {
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2]  +2
                }else {
                    dp[i] = dp[i-1] + 2
                }
            }
            max = maxInt(max,dp[i])
        }
    }
    return max
}

//Using stack 栈，
func longestValidParentheses2(s string) int {
    var stack []int
    max := 0
    stack = append(stack,-1)
    for i := 0; i &amp;lt; len(s);i ++ {
        if s[i]==&#39;(&#39; {
            stack = append(stack,i)
        }else {
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                stack = append(stack,i)
            }else {
                max = maxInt(max,i - stack[len(stack)-1])
            }
        }
    }
    return max
}
func longestValidParentheses1(s string) int {
    if len(s)&amp;lt;=1 {
        return 0
    }
    help := make([]bool,len(s))
    var stack  []int
    for i := 0;i &amp;lt; len(s);i ++{
        help[i] = false
    }
    for i := 0; i &amp;lt; len(s); i ++ {
        if s[i] == &#39;(&#39;{
            stack = append(stack,i)
        }else {
            if len(stack) &amp;gt; 0{
                help[i] = true
                help[stack[len(stack)-1]] = true
                stack = stack[:len(stack)-1]
            }
        }
    }
    max,l := 0,0
    for i := 0; i &amp;lt; len(s);i ++ {
        if help[i] {
            l++
        }else {
            if max &amp;lt; l {
                max = l
            }
            l = 0
        }
    }
    return maxInt(max,l)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-valid-parentheses/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>031_下一个排列</title>
            <link>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</link>
            <pubDate>Sat, 16 Mar 2019 02:50:51 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-16/031_Next-Permutation/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func nextPermutation(nums []int)  {
    if len(nums) &amp;lt;= 1 {
        return
    }
    var  i int
    for i = len(nums)-2;i &amp;gt;=0;i-- {
        if nums[i] &amp;lt; nums[i+1] {
            break
        }
    }
    if i == -1 {
        reverseSort(nums)
        return
    }
    var j int
    for j = len(nums)-1; j &amp;gt; i;j -- {
        if nums[j] &amp;gt; nums[i] {
            break
        }
    }
    nums[i],nums[j] = nums[j],nums[i]
    reverseSort(nums[i+1:])
}

func reverseSort(nums []int)  {
    lenth := len(nums)
    for i := 0;i &amp;lt;= lenth;i ++ {
        if i &amp;gt;= lenth - i -1 {
            break
        }
        nums[i],nums[lenth - i - 1] = nums[lenth - i - 1],nums[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>030_串联所有单词的子串</title>
            <link>http://blog.flywithme.top/2019/03-15/030_substring/</link>
            <pubDate>Fri, 15 Mar 2019 21:21:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/030_substring/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入：
  s = &amp;quot;barfoothefoobarman&amp;quot;,
  words = [&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 &amp;quot;barfoor&amp;quot; 和 &amp;quot;foobar&amp;quot; 。
输出的顺序不重要, [9,0] 也是有效答案。

输入：
  s = &amp;quot;wordgoodgoodgoodbestword&amp;quot;,
  words = [&amp;quot;word&amp;quot;,&amp;quot;good&amp;quot;,&amp;quot;best&amp;quot;,&amp;quot;word&amp;quot;]
输出：[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//最优解？？？？？//TODO
func findSubstring1(s string, words []string)(ret []int)  {
    if len(words) == 0 {return}
    wl := len(words[0])
    for off :=0;off &amp;lt; wl; off ++ {
        beg,end := off,off
        list := append(make([]string,0),words...)
        loop:
            for end+wl &amp;lt;= len(s) {
                for i ,v := range list{
                    if v == s[end:end+wl] {
                        end +=wl
                        list = append(list[:i],list[i+1:]...)
                        if len(list) == 0{
                            ret = append(ret,beg)
                        }
                        goto loop
                    }
                }
                if beg &amp;lt; end{
                    list = append(list,s[beg:beg+wl])
                }else {
                    end += wl
                }
                beg +=wl
            }
    }
    return
}

//暴力
func findSubstring(s string, words []string)(ret []int)  {
    if len(words) == 0 {
        return
    }

    wLen := len(words[0])

    left := 0
loop:
    beg ,end := left,left
    list := append(make([]string, 0), words...)
loop1:
    for end+wLen &amp;lt;= len(s){
        for i,v := range list {
            if v == s[end:end+len(v)] {
                end +=len(v)
                list = append(list[:i],list[i+1:]...)
                if len(list) == 0 {
                    ret = append(ret,beg)
                    goto loop
                }else {
                    goto loop1
                }
            }
        }
        left++
        goto loop
    }
    return
}



//空间换时间
func findSubstring2(s string, words []string) []int {
    var ret  []int
    if len(words) == 0 || len(s) == 0 {
        return ret
    }
    l := len(words[0])
    size := l * len(words)
    if size &amp;gt; len(s) {
        return ret
    }
    idx := 0
    idxmap := make(map[string]int)
    for _, str := range words {
        _, ok := idxmap[str]
        if ok == false {
            idxmap[str] = idx
            idx++
        }
    }
    rawmap := make([]int, len(idxmap))
    for i := 0; i &amp;lt; len(rawmap); i++ {
        rawmap[i] = 0
    }
    for _, str := range words {
        rawmap[idxmap[str]]++
    }

    stridx := make([]int, len(s)-l+1)
    for i := 0; i &amp;lt; len(stridx); i++ {
        str := s[i : i+l]
        idx, ok := idxmap[str]
        if ok == false {
            stridx[i] = -1
        } else {
            stridx[i] = idx
        }
    }
    for i := 0; i &amp;lt; len(stridx); i++ {
        curmap := make([]int, len(rawmap))
        for i := 0; i &amp;lt; len(rawmap); i++ {
            curmap[i] = rawmap[i]
        }
        for j := 0; j &amp;lt; size &amp;amp;&amp;amp; i+j &amp;lt; len(stridx); j += l {
            if stridx[i+j] == -1 || curmap[stridx[i+j]] == 0 {
                break
            } else {
                curmap[stridx[i+j]]--
            }
            if j == size-l {
                ret = append(ret, i)
            }
        }
    }
    return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/substring-with-concatenation-of-all-words/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>029_两数相除 Divide Two Integers</title>
            <link>http://blog.flywithme.top/2019/03-15/029_divide_two_integers/</link>
            <pubDate>Fri, 15 Mar 2019 20:43:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/029_divide_two_integers/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: dividend = 10, divisor = 3
输出: 3

输入: dividend = 7, divisor = -3
输出: -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
   - 被除数和除数均为 32 位有符号整数。
   - 除数不为 0。
   - 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。
   本题中，如果除法结果溢出，则返回 231 − 1。&lt;/p&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//使用加减法计算
func divide(dividend int, divisor int) int {
    if divisor == 0{
        return 0
    }

    if dividend &amp;lt;= math.MinInt32 &amp;amp;&amp;amp; divisor == -1{
        return math.MaxInt32
    }
    negative := 1
    if dividend &amp;lt; 0 {
        negative = -negative
        dividend = -dividend
    }
    if divisor &amp;lt; 0 {
        negative = -negative
        divisor = -divisor
    }

    count := 0
    for dividend &amp;gt;= divisor {
        dividend = dividend - divisor
        count ++
    }
    if negative &amp;lt; 0 {
        count = -count
    }
    return count
}

//位移，计算速度更快
func divide1(dividend int, divisor int) int {
    if divisor == 0{
        return 0
    }

    if dividend &amp;lt;= math.MinInt32 &amp;amp;&amp;amp; divisor == -1{
        return math.MaxInt32
    }
    negative := 1
    if dividend &amp;lt; 0 {
        negative = -negative
        dividend = -dividend
    }
    if divisor &amp;lt; 0 {
        negative = -negative
        divisor = -divisor
    }

    count := 0
    for dividend &amp;gt;= divisor {
        temp,m := divisor,1
        for dividend &amp;gt;= temp&amp;lt;&amp;lt;1{
            temp,m = temp&amp;lt;&amp;lt;1,m&amp;lt;&amp;lt;1
        }
        dividend -=temp
        count +=m
    }
    if negative &amp;lt; 0 {
        count = -count
    }
    return count
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/divide-two-integers/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>028_实现strStr()</title>
            <link>http://blog.flywithme.top/2019/03-15/028_implementstr/</link>
            <pubDate>Fri, 15 Mar 2019 20:15:55 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/028_implementstr/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;输入: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot;
输出: 2

输入: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot;
输出: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。&lt;/p&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;//暴力比较
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        equle := true
        for j := 0; j &amp;lt; len(needle); j ++ {
            if needle[j]!= haystack[i] {
                equle = false
                break
            }
        }
        if equle {
            return i
        }
    }

    return -1
}


//字符串截取比较(可能不符合题设)
func strStr(haystack string, needle string) int {
    if needle == &amp;quot;&amp;quot; {
        return 0
    }
    if len(needle) &amp;gt; len(haystack) {
        return -1
    }
    for i := 0;i &amp;lt; len(haystack);i ++ {
        if i + len(needle) &amp;gt; len(haystack) {
            return -1
        }
        if needle == haystack[i:i+len(needle)]{
            return i
        }
    }
    return -1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-strstr/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>027_移除元素</title>
            <link>http://blog.flywithme.top/2019/03-15/027_remove_element/</link>
            <pubDate>Fri, 15 Mar 2019 20:02:23 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2019/03-15/027_remove_element/</guid>
            <description>

&lt;h5 id=&#34;description&#34;&gt;Description&lt;/h5&gt;

&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;p&gt;示例1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br /&gt;
    为什么返回数值是整数，但输出的答案是数组呢?
    请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
    你可以想象内部操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;solution&#34;&gt;Solution&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func removeElement(nums []int, val int) int {
      index := 0
    for i := 0; i &amp;lt; len(nums);i ++ {
        if nums[i]!= val {
            nums[index] = nums[i]
            index++
        }
    }
    return index
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/remove-element/&#34;&gt;leetCode地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
