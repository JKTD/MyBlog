<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.54.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Swift3-09 集合 &middot; Fly With Me</title>

  
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.top/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.top/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.top/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.flywithme.top/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://blog.flywithme.top/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="http://blog.flywithme.top/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Fly With Me" />

  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.flywithme.top/"><h1>Fly With Me</h1></a>
      <p class="lead">
       漫步走在沙滩上 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.flywithme.top/">Home</a> </li>
        <li><a href="http://blog.flywithme.top/post/"> 归档 </a></li><li><a href="http://blog.flywithme.top/about/"> 关于我 </a></li>
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Swift3-09 集合</h1>
  <time datetime=2017-02-22T15:18:43&#43;0800 class="post-date">Wed, Feb 22, 2017</time>
  <blockquote>
<p>将一些元素放在一起,它们是无序的, 跟数组的不同是,数组是一个有序的列表,而集合是一个有序的数据集<br />
   为什么需要集合,因为集合是无序的,所以,在做一些查找和判重的时候,效率会有差别。集合会有一些,比数组使用起来方便很多。
   <strong>集合中的每一个元素都是唯一的</strong>。</p>
</blockquote>

<p><strong>基本方法</strong></p>

<pre><code>//集合的初始化
var arr = [&quot;x&quot;,&quot;y&quot;] //如果不显式的声明,则默认是数组
var setA:Set = [&quot;x&quot;,&quot;y&quot;]  //必须显式声明才行

var emptySet1:Set&lt;String&gt; = []
var emptySet2 = Set&lt;Int&gt;()

var setB = Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;]) //将一个数组转换成集合 


setA.count
setA.isEmpty
setA.first //随机的取出一个元素

setA.contains(&quot;a&quot;) //判断是否有这个元素
//遍历    
for str in setA{
    print(str)
}

var str = setA.joined(separator: &quot;d&quot;)

//比较
setA == setB
setA.elementsEqual(setB)
</code></pre>

<p><strong>集合的操作</strong></p>

<pre><code>var setA:Set = [&quot;x&quot;,&quot;y&quot;]  
//插入
setA.insert(&quot;D&quot;) //返回一个元组
//更新
setA.update(with: &quot;A&quot;) //若已存在元素,则返回改元素,若没有,则返回nil
//删除
setA.remove(&quot;a&quot;) //返回一个 bool 若是 true 则表示删除成功,返回 false 则表示之前没有这个元素
setA.removeAll() 
</code></pre>

<blockquote>
<p>并集: <code>union</code> (不改变调用者的集合), <code>formUnion</code>  (改变调用者的集合)  两个集合中的所有元素集合</p>
</blockquote>

<pre><code>var setA:Set = [&quot;x&quot;,&quot;y&quot;]
var setB = Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]) //将一根数组转换成集合

var setC =  setA.union(setB)  //setC 有 setA和 setB 所有元素,但是setA 不变
setA.union([&quot;a&quot;])

setA
setA.formUnion(setB) //setA 被改变
setA
</code></pre>

<blockquote>
<p>交集: <code>intersect</code>(不改变调用者的集合),  <code>formIntersection</code> (改变调用者的集合) 两个集合的公共部分</p>
</blockquote>

<pre><code>setA.intersection(setB)
setA

setA.formIntersection(setB)
setA
</code></pre>

<blockquote>
<p>补集(差集): 做减法  <code>subtracting</code> (不改变调用者的集合) <code>subtract</code> (改变调用者的集合)   调用者不包含在被调用者中的部分</p>
</blockquote>

<pre><code>setA.subtracting(setB)  //setA 独有的,而 setB 没有的元素 不改变 setA 值
setA

setA.subtract(setB) //setA 独有的,而 setB 没有的元素 改变 setA 值
setA
</code></pre>

<blockquote>
<p>去重: <code>symmetricDifference</code>(不改变调用者的集合), <code>formSymmetricDifference</code> (改变调用者的集合),   去除两个集合中相同的部分。</p>
</blockquote>

<pre><code>setA.symmetricDifference(setB)
setA
setA.formSymmetricDifference(setB)
setA
</code></pre>

<blockquote>
<p>子集: <code>isSbuset</code> 子集, <code>isStrictSubset</code> 真子集  判断是否是另外一个集合的子集</p>
</blockquote>

<pre><code>setA.isSubset(of: setB)
setA.isStrictSubset(of: setB)
</code></pre>

<blockquote>
<p>超集: <code>isSuperset</code>超集 ,  <code>isStrictSuperset</code> 真超集</p>
</blockquote>

<pre><code>setA.isSuperset(of: setB)
setA.isStrictSuperset(of: setB)
</code></pre>

<blockquote>
<p>相离:  <code>isDisjoint</code> 没有重叠的元素</p>
</blockquote>

<pre><code>setA.isDisjoint(with: setB)
</code></pre>

</div>


    </main>

    
  </body>
</html>
