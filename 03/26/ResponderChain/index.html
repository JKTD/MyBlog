<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.54.0" />



<link rel="canonical" href="http://blog.flywithme.top/2016/03/26/ResponderChain/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>Responder -- iOS用户响应者链完全剖析 - Fly With Bug</title>
    
<meta name="description" content="这篇文章想跟大家分享的主旨是iOS捕获用户事件的各种情况，以及内部封装的一些特殊事件。 我们先从UIButton谈起，UIButton大家使用">

<meta property="og:title" content="Responder -- iOS用户响应者链完全剖析 - Fly With Bug">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.flywithme.top/2016/03/26/ResponderChain/">
<meta property="og:image" content="http://blog.flywithme.topimages/default.png">
<meta property="og:site_name" content="Fly With Bug">
<meta property="og:description" content="这篇文章想跟大家分享的主旨是iOS捕获用户事件的各种情况，以及内部封装的一些特殊事件。 我们先从UIButton谈起，UIButton大家使用">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Fly With Bug">
<meta name="twitter:url" content="http://blog.flywithme.top/2016/03/26/ResponderChain/">
<meta name="twitter:title" content="Responder -- iOS用户响应者链完全剖析 - Fly With Bug">
<meta name="twitter:description" content="这篇文章想跟大家分享的主旨是iOS捕获用户事件的各种情况，以及内部封装的一些特殊事件。 我们先从UIButton谈起，UIButton大家使用">
<meta name="twitter:image" content="http://blog.flywithme.topimages/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"http://blog.flywithme.top"
    },
    "headline": "Responder -- iOS用户响应者链完全剖析 - Fly With Bug",
    "image": {
      "@type": "ImageObject",
      "url": "http://blog.flywithme.topimages/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2016-03-26T22:28:03JST",
    "dateModified": "2016-03-26T22:28:03JST",
    "author": {
      "@type": "Person",
      "name": "Fly With Bug"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Fly With Bug",
      "logo": {
        "@type": "ImageObject",
        "url": "http://blog.flywithme.topimages/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "这篇文章想跟大家分享的主旨是iOS捕获用户事件的各种情况，以及内部封装的一些特殊事件。 我们先从UIButton谈起，UIButton大家使用"
  }
</script>


    <link href="http://blog.flywithme.topcss/styles.css" rel="stylesheet">
    

  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://blog.flywithme.top">Fly With Bug</a>
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="http://blog.flywithme.top/post/">归档</a></li>
              
              
              
              <li><a href="http://blog.flywithme.top/about/">关于我</a></li>
              
              
            </ul>
            
          </div>
          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="http://blog.flywithme.top"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="http://blog.flywithme.toppost/" itemprop="url"><span itemprop="title">post</span></a></li>
        
        <li class="active">Responder -- iOS用户响应者链完全剖析</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2016-03-26T22:28:03JST">Mar 26, 2016</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="http://blog.flywithme.toppost/">post</a></li>
      
    </ul>

    <h1 class="title">Responder -- iOS用户响应者链完全剖析</h1>
  </header>

  

  <div class="article-body"><p>这篇文章想跟大家分享的主旨是iOS捕获用户事件的各种情况，以及内部封装的一些特殊事件。</p>

<hr />

<blockquote>
<p>我们先从UIButton谈起，UIButton大家使用的太多了，他特殊的地方就在于其内置的普通Default/高亮Highlighted/选择Selected/可用Enable的几个状态(UIControlState)。其次就是SDK内部已经为我们封装了以下用户事件:</p>
</blockquote>

<p><img src="sources/responderchain/UIControlEvents.jpg" alt="controlEvent" /></p>

<blockquote>
<p>最常用的莫过于Touch Up Inside这个事件了，他代表:  用户在按钮区域内按下，并且也在按钮区域内松开。</p>

<p>关键点:按下并且松开 才能触发此方法，也就是正确的操作 按下一次，松开一次只会触发一次此事件。与之不同的Touch Drag Inside等方法不需要松开这个过程，Up变为了Drag,其实大家都能理解，SDK在封装的时候原理跟UITouchEvent是一个道理，第一个单词Touch 代表按下(Began)第二个单词Up代表松开(Ended),Drag代表拖动(Moved)。TouchMoved方法在一次完整的触摸中会被触发很多次，所以Touch Drag Inside方法会在用户手松开之前一直被触发。</p>

<p>这些就是UIButton已封装的事件，而UIButton继承自UIControl。UIControl又继承自UIView。我们平时能用这些已封装的事件的控件都是UIControl的子类。那么父类UIView是没有内部事件的。</p>

<p>我们常常利用UIView来写自己的UITouchEvent。例如在一个View/ViewController中直接实现以下3个方法:</p>
</blockquote>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  
{  

}  
-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event  
{  

}  

-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event  
{  

}  
-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event  
{  

}  
</code></pre>

<blockquote>
<p>我们用的非常多，但是大家知道这4个方法是谁的实例方法吗？如果你一下就说出是UIView的，那么为什么我们在UIViewController中也可以用呢，他们不是继承关系。</p>

<p>注意这4个实例方法来自UIView与UIViewController的共同父类:UIResponder。它是我们今天的主角。</p>

<p>基本上我们所能看到的所有图形界面都是继承自UIResponder的，So，它究竟为何方神圣?</p>

<p>UIResponder所谓很多视图的父类，他掌管着用户的操作事件分发大权。如果没有他，我们的电容屏如何将用户的操作传递给我们的视图令其做出反应呢？</p>
</blockquote>

<ul>
<li><p>我们先看看iOS中的响应者链的概念:</p>

<blockquote>
<p>每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。</p>
</blockquote></li>
</ul>

<p><strong>例子:</strong></p>

<blockquote>
<p>我用SingleView模板创建了一个新的工程，它的主Window上只有一个UIViewController，其View之上有一个Button。这个项目中所有UIResponder的子类所构成的N叉树为这样的结构:</p>
</blockquote>

<p><img src="sources/responderchain/actionChain.jpg" alt="buttonActionChain" /></p>

<ul>
<li><p>那么他看起来并不像N叉树，但是不代表者不是一颗N叉树，当我们项目复杂之后，这个View可不可以有多个UIButton节点？所以他就是一棵树。
&gt; 实际上我们要把这棵树写完整，应该还要算上UIButton的UILabel和UIImageView，因为他们也是UIReponder的子类。这里先不考虑了。
&gt; 我们对UIButton来讲，他此时若是叶节点，那么这时我们针对他所在的响应链来说，他在他之前的响应者就应该是我们controller的view(树中的叶节点比父节点永远更优先被分发事件,但是并不是说他就能在时间上先响应，我们下面讲为什么)。所以我们尝试在任意地方打印这个Button的nextReponder对象。nextResponder对象是UIReponder类的实例方法，它会返回任意对象在树中的上一个响应者实例:</p>

<pre><code>NSLog(@&quot;%@&quot;,_testButton.nextResponder);  
</code></pre>

<blockquote>
<p>控制台输出消息:</p>
</blockquote>

<pre><code>2013-09-21 03:40:25.989 响应链[614:60b] &lt;UIView: 0x16555e10; frame = (0 0; 320 568); autoresize = RM+BM; layer = &lt;CALayer: 0x16555e70&gt;&gt;  
</code></pre>

<blockquote>
<p>我们可以根据这个UIView的尺寸来得知，他就是我们唯一的控制器中的那个UIView。
 接下来我们再打印下这个UIView的下一个响应者是谁:</p>
</blockquote>

<pre><code>NSLog(@&quot;%@&quot;,_testButton.nextResponder.nextResponder);  
</code></pre>

<blockquote>
<p>输出:</p>
</blockquote>

<pre><code>2013-09-21 03:45:03.914响应链[621:60b] &lt;RSViewController: 0x15da0e30&gt;
//依次看，接着加一个nextResponder:
2013-09-21 03:50:49.428 响应链[669:60b] (null)
为什么这里ViewController没有父亲呢？  
</code></pre>

<blockquote>
<p>注意这句代码我是写在ViewDidLoad中，而我们知道这个方法的生命周期比较早，所以我们换个地方写或者延迟一段时间再打印，两种方法都可以得到结果(由此可以推理出我们响应者树的构造过程是在ViewDidLoad周期中来完成的，这个函数会将当前实例的构成的响应者子树合并到我们整个根树中):</p>
</blockquote>

<pre><code>2013-09-21 03:53:47.304 响应链[681:60b] &lt;UIWindow: 0x14e24200; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x14e242e0&gt;; layer = &lt;UIWindowLayer: 0x14e244a0&gt;&gt;
</code></pre>

<blockquote>
<p>再继续往上追朔:</p>
</blockquote>

<pre><code>double delayInSeconds = 2.0;  
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));  
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){  
      NSLog(@&quot;%@&quot;,_testButton.nextResponder.nextResponder.nextResponder.nextResponder);  
 }); 

2013-09-21 03:56:22.043 响应链[690:60b] &lt;UIApplication: 0x15659c00&gt;
//再加一个:
2013-09-21 03:56:51.186 响应链[696:60b] &lt;RSAppDelegate: 0x16663520&gt;
 //那么我们的appDelegate还有没有父节点?
2013-09-21 03:57:22.588 响应链[706:60b] (null)
//没有了，注意，一个从叶节点开始分发的事件，最多也就只能分发到我们的AppDelegate了！
</code></pre></li>

<li><p>这个树形结构在我们的项目中尤为重要，举个栗子，如果我们想在一个view中重写UITouchEvent的4个方法，并且不影响他的父视图也响应这些事件，就要注意你重写的方式了，
&gt; 比如我们在ViewController中重写touchBegan如下:</p>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  
{  
    NSLog(@&quot;ViewController接收到触摸事件&quot;);  
}
</code></pre>

<blockquote>
<p>在appDelegate的中同样也写上这一段:</p>
</blockquote>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  
{  
    NSLog(@&quot;appDelegate接收到触摸事件&quot;);  
}  
</code></pre>

<blockquote>
<p>那么究竟是谁被触发呢？</p>
</blockquote>

<pre><code>2013-09-21 04:02:49.405 响应链[743:60b] ViewController接收到触摸事件
</code></pre>

<blockquote>
<p>这个很好理解，我刚刚也说了，viewController明显是appDelegate的子节点，他有事件分发的优先权。
如果我们想两个地方都触发呢？这里super一下就可以了:</p>
</blockquote>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event  
{  
    [super touchesBegan:touches withEvent:event];  
    NSLog(@&quot;ViewController接收到触摸事件&quot;);  
}    
</code></pre>

<blockquote>
<p>输出:</p>
</blockquote>

<pre><code>2013-09-21 04:07:26.206 响应链[749:60b] appDelegate接收到触摸事件
2013-09-21 04:07:26.208 响应链[749:60b] ViewController接收到触摸事件
</code></pre>

<blockquote>
<p>注意看时间戳，appDelegate虽然优先级别不如ViewController，但是他响应的时间上面足足比ViewController早了0.002秒，我这里试了几次，都是相差0.002秒。
那么我们分析一下这里的响应者链是怎样工作的:</p>

<p>用户手指触摸到了UIView上,由于我们没有重写UIView的UITouchEvent,所以他里面和super执行的一样的，将该事件继续分发到UIViewController；
UIViewController的TouchBegan被我们重写了，如果我们不super，那么我们在这里写响应代码。事件到这里就不继续分发了。可想而知，UIViewController祖先节点:UIWindow，UIApplication，AppDelegate都无权被分发此事件。
如果我们super了TouchBegan，那么此次触摸事件由
ViewController分发给UIWindow,
UIWindow继而分发给UIApplication，
UIApplication再分发给AppDelegate，
于是我们在ViewController和appDelegate的touchBegan方法中都捕获到了这次事件。</p>
</blockquote></li>
</ul>
</div>

  <footer class="article-footer">
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">CATEGORIES</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="http://blog.flywithme.topcategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    
  </footer>

</article>


    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="http://blog.flywithme.top/2019/02/24/gobin/" class="list-group-item">go bin执行问题记录</a>
      
      <a href="http://blog.flywithme.top/2019/01/15/nginx/" class="list-group-item">Nginx 配置 HTTPS 服务器</a>
      
      <a href="http://blog.flywithme.top/2019/01/13/mongodump/" class="list-group-item">mongodb 维护小记</a>
      
      <a href="http://blog.flywithme.top/2018/12/24/vue_webserver/" class="list-group-item">Vue上线后，history页面点击刷新按钮报错404问题</a>
      
      <a href="http://blog.flywithme.top/2018/12/24/vue-element02/" class="list-group-item">vue 路由重载之后导致history页面刷新空白问题fix</a>
      
      <a href="http://blog.flywithme.top/2018/12/22/vue-element-admin01/" class="list-group-item">vue-element-admin 踩坑日记 01</a>
      
      <a href="http://blog.flywithme.top/2018/12/18/blocked-by-CORS-policy/" class="list-group-item">gin api 跨域问题,cors</a>
      
      <a href="http://blog.flywithme.top/2018/12/10/mongodb/" class="list-group-item">MongoDB 用户名密码登录</a>
      
      <a href="http://blog.flywithme.top/2018/08/31/nat/" class="list-group-item">nat</a>
      
      <a href="http://blog.flywithme.top/2018/04/02/note_28/" class="list-group-item">Elasticsearch 入门</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
      <a href="http://blog.flywithme.topcategories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0" class="list-group-item">技术文章</a>
      
      <a href="http://blog.flywithme.topcategories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" class="list-group-item">学习笔记</a>
      
      <a href="http://blog.flywithme.topcategories/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F" class="list-group-item">思考感悟</a>
      
      <a href="http://blog.flywithme.topcategories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="list-group-item">读书笔记</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p>Copyright (c) 2015. All rights reserved.</p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

