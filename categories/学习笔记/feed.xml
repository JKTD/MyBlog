<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学习笔记 on Fly With Me</title>
        <link>http://blog.flywithme.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>swift3-16 属性</title>
            <link>http://blog.flywithme.top/2017/03/30/swift16/</link>
            <pubDate>Thu, 30 Mar 2017 16:53:45 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/30/swift16/</guid>
            <description>&lt;p&gt;Swift 属性将值跟特定的类、结构或枚举关联&lt;/p&gt;

&lt;p&gt;属性可分为存储属性和计算属性:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;存储属性&lt;/th&gt;
&lt;th&gt;计算属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存储常量或变量作为实例的一部分&lt;/td&gt;
&lt;td&gt;计算（而不是存储）一个值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于类和结构体&lt;/td&gt;
&lt;td&gt;用于类、结构体和枚举&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;存储属性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以在定义存储属性的时候指定默认值&lt;/li&gt;
&lt;li&gt;在构造过程中设置或修改存储值属性的值，身子修改常量存储属性的值
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;延迟存储属性&lt;/strong&gt; lazy property&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;延迟对象的创建&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当属性的值依赖于其他未知类&lt;/p&gt;

&lt;p&gt;class CloseRange{
    var start: Int
    var end:Int
    var width:Int{
        return end - start + 1
    }
    lazy var sum: Int = {
        var res = 0
        for i in self.start&amp;hellip;self.end{
            res += 1
        }
        return res
    }()
    var sum1: Int {
        var res = 0
        for i in start&amp;hellip;end{
            res += 1
        }
        return res
    }
    init?(start:Int, end:Int){
        if start &amp;gt; end{
            return nil
        }
        self.start = start
        self.end = end
    }
}
var range = CloseRange(start: 0, end: 10)!
range.sum
range.sum1
range.start = 1
range.sum  //不变
range.sum1 //每次都重新计算&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;计算属性&lt;/strong&gt; 除存储属性外，类、结构体和枚举可以定义计算属性，计算属性不直接存储值，而是提供一个 getter 来获取值，
一个可选的 setter 来间接设置其他属性或变量的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class sample {
    var no1 = 0.0, no2 = 0.0
    var length = 300.0, breadth = 150.0        
    var middle: (Double, Double) {
        get{
            return (length / 2, breadth / 2)
        }
        set(axis){
            no1 = axis.0 - (length / 2)
            no2 = axis.1 - (breadth / 2)
        }
    }
}
var result = sample()
print(result.middle)
result.middle = (0.0, 10.0)
print(result.no1)
print(result.no2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;只读计算属性&lt;/strong&gt; 只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点(.)运算符访问，但不能设置新的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class film {
    var head = &amp;quot;&amp;quot;
    var duration = 0.0
    var metaInfo: [String:String] {
        return [
            &amp;quot;head&amp;quot;: self.head,
            &amp;quot;duration&amp;quot;:&amp;quot;\(self.duration)&amp;quot;
        ]
    }
}
var movie = film()
movie.head = &amp;quot;肖申克救赎&amp;quot;
movie.duration = 3.09

print(movie.metaInfo[&amp;quot;head&amp;quot;]!)
print(movie.metaInfo[&amp;quot;duration&amp;quot;]!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;属性观察器&lt;/strong&gt;  属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Samplepgm {
    var counter: Int = 0{
        willSet(newTotal){
            print(&amp;quot;计数器: \(newTotal)&amp;quot;)
        }
        didSet{
            if counter &amp;gt; oldValue {
                print(&amp;quot;新增数 \(counter - oldValue)&amp;quot;)
            }
        }
    }
}
let NewCounter = Samplepgm()
NewCounter.counter = 100
NewCounter.counter = 800
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;willSet在设置新的值之前调用&lt;/li&gt;
&lt;li&gt;didSet在新的值被设置之后立即调用&lt;/li&gt;
&lt;li&gt;willSet和didSet观察器在属性初始化过程中不会被调用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;全局变量和局部变量&lt;/strong&gt;  计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;局部变量&lt;/th&gt;
&lt;th&gt;全局变量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在函数、方法或闭包内部定义的变量。&lt;/td&gt;
&lt;td&gt;函数、方法、闭包或任何类型之外定义的变量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于存储和检索值。  用于存储和检索值。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;**类型属性 类型方法 ** 类型属性是作为类型定义的一部分写在类型最外层的花括号（{}）内。使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Player{
    var name:String
    var score = 0
    static var heighestScore = 0
    init(name:String) {
        self.name = name
    }
    func play() {
        let score = arc4random()%100
        print(&amp;quot;\(name) played and got \(score) score&amp;quot;)
        self.score += Int(score)
        Player.heighestScore = Player.heighestScore &amp;gt; self.score ? Player.heighestScore:self.score
        print(&amp;quot;Highest Score is \(Player.heighestScore)&amp;quot;)
    }

     static func heightScore(){
        print(&amp;quot;Highest Score is == \(Player.heighestScore)&amp;quot;)
     }
}
var play1 = Player.init(name: &amp;quot;Player1&amp;quot;)
var play2 = Player.init(name: &amp;quot;Player2&amp;quot;)

play1.play()
play2.play()
Player.heighestScore
Player.heightScore()


play1.play()
play2.play()
Player.heighestScore

play1.play()
play2.play()
Player.heighestScore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问控制&lt;/strong&gt; public internal private&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UI{
    private var fontColor: UIColor!
    var backGroundColor: UIColor!
    var themeMode:Theme = .DayMode{
        didSet{
            self.changetheme(themeModel: themeMode)
        }

    }

    private func changetheme(themeModel:Theme) {
        switch themeModel {
        case .DayMode:
            fontColor = UIColor.black
            backGroundColor = UIColor.orange
        case .NightMode:
            fontColor = UIColor.gray
            backGroundColor = UIColor.lightGray
        }
    }

    init(){
        self.themeMode = .DayMode
        self.changetheme(themeModel: self.themeMode)
    }

    init(themeMode:Theme) {
        self.themeMode = themeMode
        self.changetheme(themeModel: themeMode)
    }
}

let ui = UI()
ui.themeMode
ui.backGroundColor
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-15 类</title>
            <link>http://blog.flywithme.top/2017/03/29/swift15/</link>
            <pubDate>Wed, 29 Mar 2017 14:18:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/29/swift15/</guid>
            <description>&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;：Swift 类是构建代码所用的一种通用且灵活的结构体。我们可以为类定义属性和方法。
    与其他编程语言不同的是,Swift 并不要求你为自定义的类去创建独立的接口和实现文件，
    你要做的是在一个单一文件中定义一个类，系统会自动生产面向其他代码的外部接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
    var firstName:String = &amp;quot;&amp;quot;
    var lastName:String = &amp;quot;&amp;quot;
}

class Person1{
    var firstName:String
    var lastName:String
    init(firstName:String, lastName:String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}
let person1 = Person1.init(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;类和结构体的对比&lt;/strong&gt;&lt;br /&gt;
 共同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义属性用于存储值&lt;/li&gt;
&lt;li&gt;定义方法用于提供功能&lt;/li&gt;
&lt;li&gt;定义附属脚本用于访问值&lt;/li&gt;
&lt;li&gt;定义构造器用于生成初始化值&lt;/li&gt;
&lt;li&gt;通过扩展以增加默认实现的功能&lt;/li&gt;
&lt;li&gt;符合协议以对某类提供标准功能
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比结构体多了如下功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许一个类继承另一个类的特征&lt;/li&gt;
&lt;li&gt;类型转换允许在运行时检查和解释一个类的实例类型&lt;/li&gt;
&lt;li&gt;结构器允许一个实例释放任何其所分配的资源&lt;/li&gt;
&lt;li&gt;引用计数允许对一个类多次引用
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区别：引用类型和值类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
   var firstName:String = &amp;quot;&amp;quot;
   var lastName:String = &amp;quot;&amp;quot;
}

let person1 = Person(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
let person2 = person1
person2.firstName = &amp;quot;abc&amp;quot;
person1.firstName  // &amp;quot;abc&amp;quot;  person1 和 person2 是引用关系 指向同一个内存空间
let person3 = Person(firstName: &amp;quot;abc&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)

struct Location{
    var latitude:Double
    var longitude:Double
}

var aLocation = Location.init(latitude: 2.0, longitude: 3.0)
var blocation = aLocation
blocation.latitude = 1.0
aLocation.latitude    // 2.0  aLocation 和 bloaction 是值类型关系，赋值是拷贝，产生一个新的副本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;恒等运算符&lt;/strong&gt;  因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例.
          为了能够判定两个常量或者变量是否引用同一个类实例，Swift 内建了两个恒等运算符：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;===&lt;/code&gt;: 如果两个常量或者变量引用同一个类实例则返回 true&lt;br /&gt;
      &lt;code&gt;!==&lt;/code&gt;: 如果两个常量或者变量引用不同一个类实例则返回 true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; person1 === person2   //true
 person1 === person3   //false
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-14 结构体</title>
            <link>http://blog.flywithme.top/2017/03/23/swift3-14/</link>
            <pubDate>Thu, 23 Mar 2017 16:54:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/23/swift3-14/</guid>
            <description>&lt;p&gt;Swift 结构体是构建代码所用的一种通用且灵活的构造体。我们可以为结构体定义属性（常量、变量）和添加方法，从而扩展结构体的功能.&lt;br /&gt;
与 C 和 Objective-C 不同的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体不需要包含实现文件和接口&lt;/li&gt;
&lt;li&gt;结构体允许我们创建一个单一文件,且系统会自动生成面向其他代码的外部接口
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct MarkStruct{
   var mark1: Int
   var mark2: Int
   var mark3: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结构体应用&lt;/strong&gt;  需要注意的以下几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体的主要目的是用来封装少了相关简单数据&lt;/li&gt;
&lt;li&gt;有理由预计一个结构体实例在赋值和传递时,封装的数据将会被拷贝而不是被引用&lt;/li&gt;
&lt;li&gt;任何在结构体中存储的值类型属性,也将会被拷贝,而不是被引用。&lt;/li&gt;
&lt;li&gt;结构体不需要去继承另一个已存在类型的属性或者行为。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说就是:结构体实例是通过值传递,而不是通过引用传递。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude:Double
    var longitude:Double
}
let aLocation = Location(latitude: 12.0,longitude: 212.0)
var bLoaction = Location.init(latitude: 1.2, longitude: 1.3)
struct Place{
    var location:Location
    var name:String
}

var aPlace = Place.init(location: bLoaction, name: &amp;quot;苹果总部&amp;quot;)
bLoaction.latitude = 37.3230
bLoaction.longitude = -122.0332
print(aPlace)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude : Double
    var longitude: Double

    init?(coordinateString:  String) {
         guard
            let commIndex = coordinateString.range(of: &amp;quot;,&amp;quot;),
            let first = Double(coordinateString.substring(to: commIndex.lowerBound)),
            let second = Double(coordinateString.substring(from: commIndex.upperBound))
            else {
                return nil
        }

        self.latitude = first
        self.longitude = second
    }
    init(latitude:Double, longitude:Double) {
        self.latitude = latitude
        self.longitude = longitude

    }
    func printLocation() {
        print(&amp;quot;The Location is \(self.latitude), \(self.longitude)&amp;quot;)
    }
    func isNoth() -&amp;gt; Bool {
         self.printLocation()
         return self.latitude &amp;gt; 0
    }
}
let location = Location(coordinateString: &amp;quot;21,23&amp;quot;)
location?.latitude
location?.longitude
let location2 = Location(latitude: 25.222,longitude: 122.23222)
location2.isNoth()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-13 枚举</title>
            <link>http://blog.flywithme.top/2017/03/21/swift13/</link>
            <pubDate>Tue, 21 Mar 2017 15:30:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/21/swift13/</guid>
            <description>&lt;p&gt;枚举简单的说也是一种数据类型，只不过是这种数据类型只包含自定义的特定数据，它是一组有共同特性的数据的集合。
Swift 的枚举类似于 Objective C 和 C 的结构&lt;/p&gt;

&lt;p&gt;枚举的功能为&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它声明在类中,可以通过实例化类来访问它的值.&lt;br /&gt;
  枚举也可以定义构造函数来提供一个初始成员值,可以在原始的实现基础上扩展它功能。&lt;br /&gt;
  可以遵守协议来提供标准的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义枚举
enum DaysofaWeek {
    case Sunday
    case Monday
    case TUESDAY
    case WEDNESDAY
    case THURSDAY
    case FRIDAY
    case Saturday
}
var weekDay = DaysofaWeek.THURSDAY
weekDay = .THURSDAY
switch weekDay
{
case .Sunday:
    print(&amp;quot;星期天&amp;quot;)
case .Monday:
    print(&amp;quot;星期一&amp;quot;)
case .TUESDAY:
    print(&amp;quot;星期二&amp;quot;)
case .WEDNESDAY:
    print(&amp;quot;星期三&amp;quot;)
case .THURSDAY:
    print(&amp;quot;星期四&amp;quot;)
case .FRIDAY:
    print(&amp;quot;星期五&amp;quot;)
case .Saturday:
    print(&amp;quot;星期六&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值与原始值的区别&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;相关值&lt;/th&gt;
&lt;th&gt;原始值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不同数据类型&lt;/td&gt;
&lt;td&gt;相同数据类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;值的创建基于常量或变量&lt;/td&gt;
&lt;td&gt;预先填充的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;相关值是当你在创建一个枚举成员的心常量或变量时才会被设置,并且每次当你这么做的时候,它的值都不同&lt;/td&gt;
&lt;td&gt;原始值试着是相同的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;原始值&lt;/strong&gt; Raw value  原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的.在原始值为整数的枚举时，不需要显式的为每一个成员赋值，Swift会自动为你赋值。&lt;/p&gt;

&lt;p&gt;例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Month: Int {
    case January = 1, February, March, April, May, June, July, August, September, October, November, December
}

let yearMonth = Month.May.rawValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值&lt;/strong&gt; Associate Value 以下实例中我们定义一个名为 Student 的枚举类型，它可以是 Name 的一个相关值（Int，Int，Int，Int），或者是 Mark 的一个字符串类型（String）相关值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Student{
    case Name(String)
    case Mark(Int,Int,Int)
}
var studDetails = Student.Name(&amp;quot;Runoob&amp;quot;)
var studMarks = Student.Mark(98,97,95)
switch studMarks {
case .Name(let studName):
    print(&amp;quot;学生的名字是: \(studName)。&amp;quot;)
case .Mark(let Mark1, let Mark2, let Mark3):
    print(&amp;quot;学生的成绩是: \(Mark1),\(Mark2),\(Mark3)。&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选型的实质就是枚举&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//public enum Optional&amp;lt;Wrapped&amp;gt;
var website: Optional&amp;lt;String&amp;gt; = Optional.some(&amp;quot;www.dianping.com&amp;quot;)
website = .none   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;枚举递归&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indirect enum ArithmeticExpression{
indirect enum ArithmeticExpression{
    case Number(Int)
    case Addition(ArithmeticExpression, ArithmeticExpression)
    case Multiplication(ArithmeticExpression, ArithmeticExpression)
}

let five = ArithmeticExpression.Number(5)
let two = ArithmeticExpression.Number(2)
let sum = ArithmeticExpression.Addition(five, two)
let product = ArithmeticExpression.Multiplication(sum, two)

func evaluate(expression:ArithmeticExpression) -&amp;gt; Int{
    switch expression {
    case let .Number(value):
        return value
    case let .Addition(left,right):
        return evaluate(expression: left) + evaluate(expression: right)
    case let .Multiplication(left,right):
        return evaluate(expression: left)*evaluate(expression: right)
    }
} 
evaluate(expression: product)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-12 闭包</title>
            <link>http://blog.flywithme.top/2017/02/28/swift12/</link>
            <pubDate>Tue, 28 Feb 2017 17:43:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/28/swift12/</guid>
            <description>&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;
  闭包(Closures)是自包含的功能代码块,可以在代码中使用或者用来传参传值。
   Swift 的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。
   全局函数和嵌套函数其实就是特殊的闭包。&lt;/p&gt;

&lt;p&gt;闭包的形式有&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;全局函数&lt;/strong&gt;:    有名字但不能捕获任何值&lt;br /&gt;
   &lt;strong&gt;嵌套函数&lt;/strong&gt;:    有名字,可以捕获封闭函数内的值&lt;br /&gt;
   &lt;strong&gt;闭包表达式&lt;/strong&gt;:  无名闭包,使用轻量级语法,可以根据上下文环境捕获值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let clousuer = { print(&amp;quot;Swift 闭包实例。&amp;quot;) }
clousuer()


//加法
let sum = {(val1:Int, val2:Int)-&amp;gt; Int in
        return val1 + val2
}
let result = sum(20,2)

//排序
var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}
arr.sorted(by: {(a: Int, b:Int) -&amp;gt; Bool in

    return a &amp;gt; b
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包的简化&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简化: 根据现场情况,选择适合当前情况的写法。
arr.sort(by:{a, b in return a &amp;gt; b}) //因为只能是 Int 类型的,可以省去声明
arr
arr.sort(by:{a, b in  a &amp;lt; b})  //省去 Return
arr
arr.sort(by: {$0&amp;gt;$1}) //$0, $1(从0开始，表示第i个参数...) 省去参数,直接使用简化参数名
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运算符函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.sort(by: &amp;lt;) //可以这样写的原因是 Swift中,&amp;gt; &amp;lt; = + - 等,本身就是函数
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;尾随闭包&lt;/strong&gt;  Trailing closure syntax   尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//把闭包写在()外边
arr.sorted(){a, b in
    return a &amp;gt; b
}
//由于么有参数需要传入,()也可以省略
arr.sorted{a, b in
    return a &amp;gt; b
}
arr.sorted{$0 &amp;gt; $1}


//实现一个小动画
import UIKit
import XCPlayground

let showView = UIView(frame:CGRect(x:0,  y:0, width:300, height:300))
let rectAngle = UIView(frame:CGRect(x:0,  y:0, width:50, height:50))
rectAngle.center = showView.center
showView.backgroundColor = UIColor .white
rectAngle.backgroundColor = UIColor.red
showView.addSubview(rectAngle)
XCPlaygroundPage.currentPage.liveView = showView
UIView.animate(withDuration: 4.0, animations: {
    rectAngle.backgroundColor = UIColor.orange
    rectAngle.frame = CGRect(x:0,  y:0, width:300, height:300)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;内容捕获&lt;/strong&gt;   闭包可以在其定义的上下文中捕获常量或变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

var num = 300
arr.sorted{
    a, b in abs(a - num) &amp;lt; abs(b - num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包是引用类型&lt;/strong&gt;  无论您将函数/闭包赋值给一个常量还是变量，实际上都是将常量/变量的值设置为对应函数/闭包的引用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func makeIncrementor(forIncrement amount: Int) -&amp;gt; () -&amp;gt; Int {
    var runningTotal = 0
    func incrementor() -&amp;gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// 返回的值为10
incrementByTen()

// 返回的值为20
incrementByTen()

// 返回的值为30
incrementByTen()

// 返回的值为40
incrementByTen()

let alsoIncrementByTen = incrementByTen

// 返回的值为50
print(alsoIncrementByTen())
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-11 函数</title>
            <link>http://blog.flywithme.top/2017/02/27/swift11/</link>
            <pubDate>Mon, 27 Feb 2017 13:41:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/27/swift11/</guid>
            <description>&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Swift 定义函数使用关键字 func。
  定义函数的时候，可以指定一个或多个输入参数和一个返回值类型。
  每个函数都有一个函数名来描述它的功能。通过函数名以及对应类型的参数值来调用这个函数。函数的参数传递的顺序必须与参数列表相同。
  函数的实参传递的顺序必须与形参列表相同，-&amp;gt; 后定义函数的返回值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func hello(name:String)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + name
}

hello(name: &amp;quot;Jack&amp;quot;)    


func hello1(name:String?)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + (name != nil  ? name! : &amp;quot;guess&amp;quot;)
}

hello1(name: &amp;quot;Jack&amp;quot;)


func printHello(){
    print(&amp;quot;hello&amp;quot;)
}
printHello()

func printHello1() -&amp;gt; Void{  //Void 是一个类型
    print(&amp;quot;hello&amp;quot;)
}
printHello1()

func printHello2() -&amp;gt; (){
    print(&amp;quot;hello&amp;quot;)
}
printHello2()    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用元组作为返回值&lt;/strong&gt;  函数返回值的类型可以是字符串,整型,浮点型等,元组与数组类似,不同的是,元组中的元素可以是任意类型,使用的是括号,你可以使用元组类型让多个值作为一个复合值从函数中返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMaxAndMin(numbers:[Int]) -&amp;gt; (max:Int, min:Int)?{ //如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型。
    guard !numbers.isEmpty else {
        return (Int.max,Int.min)
    }
    var minValue = numbers[0]
    var maxValue = numbers[0]
    for num in numbers{
        minValue = minValue &amp;lt; num ? minValue : num
        maxValue =  maxValue &amp;gt; num ? maxValue : num
    }
    return (maxValue ,minValue)
}
var numbers = [1,23,34,2,2,31,23,23,34,45,454545,4,54,5,45,45,45]
var result =  findMaxAndMin(numbers: numbers)
print(result?.max ?? 0,result?.min ?? 0)  
if let result =  findMaxAndMin(numbers: numbers) {
    print( result.max,result.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数的内部参数和外部参数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHelloTo(name:String, msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;)  //sayHelloTo(&amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;) 这种方式已被废弃

//内部参数和外部参数
func sayHelloTo(name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//修改外部参数名
func sayHello(to name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//隐藏调用参数
func mutiply(_ num1:Int, _ num2:Int) -&amp;gt; Int{
    return num1*num2
}
mutiply(2,  4) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认参数值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;) //可以省略后面的一个参数


func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;, punctuation:String = &amp;quot;!&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name) \(punctuation)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;)
sayHello(to: &amp;quot;Jack&amp;quot;, withMessage: &amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可变参数值&lt;/strong&gt; 一个函数至多只可以有一个变长的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//常用的变长参数函数
print(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
//求平均值
func mean(numbers:Double ...) -&amp;gt;Double{
    var sum : Double = 0
    for num in numbers{
        sum += num
    }
    return sum / Double(numbers.count)
}
mean(numbers: 1,2,3,4,5,5.0,23,434)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量参数,变量参数和 inout 参数&lt;/strong&gt; 默认的函数参数都是常量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func toBinary(num:Int)-&amp;gt;String{ //直接声明称 var 类型参数已被废弃。
    var num = num  
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
toBinary(num: 1000)

//inout 
func toBinary( num:inout Int)-&amp;gt;String{
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
var num = 100
toBinary(num: &amp;amp;num) //传入指针
print(num) 

//交换两个字符串
func swapTwoString(str1:inout String, str2:inout String){
    let tstr = str1
    str1 = str2
    str2 = tstr
}

var str1 = &amp;quot;a&amp;quot;
var str2 = &amp;quot;b&amp;quot;
swapTwoString(str1: &amp;amp;str1, str2:&amp;amp;str2)
str1
str2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数型变量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int, b:Int) -&amp;gt; Int{
    return a + b
}

let add01 = add
add01(3,4)
let add02:(Int, Int) -&amp;gt; Int = add
add02(4,5)


var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

arr.sort { (a, b) -&amp;gt; Bool in
    return a &amp;lt; b
}
arr

func descending (a:Int ,b:Int) -&amp;gt;Bool{
    return a &amp;gt; b
}
arr.sorted(by: descending)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数变成初步&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeScores( scors: [Int], by method:(Int)-&amp;gt; Int) -&amp;gt; [Int]{
    var arr = scors
    for (index , score) in scors.enumerated(){
        arr[index] = method(score)
    }
    return arr
}
func changeScore01 (score : Int) -&amp;gt; Int{
    return score + 3
}

func changeScore02 (score : Int) -&amp;gt; Int{
    return Int(Double(score)/150.0*100.0)
}

var arr:[Int] = []
for _ in 0..&amp;lt;10{
    arr.append(Int(arc4random())%150)
}
arr
changeScores(scors: arr, by: changeScore01)
changeScores(scors: arr, by: changeScore02)
//map 
arr.map(changeScore01)
func isPassOrFail(score:Int)-&amp;gt;String{
    return score &amp;lt; 60 ? &amp;quot;Fail&amp;quot;: &amp;quot;Pass&amp;quot;
}
arr.map(isPassOrFail)

//filter 过滤
func fail (score:Int)-&amp;gt; Bool{
    return score &amp;lt; 60
}
arr.filter(fail)

//reduce 聚合
func add(a:Int, b:Int)-&amp;gt; Int{
    return a + b
}
arr.reduce(0, add)

arr.reduce(0, +)

//Swift中,运算符号 本质上就是一个函数 
public func +(lhs: Int, rhs: Int) -&amp;gt; Int
public func *(lhs: Int, rhs: Int) -&amp;gt; Int
public func -(lhs: Int, rhs: Int) -&amp;gt; Int
public func /(lhs: Int, rhs: Int) -&amp;gt; Int
public func %(lhs: Int, rhs: Int) -&amp;gt; Int


func concatenate(str:String , num:Int) -&amp;gt; String{
    return &amp;quot;\(str)\(num) &amp;quot;
}
arr.reduce(&amp;quot;&amp;quot;, concatenate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;返回函数类型和函数嵌套&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//邮递费用
func tilerMailfeeByWight( weight : Int) -&amp;gt; Int{
    return 1*weight
}
func tiler2MailfeeByWight( weight : Int) -&amp;gt; Int{
    return 3*weight
}
//超过10单位，则按三倍计算
func feeBytUnitPrice (price :Int , wight:Int) -&amp;gt; Int{
    py
    func chooseMailFeeCalationByWeight(weight: Int) -&amp;gt; (Int) -&amp;gt; Int{
        return weight &amp;lt;= 10 ? tilerMailfeeByWight : tiler2MailfeeByWight
    }

    let mailFeefuc = chooseMailFeeCalationByWeight(weight: wight)
    return mailFeefuc(wight) + price*wight //邮递费用+商品费用
}
feeBytUnitPrice(price: 2, wight: 11)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-10 数据集合小节</title>
            <link>http://blog.flywithme.top/2017/02/22/swift10/</link>
            <pubDate>Wed, 22 Feb 2017 16:15:18 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift10/</guid>
            <description>&lt;p&gt;&lt;strong&gt;选择合适的数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;有序,最大的特定就是有序,如果我们操作的元素是有序的话,使用数组是最方便的。如果需要排序,最好也选择数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;集合&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;无序,唯一性,集合特有的操作,快速查找 如果需要做一些特殊的集合计算,就使用集合,比如在做用户特性分析的时候,分组的时候就可以使用
          集合,获取共同喜好,共同兴趣等。快速查找这个是集合的一大优势,数组查找复杂度是 O(n), 而集合的复杂度是 O(log2(n)),
          例如一个100万的数据,如果是数组查找的话,最坏的情况是
             查找100万次,而集合的最大次数是 log2(1000000) 大约是20次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字典&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;键值数据对,这个就不说了,使用的很广泛。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;回顾&lt;/strong&gt; &lt;code&gt;for in&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...10{
    print(index)
}

for c in &amp;quot;hello&amp;quot;.characters{
    print(c)
}

var arr = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
for str in arr{
    print(str)
}

for (index ,str) in arr.enumerated(){
    print(index, str)
}

var dic = [1:&amp;quot;a&amp;quot; , 2:&amp;quot;b&amp;quot;]
for key in dic{
    print(key)
}
for value in dic.values{
    print(value)
}

for (key, value) in dic{
    print(key,value)
}

var setA = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] as Set
for str in setA{
    print(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;还有很多没有涉及到的方法。这些方法需要我们在开发的过程中,慢慢学习了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-09 集合</title>
            <link>http://blog.flywithme.top/2017/02/22/swift09/</link>
            <pubDate>Wed, 22 Feb 2017 15:18:43 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift09/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;将一些元素放在一起,它们是无序的, 跟数组的不同是,数组是一个有序的列表,而集合是一个有序的数据集&lt;br /&gt;
   为什么需要集合,因为集合是无序的,所以,在做一些查找和判重的时候,效率会有差别。集合会有一些,比数组使用起来方便很多。
   &lt;strong&gt;集合中的每一个元素都是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//集合的初始化
var arr = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;] //如果不显式的声明,则默认是数组
var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  //必须显式声明才行

var emptySet1:Set&amp;lt;String&amp;gt; = []
var emptySet2 = Set&amp;lt;Int&amp;gt;()

var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;c&amp;quot;]) //将一个数组转换成集合 


setA.count
setA.isEmpty
setA.first //随机的取出一个元素

setA.contains(&amp;quot;a&amp;quot;) //判断是否有这个元素
//遍历    
for str in setA{
    print(str)
}

var str = setA.joined(separator: &amp;quot;d&amp;quot;)

//比较
setA == setB
setA.elementsEqual(setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集合的操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  
//插入
setA.insert(&amp;quot;D&amp;quot;) //返回一个元组
//更新
setA.update(with: &amp;quot;A&amp;quot;) //若已存在元素,则返回改元素,若没有,则返回nil
//删除
setA.remove(&amp;quot;a&amp;quot;) //返回一个 bool 若是 true 则表示删除成功,返回 false 则表示之前没有这个元素
setA.removeAll() 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;并集: &lt;code&gt;union&lt;/code&gt; (不改变调用者的集合), &lt;code&gt;formUnion&lt;/code&gt;  (改变调用者的集合)  两个集合中的所有元素集合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]
var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]) //将一根数组转换成集合

var setC =  setA.union(setB)  //setC 有 setA和 setB 所有元素,但是setA 不变
setA.union([&amp;quot;a&amp;quot;])

setA
setA.formUnion(setB) //setA 被改变
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;交集: &lt;code&gt;intersect&lt;/code&gt;(不改变调用者的集合),  &lt;code&gt;formIntersection&lt;/code&gt; (改变调用者的集合) 两个集合的公共部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.intersection(setB)
setA

setA.formIntersection(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;补集(差集): 做减法  &lt;code&gt;subtracting&lt;/code&gt; (不改变调用者的集合) &lt;code&gt;subtract&lt;/code&gt; (改变调用者的集合)   调用者不包含在被调用者中的部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.subtracting(setB)  //setA 独有的,而 setB 没有的元素 不改变 setA 值
setA

setA.subtract(setB) //setA 独有的,而 setB 没有的元素 改变 setA 值
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;去重: &lt;code&gt;symmetricDifference&lt;/code&gt;(不改变调用者的集合), &lt;code&gt;formSymmetricDifference&lt;/code&gt; (改变调用者的集合),   去除两个集合中相同的部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.symmetricDifference(setB)
setA
setA.formSymmetricDifference(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;子集: &lt;code&gt;isSbuset&lt;/code&gt; 子集, &lt;code&gt;isStrictSubset&lt;/code&gt; 真子集  判断是否是另外一个集合的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSubset(of: setB)
setA.isStrictSubset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;超集: &lt;code&gt;isSuperset&lt;/code&gt;超集 ,  &lt;code&gt;isStrictSuperset&lt;/code&gt; 真超集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSuperset(of: setB)
setA.isStrictSuperset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;相离:  &lt;code&gt;isDisjoint&lt;/code&gt; 没有重叠的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isDisjoint(with: setB)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-08 字典</title>
            <link>http://blog.flywithme.top/2017/02/22/swift08/</link>
            <pubDate>Wed, 22 Feb 2017 14:12:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift08/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;字典是存储 键-值 数据对的无序数据集合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
    dic[&amp;quot;key&amp;quot;]
var value = dic[&amp;quot;key&amp;quot;] //返回的 value 是一个可选型
    value = dic[&amp;quot;daaaa&amp;quot;]

    dict.isEmpty
    dict.count  

if let value = dic[&amp;quot;key&amp;quot;]{
    print(value)
 }    

var dict:[String:Int] = [&amp;quot;1&amp;quot;:1,&amp;quot;2&amp;quot;:2]
    dict[&amp;quot;1&amp;quot;]



var dict01:[Int:Int] = [1:1,2:2]
    dict01[1]

var dict02:[Int:Any] = [1:1,2:&amp;quot;a&amp;quot;]
    dict02[1]    

//遍历   
for (key, value) in dict{
        print(key,value)
}   

//比较
var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
dic[&amp;quot;key&amp;quot;]
var dic2 = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
dic2[&amp;quot;key&amp;quot;]dict == dict01
dic == dic2  //true  如果 元素类型不同,比较会抛错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;增删改查&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dic = [&amp;quot;key&amp;quot;:&amp;quot;value&amp;quot;, &amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;]
//查
dic[&amp;quot;key&amp;quot;]

//修改
dic[&amp;quot;key&amp;quot;]= &amp;quot;a&amp;quot;
//增加
dic[&amp;quot;c&amp;quot;] = &amp;quot;c&amp;quot; //若之前没有响应的 Key 则会添加
dic.updateValue(&amp;quot;d&amp;quot;, forKey: &amp;quot;d&amp;quot;)

//删除    
dic.removeValue(forKey: &amp;quot;key&amp;quot;)
if let key = dic.removeValue(forKey: &amp;quot;key&amp;quot;){
    print(&amp;quot;删除成功&amp;quot;)
}

//删除所有
dic.removeAll()


var str =  dic.updateValue(&amp;quot;value&amp;quot;, forKey: &amp;quot;key&amp;quot;) //返回值是原始值 str 的值是 &amp;quot;a&amp;quot;

//问题
 if  dic.updateValue(&amp;quot;jack01&amp;quot;, forKey: &amp;quot;nick&amp;quot;) == dic[&amp;quot;nick&amp;quot;] {
        print(&amp;quot;新旧昵称一样&amp;quot;)  //会不会打印出来?
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-07 数组</title>
            <link>http://blog.flywithme.top/2017/02/21/swift07/</link>
            <pubDate>Tue, 21 Feb 2017 15:38:45 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/21/swift07/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;数组是 Swift 三种最基本的数据集合的一种,这三种集合分别是: &lt;code&gt;Array Dictionary set&lt;/code&gt;
数组的概念就是一个有序的数据序列,概念很简单,我们已经很熟悉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;初始化方式&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var numbers = [0,1,2,3] 
var num:[Int] = [0,1,2] //只能是 Int 类型
var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] //只能是 字符串
var arr1:[Any] = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,1,num,arr] //里面的元素可以为任意类型

var arr0: Array&amp;lt;String&amp;gt; = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
var arr01 = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,1] as [Any]

//空数组的声明方式
var emptyArr1:[Int] = []
var emptyArr2:Array&amp;lt;Int&amp;gt; = []
var emptyArr3 = [Int]()

//重复数组初始化
var allzZeros = [String](repeatElement(&amp;quot;a&amp;quot;, count: 4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数组的基本查询 属性方法 &lt;code&gt;count ,isEmpty, first, last, max, min, [], contains, index, for in enumerated, compare&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]

arr.count //判断数组长度
arr.isEmpty //判空

arr[1]     //索引数组中第二个元素

//取值
arr.first
arr.last
var fistElement =  arr.first  // 返回的是一个可选型。

//最大最小
arr.max()
arr.min()

//区间
arr[0...2]
arr[0..&amp;lt;2]

//判断是否包含
arr.contains(&amp;quot;c&amp;quot;)

//获取位置
arr.index(of: &amp;quot;b&amp;quot;)
arr.index(of: &amp;quot;add23&amp;quot;)

//遍历
for str in arr{
    print(str)
}

for (index, str ) in arr.enumerated(){
    print(index, str)
}

//数组比较
var arr1 = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
arr == arr1  //数组比较。。 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;数组的&lt;strong&gt;增删改&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]

//增加元素
arr.append(&amp;quot;d&amp;quot;)
arr += [&amp;quot;a&amp;quot;]  // 后面必须跟同数据类型的数组
arr.insert(&amp;quot;x&amp;quot;, at: 2)  //在某一个位置添加,注意越界问题

//删除元素
arr.removeFirst(2) //删除数组首2个元素
arr.removeLast(3) //删除数组尾部3个元素
arr.remove(at: 2)  //删除第二个元素
arr.removeSubrange(0...1)
arr.removeSubrange(0..&amp;lt;2)
//arr.removeAll()

//修改元素  
arr[0] = &amp;quot;hello&amp;quot; 修改第一个元素 为 &amp;quot;hello&amp;quot;
arr[0...2] = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] //修改区间中的元素为新元素 
arr[0...2] = [&amp;quot;a&amp;quot;] //修改区间中的元素为新元素 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;二维数组&lt;/strong&gt;  其实就是一维数组中的元素都是一维数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr:[Array&amp;lt;String&amp;gt;] = [[&amp;quot;a&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]] //元素必须都是 String
var arrtemp = arr[0]  
var str = arr[0][0]  
var arr01:[Array&amp;lt;Any&amp;gt;] = [[&amp;quot;a&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;],[1,2,3]] //任意元素,使用时需要谨慎。经常会有各种解包问题
var int = arr01[2][1] as! Int

arr.append([&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;]) //在二维数组的尾部添加新的数组元素
arr[0].append(&amp;quot;b&amp;quot;) //给二维数组的第一个数组元素 添加一个String

arr += [[&amp;quot;b&amp;quot;,&amp;quot;d&amp;quot;]]   //+的也需要是二维数组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NSArray&lt;/strong&gt; NSArray 和 Array 的区别就是 NSArray 是一个类,而 Array 是一个结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr000 = [1, 2, 3, 4] as NSArray
var arr001:NSArray = [&amp;quot;a&amp;quot;]
var arr002:NSArray = [1, 2, &amp;quot;hello&#39;&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;遗留问题&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var arr000 = [1, 2, 3, 4]
 var arr001 = [&amp;quot;a&amp;quot;]
 var arr002 = [[1],[2],[3],[&amp;quot;a&amp;quot;],arr000] as [Any]

 //如何在 arr002 中获取第五个元素,然后解包这个元素。
 var arr = arr002[4]   //对 arr的解包,如何顺利进行。
 //arr[0]  //error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//问题解决&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr0001 = arr1[5] as! Array&amp;lt;String&amp;gt;
arr0001[1] 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-06 可选型 Optionals</title>
            <link>http://blog.flywithme.top/2017/02/20/swift06/</link>
            <pubDate>Mon, 20 Feb 2017 15:22:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/20/swift06/</guid>
            <description>&lt;p&gt;画重点!
Optionals 是 swift 新加入的类型,所以之前的 Objective-C 中是没有这个概念的。可选型 简单一些理解就是:有值的时候就有值,无值的时候
是 nil. 但是 swift 的 nil 和其他语言中的 nil 不一样,nil 本身也是一中类型,nil就是没有,不是任何一个值,是和其他类型严格区分开的。&lt;/p&gt;

&lt;p&gt;可选型不是表示 可以表示任意类型,而是可以表示一个指定数据类型 和 nil类型,&lt;/p&gt;

&lt;p&gt;错误代码示范&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: String = &amp;quot;loveway&amp;quot;
name = nil //报错 error: Nil cannot be assigned to type &#39;String&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optionals的声明&lt;/strong&gt; &lt;code&gt;var optionalInteger: Int? , var optionalInteger: Optional&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: String? = &amp;quot;loveway&amp;quot;
print(name!)
name = nil
print(name as Any)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选型的解包&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name: Optional&amp;lt;String&amp;gt; = &amp;quot;lazy&amp;quot;
print(name!)
name = nil
print(name as Any )
name = &amp;quot;sam&amp;quot;
//var string = &amp;quot;my name is &amp;quot; + name  //error 因为 ```name```是一个未解包的数据,不能直接使用。
var string = &amp;quot;my name is &amp;quot; + name!  //强制解包
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;后面加一个 叹号 &lt;code&gt;!&lt;/code&gt; 可以强制解包 但是 name 有可能出现为 nil 的情况,这是有风险的。可能
        会造成 app 崩溃。所以在使用之前需要对 &lt;code&gt;name&lt;/code&gt; 进行判空&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var name: Optional&amp;lt;String&amp;gt; = &amp;quot;lazy&amp;quot;
var age : Optional&amp;lt;Int&amp;gt; = 24

if name != nil {
    var string = &amp;quot;my name is &amp;quot; + name!
}else{
     &amp;quot;name is nil&amp;quot;
}

//或者
if let unwrapName = name{ //自动解包 name 数据到 unwrapName
    var string = &amp;quot;my name is &amp;quot; + unwrapName
}else{
          &amp;quot;name is nil&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;两个数据都解包成功之后才会进入判断方法中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if let unwrapName = name,let unwrapAge = age{
    var string = &amp;quot;my name is &amp;quot; + unwrapName + &amp;quot;age is \(unwrapAge)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;添加限制条件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if let unwrapName = name,let unwrapAge = age , unwrapAge &amp;gt; 20{
    var string = &amp;quot;my name is &amp;quot; + unwrapName + &amp;quot;age is \(unwrapAge)&amp;quot;
}

if let name = name,let age = age , age &amp;gt; 20{
    var string = &amp;quot;my name is &amp;quot; + name + &amp;quot;age is \(age)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional Chaining&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var errorMsg:String? = nil
print(errorMsg as Any)
errorMsg = &amp;quot;404&amp;quot;
//重点 尝试解包 ```?```
errorMsg?.uppercased() //尝试解包,如果成功就调用方法,如果失败,就停止 

//如果确认 ```errorMsg```有值,可以使用,否则很容易出错。 
errorMsg!.uppercased() //强制解包,如果 ```errorMsg``` 是 nil 则会报错,这样写会不安全。

var temp = errorMsg?.uppercased() //temp 依然是一个可选型

var msg = errorMsg == nil ? &amp;quot;No error&amp;quot; : errorMsg!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional在元组中的使用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var error :(errorCode: Int , errorMsg:String?) = (404, &amp;quot;Not found&amp;quot;)
error.errorMsg = nil

var error1 :(errorCode: Int , errorMsg:String)? = nil
error1 = nil

var error2 :(errorCode: Int , errorMsg:String?)? = nil
error2?.errorMsg = nil
error2 = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Optional 的应用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ageInput:String = &amp;quot;ads&amp;quot;
var age = Int(ageInput) //返回的 age 类型是可选型。
if let age = Int(ageInput), age &amp;gt; 18{ //这里的 age 的类似又是什么呢? 
    print(&amp;quot;成年了&amp;quot;)
}


var str = &amp;quot;hello world&amp;quot;
var range =  str.range(of: &amp;quot;ll&amp;quot;)
range?.lowerBound
range?.upperBound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;隐式可选型&lt;/strong&gt;  隐式可选型在使用的时候可以不进行解包直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var errorMsg:String! = nil
errorMsg = &amp;quot;Not found&amp;quot;
&amp;quot;messge &amp;quot; + errorMsg  //使用的时候必须保证 errorMsg 不为空,要不然程序会报错。




class Student{
    let name:String
    var age:Int
    var stdId:Int
    unowned var aClass:Class //避免循环引用
    init(name:String,age:Int,stdId:Int,aClass:Class){
        self.name = name
        self.age = age
        self.stdId = stdId
        self.aClass = aClass
    }
}

class Class{
    var className:String = &amp;quot;&amp;quot;
    var classNum:Int = 0
    var monitor:Student! //若不设置成可选型，则在下面初始化的时候回造成死循环

    init(className:String, classNum:Int, monitorName:String) {
        self.className = className;
        self.classNum = classNum;
        self.monitor = Student(name: monitorName, age: 18, stdId: 20, aClass: self)
    }
    func showInfo(){
        print(&amp;quot;this is \(classNum)&amp;quot;)
        print(&amp;quot;monitor is \(monitor.name)&amp;quot;)
    }
}

let class001 = Class(className: &amp;quot;0101&amp;quot;, classNum: 1001, monitorName: &amp;quot;jack&amp;quot;)
class001.monitor
class001.showInfo()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-05 逻辑控制</title>
            <link>http://blog.flywithme.top/2017/02/17/swift05/</link>
            <pubDate>Fri, 17 Feb 2017 17:34:01 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/17/swift05/</guid>
            <description>&lt;p&gt;控制流的三种基本结构:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;顺序结构&lt;/strong&gt;:  顺序语句有语句序列组成,程序执行时,按照语句顺序,从上而下,一条一条顺序执行&lt;br /&gt;
 &lt;strong&gt;循环结构&lt;/strong&gt;   循环语句使用同一个语句组根据一定的条件执行若干次&lt;br /&gt;
 &lt;strong&gt;选择结构&lt;/strong&gt;:  分支语句根据一定的条件决定执行那一部分语句序列
顺序结构不再多说&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;循环结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for _ in 0...100{
    print(&amp;quot;遍历循环&amp;quot;) 
}
    
//这种方式在 swift3 中被废弃,不能在使用
//for var i = 1; i &amp;lt; 100 ; i++{
//    print(&amp;quot;遍历循环中&amp;quot;)
//}
    
    
var a = 0.0
while a &amp;lt; 50 {
    a += 0.5
    sin(a)   
}
    
//至少执行一次
repeat{
    a += 0.5
    sin(a)
}while a &amp;lt; 100
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if true {
        
}else if(1 == 1){
        
}else{
        
}
    
    
switch index {
case 0:
    break
case 1:
    break
case 2:
    break
default: break
}
    
//swift 提供的基础数据类型都可以用作 switch 的判断
var str = &amp;quot;a&amp;quot;
switch str {
case &amp;quot;a&amp;quot;,&amp;quot;A&amp;quot;:
    print(&amp;quot;A&amp;quot;)
case &amp;quot;b&amp;quot;:
    print(&amp;quot;B&amp;quot;)
default:
    break
    
}


//区间
let age = 19
switch age {
case 0..&amp;lt;18:
    print(&amp;quot;未成年&amp;quot;)
case 18..&amp;lt;30:
    print(&amp;quot;青年&amp;quot;)
case 30..&amp;lt;60:
    print(&amp;quot;壮年&amp;quot;)
default:
     break
}

//元组    
let point = (5, 2)
    
switch point {
case (0,0):
    print(&amp;quot;原点&amp;quot;)
case (0,1):
    print(&amp;quot;1&amp;quot;)
case (0,2):
    print(&amp;quot;2&amp;quot;)
case (_,2): //可以忽略某一个维度的值
    print(&amp;quot;_ 2&amp;quot;)
case (-10...10,2...5): //元组中,同样可以使用区间
    print(&amp;quot;_ 2&amp;quot;)
default:
    print(&amp;quot;没找到&amp;quot;)
}
    
//解包
let point1 = (5, 2)
switch point1 {
case (0,0):
    print(&amp;quot;原点&amp;quot;)
case (let x,0):
    print(&amp;quot;x 轴 \(x)&amp;quot;)
case (0,let y):
    print(&amp;quot;y 轴  \(y)&amp;quot;)
case (let x, let y):
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;where&lt;/strong&gt;  限定匹配条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch point {
case (0,0) :
    print(&amp;quot;原点&amp;quot;)

case (let x,0):
    print(&amp;quot;x 轴 \(x)&amp;quot;)
case (0,let y):
    print(&amp;quot;y 轴  \(y)&amp;quot;)
case (let x, let y) where x == y :
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
case  let(x, y ) where x == -y :
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
case (let x, let y):
    print(&amp;quot;x = \(x), y = \(y)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;if case&lt;/strong&gt;  简化 switch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = 19 
if case 18...20 = age {
    print(&amp;quot;青年&amp;quot;)
}

// 对 case 增加一个限定条件
if case 18...30 = age, age &amp;gt;= 19 {
    print(&amp;quot;青年&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;for case where&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for case let index in 1...100 where index % 7 == 0{
    print(index)
}

for  index in 1...100 where index % 7 == 0{
    print(index)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;控制转移&lt;/strong&gt;   &lt;code&gt;break&lt;/code&gt; 跳出本层循环体,提前结束循环 。   &lt;code&gt;continue&lt;/code&gt; 结束当前循环体,进行下一次循环   &lt;code&gt;fallthrough&lt;/code&gt; 执行完当前case 之后 进入下一个 case&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while true {
    a += 0.5
    if a == 5.5{
        continue
    }
    sin(a)
    if a &amp;gt; 50{
        break
    }
}

var str = &amp;quot;a&amp;quot;
switch str {
case &amp;quot;a&amp;quot;,&amp;quot;A&amp;quot;:
    print(&amp;quot;A&amp;quot;)
    fallthrough //执行完之后 ,跳入下一个 case 语句
case &amp;quot;b&amp;quot;:
    print(&amp;quot;B&amp;quot;)
    fallthrough //执行完之后 ,跳入下一个 case 语句
default:
    print(&amp;quot;C&amp;quot;)
}

//给 for 循环加一个名字,可以使用 break 结束这个循环。 谨慎使用。
findanswer:for x in 1...300{
    for y in 1...300{
        print(x, y)
        if x == 4,y == 5 {
            break findanswer
        }

    }
}
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;guard&lt;/strong&gt; 关键字守护  &lt;code&gt;guard  bool condition  else&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func buyComputer(money:Int, price:Int, brand:String){
    guard money &amp;gt; price else {
        print(&amp;quot;钱不够&amp;quot;)
        return
    }

    guard brand == &amp;quot;Apple&amp;quot; else {
        print(&amp;quot;不是苹果电脑&amp;quot;)
        return
    }
}
buyComputer(money: 9000, price: 6000, brand: &amp;quot;Sony&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-04 基础运算符</title>
            <link>http://blog.flywithme.top/2017/02/17/swift04/</link>
            <pubDate>Fri, 17 Feb 2017 11:00:55 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/17/swift04/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;赋值运算符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;=&lt;/strong&gt;  这里是没有返回值的。返回值可能是Void，此时不等于nil，即赋值成功；或等于nil，即赋值失败&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 3  
a = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数学运算符  &lt;code&gt;+ - * / +=  -= %&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 201
var b  = 4
a + b
a * b
a - b
a / b
a % b
a += 1
+a
-a
a += 2
a -= 3
a *= 2
a /= 2
a %= 2    
    
var u = 2.5.truncatingRemainder(dividingBy: 1.2) //小数求余
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑运算符  &lt;code&gt;! &amp;amp;&amp;amp; ||&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var isTrue:Bool = true , isFalse:Bool = false
!isTrue
isTrue &amp;amp;&amp;amp; isFalse
isTrue || isFalse
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比较运算符   &lt;code&gt;== != &amp;gt; &amp;gt;= &amp;lt; &amp;lt;=&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let money = 100
let price = 20
if money &amp;gt;= price{
    print(&amp;quot;buy&amp;quot;)
}
    
let capacity = 30 //背包容量
let volume = 40 //购买物体积
    
if money &amp;gt;= price &amp;amp;&amp;amp; capacity &amp;gt;= volume{
    print(&amp;quot;buy it&amp;quot;)
}
    
if money &amp;lt; price || capacity &amp;lt; volume{
    print(&amp;quot;can not buy it&amp;quot;)
}
    
if  !(money &amp;gt;= price &amp;amp;&amp;amp; capacity &amp;gt;= volume){
     print(&amp;quot;can not buy it&amp;quot;)
}
    
//登陆
var isUserNameOK = false
var isPasswordOk = false
    
var isPhoneNumOk = true
var isPhoneCodeOk = false
    
if isUserNameOK &amp;amp;&amp;amp; isPasswordOk || isPhoneNumOk &amp;amp;&amp;amp; isPasswordOk{
    print(&amp;quot;登陆成功&amp;quot;)
}else{
    print(&amp;quot;登陆失败&amp;quot;)
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三目运算符   bool?answer1:answer2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var battery = 19
var batteryColor:UIColor
batteryColor =  battery &amp;lt;= 20 ? UIColor.red:UIColor.green
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;区间运算符  闭区间运算符 &lt;code&gt;[a, b] a...b&lt;/code&gt; , 前闭后开区间运算符 &lt;code&gt;[) a..&amp;lt;b&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...10{
    index
}
    
for index in 1..&amp;lt;10{
        index
}
        
let arr = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
for str in arr{
    print(str)
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-03 基础类型</title>
            <link>http://blog.flywithme.top/2017/02/16/swift03/</link>
            <pubDate>Thu, 16 Feb 2017 16:11:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift03/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常量 &lt;strong&gt;let&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a = 1
let b:Int
b = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量 &lt;strong&gt;var&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var b = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;swift 是一个强类型语言:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1

x = &amp;quot;abc&amp;quot; //会报错(Cannot assign value of type &amp;quot;String&amp;quot; to type &amp;quot;int&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示声明变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s:String = &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一次声明多个变量,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var y, z, d:Double
var x = 1, y = 2, z = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;常用数据类型: Int , Float ,Double , Boolean , String ,Tuple&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Int&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var aInt: Int = 20 //整型的存储空间是有限的,根据不同的计算机来定。有最大最小值
Int.max
Int.min

var aUInt:UInt = 200  //无法存储负数,最大值是 Int 的两倍+1
UInt.max
UInt.min
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Int 的类型&lt;br /&gt;
   !&lt;img src=&#34;sources/swift/Int类型.png&#34; alt=&#34;intType&#34; /&gt;&lt;/p&gt;

&lt;p&gt;小知识 如果是一个比较大的数值,可以使用下划线对数字进行分割&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let bigNum = 1_000_000_000_00232
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/swift/BA6D5746-A4AE-411F-905E-4761288DEE0F.png&#34; alt=&#34;C8A54525-8DE7-4EC3-8665-89146D67C0CF&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Float Double&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浮点数 float Double 区别&lt;br /&gt;
    &lt;img src=&#34;sources/swift/C1DB90FE-EE4F-4CC2-95F3-580D54437E75.png&#34; alt=&#34;C8A54525-8DE7-4EC3-8665-89146D67C0CF&#34; /&gt;&lt;/p&gt;

&lt;p&gt;//上面的数字加下划线 亦可以用在小数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var aFloat = 1_000_000.000_0001  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不同数据类型之间不能直接做数据运算,不能自动做类型转换。必需要做显示类型转换,以防止运算出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a:Int = 1
let b:UInt = 2
a + b //错误,运算歧义 
a + Int(b) //正确
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;swift 是一个强制类型语言,把浮点数赋值给整型是肯定会报错的。除非对浮点数进行转换才行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Boolean&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let aTrue:Bool = true
let aFalse = false

if aTrue{
    print(&amp;quot;True&amp;quot;)
}else if(1 == 1){
    print(&amp;quot;1 == 1&amp;quot;)
}
else{
    print(&amp;quot;False&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if 判断语句 只能使用 Bool 类型判断,否则会报错&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tuple&lt;/strong&gt; 元组就是将多个不同的值集合在一个数据中。可以有任意多个值,多个不同的数据类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var point = (1 , 1)
var httpResponse = (401, &amp;quot;未授权&amp;quot;)

// 显式指定元组类型
var point2:(Int, Int, Int) = (2, 3, 4)

var httpResponse2:(Int, String) = (200, &amp;quot;OK&amp;quot;)

//取值
httpResponse.0
httpResponse.1

//解包
let (x, y) = httpResponse2
print(x, y)

//给分量加一个名字。
let point3 = (x: 3, y :4)
point3.x
point3.y

let point4:(x: Int, y: Int) =(2, 3)
point4.x
point4.y

let point5 = (10,23)
let (z, _) = point5 //若不需要解包某一个数据,可以用下划线_忽略一些值
z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;   使用双引号引起来的一段文本。&lt;/p&gt;

&lt;p&gt;字符串基本用法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//声明一个字符串
var str: String = &amp;quot;swift&amp;quot;
let str1 = String(&amp;quot;abdd&amp;quot;)

//空字符串
var emptyStr = &amp;quot;&amp;quot;
var emptystr1 = String()

str.isEmpty //字符串判空

let a = &amp;quot;abc&amp;quot;
str + a 

str += a

str1 += a //错误 常量不能被改变

//字符串插值  字符串插值是一种全新的构建字符串的方式，可以在其中包含常量、变量、字面量和表达式。您插入的字符串字面量的每一项都被包裹在以反斜线为前缀的圆括号中：
let name  = &amp;quot;jack&amp;quot;
let age = 20
let s = &amp;quot;My name is \(name), age is \(age)&amp;quot;

// \是转义字符  \t 是制表符  \n 是换行符
let s2 = &amp;quot;\\&amp;quot; //输出转义字符
print(s2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello. swift&amp;quot;

for c in str.characters{
    print(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mark:Character = &amp;quot;!&amp;quot; //字符

str + String(mark) //不改变 str 

str.append(mark) //改变 str 值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 swift 中一个中文字符和表情符都可以是一个字符(其他语言中可能需要多个字符才能标识)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dog:Character = &amp;quot;🐶&amp;quot;
let chinessLetter :Character = &amp;quot;程&amp;quot;
let coolguy: Character = &amp;quot;\u{1F60E}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串长度 :swift 更倾向于人类理解,而不是机器理解。  但是这会导致 swift 处理大批量字符串的时候速度比较慢&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var strLetters = &amp;quot;abcdef\u{1F60E}&amp;quot;
strLetters.characters.count //长度计算 为7
strLetters = &amp;quot;中国&amp;quot;
strLetters.characters.count //长度计算 为2

var cafe = &amp;quot;café&amp;quot;  //字符串长度是多少?

cafe = &amp;quot;cafe\u{0301}&amp;quot; //字符串长度是多少?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何索引获取字符串中的字符   //这个处理几个版本变化很大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello, swift&amp;quot; 
let startIndex =  str.index(str.startIndex, offsetBy: 2) //距离起点字符偏移位置
str[startIndex] //
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var varA   = &amp;quot;Hello, Swift!&amp;quot;
var varB   = &amp;quot;Hello, World!&amp;quot;

if varA == varB {
   print( &amp;quot;\(varA) 与 \(varB) 是相等的&amp;quot; )
} else {
   print( &amp;quot;\(varA) 与 \(varB) 是不相等的&amp;quot; )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串 filter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let str2 = &amp;quot;    a  b  c  d &amp;quot;
let res = String(str2.characters.filter  { $0 != &amp;quot; &amp;quot; })
res
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串插入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let c:Character = &amp;quot;1&amp;quot;
str.insert(c, at: startIndex)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串大小写转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var str = &amp;quot;hello, swift&amp;quot;
let shouty = str.uppercased()
let shoutx = str.lowercased()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断字母首尾是否为某特定字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str.hasPrefix(&amp;quot;hello&amp;quot;)
str.hasSuffix(&amp;quot;swift&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制类型转换  as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s2 = NSString(format:&amp;quot;1/3 =  %.2f&amp;quot;, 1.0/3.0) as String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NSString&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let s3:NSString = &amp;quot;😄哈&amp;quot;
s3.length
s3.character(at: 1)
let s4 = &amp;quot;    hello world    &amp;quot; as NSString

s4.trimmingCharacters(in: .whitespaces) //去除空格
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-02 初见</title>
            <link>http://blog.flywithme.top/2017/02/16/swift02/</link>
            <pubDate>Thu, 16 Feb 2017 11:27:44 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/16/swift02/</guid>
            <description>&lt;p&gt;首先我们来在屏幕上输出一个 &lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要 import 任何库,可以直接在全局作用域使用。代码结尾不要带分号。&lt;/p&gt;

&lt;p&gt;Xcode 提供了代码预览功能 &lt;strong&gt;Playground&lt;/strong&gt; . 使用它可以加快 swift的学习速度&lt;/p&gt;

&lt;p&gt;初始化一个变量和常量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  a = 2  //可变数据
a = 3
let b = 2 //不可变
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if else&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if a == 2{
     print(&amp;quot;true&amp;quot;)
 } else{
     print(&amp;quot;false&amp;quot;)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for in 遍历语句(此外还有 ,repeat..while ,for 循环3.0中已经被弃用)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 0...100{
   var c = Double(index)/20.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while 1 == 1 {
    a += 1
    if a == 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;repeat&amp;hellip; while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repeat
{
    a += 1
    if a &amp;gt; 100{
        break
    }
    print(&amp;quot;do something&amp;quot;,a)

}while( 1 == 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;断言&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let age = -3 
assert(age &amp;gt;= 0, &amp;quot;A person&#39;s age cannot be less than zero&amp;quot;) 
// 因为 age &amp;lt; 0，所以断言会触发  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面开始深入学习&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
