<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学习笔记 on JKCoder&#39;s Blog </title>
        <link>http://www.flywithme.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Thu, 14 Jul 2016 11:40:29 CST</updated>
        
        <item>
            <title>iOS 开发Debug工具壳</title>
            <link>http://www.flywithme.top/2016/07/14/debugpanel/</link>
            <pubDate>Thu, 14 Jul 2016 11:40:29 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://www.flywithme.top/2016/07/14/debugpanel/</guid>
            <description>

&lt;h5 id=&#34;初衷:bccb225b752499f845bd206d74979637&#34;&gt;初衷&lt;/h5&gt;

&lt;p&gt;移动端开发的时候总会遇到需要切换设备环境,或者切换服务器环境,或者查看一些测试 Log的时候. 这个时候免不了需要调取一下设备信息, 所以就想做一个固定在状态栏上的的
 Debug 功能控件,之前公司也有一个旧的类似控件,但是里面牵连业务非常多,而且扩展也不友好,所以我就想趁着有新项目需求的时候写一个顶部的控件壳子,
 而且可以很方便的扩展方法,当然,需要的测试方法依然需要开发者手动添加,这个控件并不侵入业务,以后如果有需要可以做一些设备基础功能的公用方法.
 暂时这个工具只有一个非常简单的工具壳,使用起来应该也不算麻烦.下面是使用方法&lt;/p&gt;

&lt;p&gt;效果如下图:
  &lt;img src=&#34;http://www.flywithme.top/sources/DebugPanel/01.gif&#34; alt=&#34;01&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;使用方法:bccb225b752499f845bd206d74979637&#34;&gt;使用方法&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;Podfile&lt;/strong&gt;&lt;br /&gt;
   To integrate DebugPanel into your Xcode project using CocoaPods, specify it in your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; source &#39;https://github.com/CocoaPods/Specs.git&#39;
 platform :ios, &#39;7.0&#39;
 target &#39;TargetName&#39; do
 pod &#39;DebugPanel&#39;  , :git =&amp;gt;&#39;https://github.com/brasbug/DebugPanel.git&#39;
 end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then ,runthe following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;参数说明:&lt;/strong&gt;&lt;br /&gt;
   &lt;code&gt;MTADebugModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
  *  @author Jack, 16-07-14 12:07:12
  *
  *  title: 显示名称
  *  selectorProperty: 调用的方法签名
  *  etc: 额外参数
  */
  @property (nonatomic, strong) NSString *title;
  @property (nonatomic, strong) NSDictionary *etc;
  @property (nonatomic, strong) NSString *selectorProperty;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MTADebugMethodBridge&lt;/code&gt;  使用者需要把MTADebugModel中命名的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在方法调用的时候根据传入的参数生成相应的 selector 
- (BOOL)handleSelectorProperty:(MTADebugModel *)modelProperty
{
    if (modelProperty &amp;amp;&amp;amp; modelProperty.title &amp;amp;&amp;amp; modelProperty.selectorProperty.length) {
        SEL selector = [self selectorForMethod:modelProperty.selectorProperty];
        if (!selector || ![self respondsToSelector:selector]) {
            return NO;
        }
#pragma clang diagnostic push
#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;
        [self performSelector:selector withObject:modelProperty];
        NSLog(@&amp;quot;%@&amp;quot;,modelProperty);
#pragma clang diagnostic pop
        return YES;
    }
    return NO;
}
//生成相应的方法
- (SEL)selectorForMethod:(NSString *)method {
    if ([method length] == 0) return nil;
    NSString *objcMethod = [[@&amp;quot;debugapi_&amp;quot; stringByAppendingString:method] stringByAppendingString:@&amp;quot;:&amp;quot;];
    return NSSelectorFromString(objcMethod);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;br /&gt;
  如果需要在&lt;code&gt;didFinishLaunchingWithOptions&lt;/code&gt;或者是 rootiew 中启动,一定要使用`&lt;code&gt;performSelector&lt;/code&gt;方法延迟调用启动 debug 按钮&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    [self performSelector:@selector(doJobsAfterFinishLaunching) withObject:nil afterDelay:0];
    return YES;
}

- (void)doJobsAfterFinishLaunching
{
    NSMutableArray *arrlist = [NSMutableArray array];

    MTADebugModel *item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;一键线上&amp;quot;;
    item.selectorProperty = @&amp;quot;changeOnlineServer&amp;quot;;
    item.etc = @{@&amp;quot;host&amp;quot;:@&amp;quot;http://www.baidu.com&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;一键测试&amp;quot;;
    item.selectorProperty = @&amp;quot;changeTestServer&amp;quot;;
    item.etc = @{@&amp;quot;host&amp;quot;:@&amp;quot;http://www.sohu.com&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;调试面板&amp;quot;;
    item.selectorProperty = @&amp;quot;showDebugPanel&amp;quot;;
    //    item.etc = @{@&amp;quot;a&amp;quot;:@&amp;quot;b&amp;quot;};
    [arrlist addObject:item];

    item = [[MTADebugModel alloc]init];
    item.title = @&amp;quot;打开 URL&amp;quot;;
    item.selectorProperty = @&amp;quot;OpenSchemeURL&amp;quot;;
    //    item.etc = @{@&amp;quot;c&amp;quot;:@&amp;quot;d&amp;quot;};
    [arrlist addObject:item];

    [[MTADebugpanel shareInstance]startDebugBar:YES methodModels:arrlist error:^(NSString *errMsg) {
        NSLog(@&amp;quot;%@&amp;quot;,errMsg);
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这一步很重要&lt;/strong&gt;&lt;br /&gt;
   创建&lt;code&gt;MTADebugMethodBridge&lt;/code&gt;的 &lt;code&gt;category&lt;/code&gt; 实现你在 &lt;code&gt;MTADebugModel&lt;/code&gt; 中的&lt;code&gt;selectorProperty&lt;/code&gt; 参数方法,需要加上 &lt;code&gt;debugapi_&lt;/code&gt;的签名前缀&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)debugapi_changeOnlineServer:(MTADebugModel *)parameters{
// TODO  Do Your Job
}


- (void)debugapi_OpenSchemeURL:(MTADebugModel *)parameters{
    // TODO  Do Your Job
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>golang-gin 框架学习 一、 GET POST Method</title>
            <link>http://www.flywithme.top/2016/06/30/Go-gin01/</link>
            <pubDate>Thu, 30 Jun 2016 18:16:12 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://www.flywithme.top/2016/06/30/Go-gin01/</guid>
            <description>

&lt;h5 id=&#34;前言:2551b16abac86e66e05bae7b2b34a895&#34;&gt;前言&lt;/h5&gt;

&lt;p&gt;一直想学一些新的东西,自从接触了 Go 语言,然后学了一些基本语法,但是基本上还是停留在知道这么个语言的阶段,没有深入的了解过.&lt;br /&gt;
 所以就选了一个文档比较齐全的 Gin 来写我的第一个 webServer 项目.这只是一个 Demo ,写这个日志是为了记录自己的学习历程.激励下自己吧.&lt;/p&gt;

&lt;h6 id=&#34;gin-api:2551b16abac86e66e05bae7b2b34a895&#34;&gt;Gin API&lt;/h6&gt;

&lt;p&gt;搭建Web 服务器少不了要写 api 首先从最简单的 GET POST 开始.&lt;br /&gt;
 首先要初始化一个路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    router := gin.Default()//初始化路由
    router.Run(&amp;quot;:8080&amp;quot;) // listen and GO on 0.0.0.0:8080
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;get-method:2551b16abac86e66e05bae7b2b34a895&#34;&gt;GET Method&lt;/h6&gt;

&lt;p&gt;这个最基本的网络请求在 gin 几行代码就可以搞定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.GET(&amp;quot;/user/:name/:action&amp;quot;, func(c *gin.Context) {
        name := c.Param(&amp;quot;name&amp;quot;)
        action := c.Param(&amp;quot;action&amp;quot;)
        message := name + &amp;quot; is &amp;quot; + action
        c.String(http.StatusOK, message)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
 &lt;img src=&#34;sources/GoGin01/20160630-0.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) {
        firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;)
        lastname := c.Query(&amp;quot;lastname&amp;quot;) // shortcut for c.Request.URL.Query().Get(&amp;quot;lastname&amp;quot;)

        c.String(http.StatusOK, &amp;quot;Hello %s %s&amp;quot;, firstname, lastname)
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
  &lt;img src=&#34;sources/GoGin01/20160631-0.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.POST(&amp;quot;/form_post&amp;quot;, func(c *gin.Context) {
        message := c.PostForm(&amp;quot;message&amp;quot;)
        nick := c.DefaultPostForm(&amp;quot;nick&amp;quot;, &amp;quot;anonymous&amp;quot;)

        c.JSON(200, gin.H{
            &amp;quot;status&amp;quot;:  &amp;quot;posted&amp;quot;,
            &amp;quot;message&amp;quot;: message,
            &amp;quot;nick&amp;quot;:    nick,
        })
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;post-method:2551b16abac86e66e05bae7b2b34a895&#34;&gt;POST Method&lt;/h6&gt;

&lt;p&gt;一样只需要几行代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.POST(&amp;quot;/post&amp;quot;, func(c *gin.Context) {

    id := c.Query(&amp;quot;postid&amp;quot;)
    page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;)
    name := c.PostForm(&amp;quot;name&amp;quot;)
    message := c.PostForm(&amp;quot;message&amp;quot;)

    fmt.Printf(&amp;quot;id: %s; page: %s; name: %s; message: %s&amp;quot;, id, page, name, message)

    c.JSON(200, gin.H{
        &amp;quot;status&amp;quot;:  &amp;quot;posted&amp;quot;,
        &amp;quot;id&amp;quot;: id,
        &amp;quot;page&amp;quot;:page,
        &amp;quot;name&amp;quot;:name,
        &amp;quot;message&amp;quot;:message,

    })
}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
 &lt;img src=&#34;sources/GoGin01/20160631-1.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type postForm1 struct {
        UserId     string `form:&amp;quot;userid&amp;quot; binding:&amp;quot;required&amp;quot;`
        Page string `form:&amp;quot;page&amp;quot; binding:&amp;quot;required&amp;quot;`
    }

    router.POST(&amp;quot;/post1&amp;quot;, func(c *gin.Context) {
        var form postForm1
        if c.Bind(&amp;amp;form) == nil{
            c.JSON(200,gin.H{
                &amp;quot;status&amp;quot;:200,
                &amp;quot;id&amp;quot;:form.UserId,
                &amp;quot;page&amp;quot;:form.Page,
            })
        }
        fmt.Printf(&amp;quot;id: %s &amp;quot;, form.UserId)
    }) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client 使用方式如下图
  &lt;img src=&#34;sources/GoGin01/20160631-2.png&#34; alt=&#34;log1&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>iOS 自定义 Log 简介</title>
            <link>http://www.flywithme.top/2016/05/27/Dlog-Introduce/</link>
            <pubDate>Fri, 27 May 2016 10:46:06 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://www.flywithme.top/2016/05/27/Dlog-Introduce/</guid>
            <description>&lt;p&gt;我们在调试程序的时候，往往需要输出一些日志信息，用到NSLog函数，当我们准备发布程序，需要注释掉NSLog代码，这个时候往往会定义一个宏，在调试的时候，会输出日志，在Release正式版本的时候，会关闭日志输出。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef DEBUG
# define DLog(fmt, ...) NSLog((@&amp;quot;[FileName:%s]\n&amp;quot; &amp;quot;[FuctionName:%s]\n&amp;quot; &amp;quot;[Line:%d] \n&amp;quot; fmt), __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);
#else
# define DLog(...);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/dlog/blogDlog.png&#34; alt=&#34;dog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;VA_ARGS&lt;/strong&gt;是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&amp;rdquo;,&amp;ldquo;去掉的作用,否则会编译出错, 你可以试试。&lt;a href=&#34;http://stackoverflow.com/questions/21873616/how-to-use-va-args-properly&#34;&gt;stackOverflow&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;FILE&lt;/strong&gt;宏在预编译时会替换成当前的源文件名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;LINE&lt;/strong&gt;宏在预编译时会替换成当前的行号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;FUNCTION&lt;/strong&gt;宏在预编译时会替换成当前的函数名称&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了以上这几个宏，特别是有了&lt;strong&gt;VA_ARGS&lt;/strong&gt;，调试信息的输出就变得灵活多了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>singnal 信号类型</title>
            <link>http://www.flywithme.top/2016/06/14/singnal/</link>
            <pubDate>Sun, 15 May 2016 17:26:11 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://www.flywithme.top/2016/06/14/singnal/</guid>
            <description>

&lt;h5 id=&#34;简介:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;简介&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;处理一些 crash 需要查到这些资料&lt;/p&gt;

&lt;p&gt;信号是Linux编程中非常重要的部分，本文将详细介绍信号机制的基本概念、Linux对信号机制的大致实现方法、如何使用信号，以及有关信号的几个系统调用。&lt;br /&gt;
信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。从它的命名可以看出，它的实质和使用很象中断。所以，信号可以说是进程控制的一部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;一-信号的基本概念:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;一、信号的基本概念&lt;/h6&gt;

&lt;p&gt;本节先介绍信号的一些基本概念，然后给出一些基本的信号类型和信号对应的事件。基本概念对于理解和使用信号，对于理解信号机制都特别重要。下面就来看看什么是信号。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。&lt;/p&gt;

&lt;p&gt;收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处 理。第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信 号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。&lt;/p&gt;

&lt;p&gt;在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;信号的类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：&lt;/p&gt;

&lt;p&gt;（1） 与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。
   （2） 与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。
   （3） 与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。
   （4） 与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。
   （5） 在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。
   （6） 与终端交互相关的信号。如用户关闭一个终端，或按下break键等情况。
   （7） 跟踪进程执行的信号。&lt;/p&gt;

&lt;p&gt;Linux支持的信号列表如下。很多信号是与机器的体系结构相关的，首先列出的是POSIX.1中列出的信号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
---------------------------------------------------------------------- 
SIGHUP 1 A 终端挂起或者控制进程终止 
SIGINT 2 A 键盘中断（如break键被按下） 
SIGQUIT 3 C 键盘的退出键被按下 
SIGILL 4 C 非法指令 
SIGABRT 6 C 由abort(3)发出的退出指令 
SIGFPE 8 C 浮点异常 
SIGKILL 9 AEF Kill信号 
SIGSEGV 11 C 无效的内存引用 
SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 
SIGALRM 14 A 由alarm(2)发出的信号 
SIGTERM 15 A 终止信号 
SIGUSR1 30,10,16 A 用户自定义信号1 
SIGUSR2 31,12,17 A 用户自定义信号2 
SIGCHLD 20,17,18 B 子进程结束信号 
SIGCONT 19,18,25 进程继续（曾被停止的进程） 
SIGSTOP 17,19,23 DEF 终止进程 
SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键 
SIGTTIN 21,21,26 D 后台进程企图从控制终端读 
SIGTTOU 22,22,27 D 后台进程企图从控制终端写 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的信号没在POSIX.1中列出，而在SUSv2列出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
-------------------------------------------------------------------- 
SIGBUS 10,7,10 C 总线错误(错误的内存访问) 
SIGPOLL A Sys V定义的Pollable事件，与SIGIO同义 
SIGPROF 27,27,29 A Profiling定时器到 
SIGSYS 12,-,12 C 无效的系统调用 (SVID) 
SIGTRAP 5 C 跟踪/断点捕获 
SIGURG 16,23,21 B Socket出现紧急条件(4.2 BSD) 
SIGVTALRM 26,26,28 A 实际时间报警时钟信号(4.2 BSD) 
SIGXCPU 24,24,30 C 超出设定的CPU时间限制(4.2 BSD) 
SIGXFSZ 25,25,31 C 超出设定的文件大小限制(4.2 BSD) 

（对于SIGSYS，SIGXCPU，SIGXFSZ，以及某些机器体系结构下的SIGBUS，Linux缺省的动作是A (terminate)，SUSv2 是C (terminate and dump core)）。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是其它的一些信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;信号 值 处理动作 发出信号的原因 
---------------------------------------------------------------------- 
SIGIOT 6 C IO捕获指令，与SIGABRT同义 
SIGEMT 7,-,7 
SIGSTKFLT -,16,- A 协处理器堆栈错误 
SIGIO 23,29,22 A 某I/O操作现在可以进行了(4.2 BSD) 
SIGCLD -,-,18 A 与SIGCHLD同义 
SIGPWR 29,30,19 A 电源故障(System V) 
SIGINFO 29,-,- A 与SIGPWR同义 
SIGLOST -,-,- A 文件锁丢失 
SIGWINCH 28,28,20 B 窗口大小改变(4.3 BSD, Sun) 
SIGUNUSED -,31,- A 未使用的信号(will be SIGSYS) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（在这里，- 表示信号没有实现；有三个值给出的含义为，第一个值通常在Alpha和Sparc上有效，中间的值对应i386和ppc以及sh，最后一个值对应mips。信号29在Alpha上为SIGINFO / SIGPWR ，在Sparc上为SIGLOST。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;处理动作一项中的字母含义如下 
A 缺省的动作是终止进程 
B 缺省的动作是忽略此信号 
C 缺省的动作是终止进程并进行内核映像转储（dump core） 
D 缺省的动作是停止进程 
E 信号不能被捕获 
F 信号不能被忽略 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面介绍的信号是常见系统所支持的。以表格的形式介绍了各种信号的名称、作用及其在默认情况下的处理动作。各种默认处理动作的含义是：终止程序是指进程退 出；忽略该信号是将该信号丢弃，不做处理；停止程序是指程序挂起，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调 用）；内核映像转储是指将进程数据在内存的映像和进程在内核结构中存储的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提 供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。&lt;/p&gt;

&lt;p&gt;注意 信号SIGKILL和SIGSTOP既不能被捕捉，也不能被忽略。信号SIGIOT与SIGABRT是一个信号。可以看出，同一个信号在不同的系统中值可能不一样，所以建议最好使用为信号定义的名字，而不要直接使用信号的值。&lt;/p&gt;

&lt;h6 id=&#34;二-信-号-机-制:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;二、信 号 机 制&lt;/h6&gt;

&lt;p&gt;上一节中介绍了信号的基本概念，在这一节中，我们将介绍内核如何实现信号机制。即内核如何向一个进程发送信号、进程如何接收一个信号、进程怎样控制自己对信 号的反应、内核在什么时机处理和怎样处理进程收到的信号。还要介绍一下setjmp和longjmp在信号中起到的作用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内核对信号的基本处理方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。这里要补充的是，如果信号发送给一个正在睡眠的进程，那么要看 该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。这一点比较重要，因为进程检 查是否收到信号的时机是：一个进程在即将从内核态返回到用户态时；或者，在一个进程要进入或离开一个适当的低调度优先级睡眠状态时。&lt;/p&gt;

&lt;p&gt;内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。&lt;/p&gt;

&lt;p&gt;内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。前面介绍概念的时候讲过，处理信号有三种类型：进程接收到信号后退 出；进程忽略该信号；进程收到信号后执行用户设定用系统调用signal的函数。当进程接收到一个它忽略的信号时，进程丢弃该信号，就象没有收到该信号似 的继续运行。如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创 建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时， 才返回原先进入内核的地方。这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权 限）。&lt;/p&gt;

&lt;p&gt;在信号的处理方法中有几点特别要引起注意。&lt;br /&gt;
   &lt;strong&gt;第一&lt;/strong&gt; 在一些系统中，当一个进程处理完中断信号返回用户态之前，内核清除用户区中设 定的对该信号的处理例程的地址，即下一次进程对该信号的处理方法又改为默认值，除非在下一次信号到来之前再次使用signal系统调用。这可能会使得进程 在调用signal之前又得到该信号而导致退出。在BSD中，内核不再清除该地址。但不清除该地址可能使得进程因为过多过快的得到某个信号而导致堆栈溢 出。为了避免出现上述情况。在BSD系统中，内核模拟了对硬件中断的处理方法，即在处理某个中断时，阻止接收新的该类中断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二&lt;/strong&gt; 引起注意的是，如果要捕捉的信号发生于进程正在一个系统调用中时，并且该进程睡眠在可中断的优先级上，这时该信号引起进程作一次longjmp，跳出睡眠 状态，返回用户态并执行信号处理例程。当从信号处理例程返回时，进程就象从系统调用返回一样，但返回了一个错误代码，指出该次系统调用曾经被中断。这要注 意的是，BSD系统中内核可以自动地重新开始系统调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三&lt;/strong&gt; 注意的地方：若进程睡眠在可中断的优先级上，则当它收到一个要忽略的信号时，该进程被唤醒，但不做longjmp，一般是继续睡眠。但用户感觉不到进程曾经被唤醒，而是象没有发生过该信号一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四&lt;/strong&gt; 注意的地方：内核对子进程终止（SIGCLD）信号的处理方法与其他信号有所区别。当进程检查出收到了一个子进程终止的信号时，缺省情况下，该进程 就象没有收到该信号似的，如果父进程执行了系统调用wait，进程将从系统调用wait中醒来并返回wait调用，执行一系列wait调用的后续操作（找 出僵死的子进程，释放子进程的进程表项），然后从wait中返回。SIGCLD信号的作用是唤醒一个睡眠在可被中断优先级上的进程。如果该进程捕捉了这个 信号，就象普通信号处理一样转到处理例程。如果进程忽略该信号，那么系统调用wait的动作就有所不同，因为SIGCLD的作用仅仅是唤醒一个睡眠在可被 中断优先级上的进程，那么执行wait调用的父进程被唤醒继续执行wait调用的后续操作，然后等待其他的子进程。&lt;/p&gt;

&lt;p&gt;如果一个进程调用signal系统调用，并设置了SIGCLD的处理方法，并且该进程有子进程处于僵死状态，则内核将向该进程发一个SIGCLD信号。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;setjmp和longjmp的作用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前面在介绍信号处理机制时，多次提到了setjmp和longjmp，但没有仔细说明它们的作用和实现方法。这里就此作一个简单的介绍。&lt;/p&gt;

&lt;p&gt;在介绍信号的时候，我们看到多个地方要求进程在检查收到信号后，从原来的系统调用中直接返回，而不是等到该调用完成。这种进程突然改变其上下文的情况，就是 使用setjmp和longjmp的结果。setjmp将保存的上下文存入用户区，并继续在旧的上下文中执行。这就是说，进程执行一个系统调用，当因为资 源或其他原因要去睡眠时，内核为进程作了一次setjmp，如果在睡眠中被信号唤醒，进程不能再进入睡眠时，内核为进程调用longjmp，该操作是内核 为进程将原先setjmp调用保存在进程用户区的上下文恢复成现在的上下文，这样就使得进程可以恢复等待资源前的状态，而且内核为setjmp返回1，使 得进程知道该次系统调用失败。这就是它们的作用。&lt;/p&gt;

&lt;h6 id=&#34;三-有关信号的系统调用:7fcd034282d2ab5b69e9cbb8faff7ce4&#34;&gt;三、有关信号的系统调用&lt;/h6&gt;

&lt;p&gt;前面两节已经介绍了有关信号的大部分知 识。这一节我们来了解一下这些系统调用。其中，系统调用signal是进程用来设定某个信号的处理方法，系统调用kill是用来发送信号给指定进程的。这 两个调用可以形成信号的基本操作。后两个调用pause和alarm是通过信号实现的进程暂停和定时器，调用alarm是通过信号通知进程定时器到时。所 以在这里，我们还要介绍这两个调用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;signal 系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用signal用来设定某个信号的处理方法。该调用声明的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void (*signal(int signum, void (*handler)(int)))(int); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述声明格式比较复杂，如果不清楚如何使用，也可以通过下面这种类型定义的格式来使用（POSIX的定义）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef void (*sighandler_t)(int); 
sighandler_t signal(int signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这种格式在不同的系统中有不同的类型定义，所以要使用这种格式，最好还是参考一下联机手册。&lt;/p&gt;

&lt;p&gt;在调用中，参数signum指出要设置处理方法的信号。第二个参数handler是一个处理函数，或者是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SIG_IGN：忽略参数signum所指的信号。 
SIG_DFL：恢复参数signum所指信号的处理方法为默认值。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传递给信号处理例程的整数参数是信号值，这样可以使得一个信号处理例程处理多个信号。系统调用signal返回值是指定信号signum前一次的处理例程或者错误时返回错误代码SIG_ERR。下面来看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
void sigroutine(int dunno) { /* 信号处理例程，其中dunno将会得到信号的值 */ 
switch (dunno) { 
case 1: 
printf(&amp;quot;Get a signal -- SIGHUP &amp;quot;); 
break; 
case 2: 
printf(&amp;quot;Get a signal -- SIGINT &amp;quot;); 
break; 
case 3: 
printf(&amp;quot;Get a signal -- SIGQUIT &amp;quot;); 
break; 
} 
return; 
} 

int main() { 
printf(&amp;quot;process id is %d &amp;quot;,getpid()); 
signal(SIGHUP, sigroutine); //* 下面设置三个信号的处理方法 
signal(SIGINT, sigroutine); 
signal(SIGQUIT, sigroutine); 
for (;;) ; 
} 

其中信号SIGINT由按下Ctrl-C发出，信号SIGQUIT由按下Ctrl-发出。该程序执行的结果如下： 

localhost:~$ ./sig_test 
process id is 463 
Get a signal -SIGINT //按下Ctrl-C得到的结果 
Get a signal -SIGQUIT //按下Ctrl-得到的结果 
//按下Ctrl-z将进程置于后台 
[1]+ Stopped ./sig_test 
localhost:~$ bg 
[1]+ ./sig_test &amp;amp; 
localhost:~$ kill -HUP 463 //向进程发送SIGHUP信号 
localhost:~$ Get a signal – SIGHUP 
kill -9 463 //向进程发送SIGKILL信号，终止进程 
localhost:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;kill 系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用kill用来向进程发送一个信号。该调用声明的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int kill(pid_t pid, int sig); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; 
#include &amp;lt;signal.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该系统调用可以用来向任何进程或进程组发送任何信号。如果参数pid是正数，那么该调用将信号sig发送到进程号为pid的进程。如果pid等于0，那么信 号sig将发送给当前进程所属进程组里的所有进程。如果参数pid等于-1，信号sig将发送给除了进程1和自身以外的所有进程。如果参数pid小于- 1，信号sig将发送给属于进程组-pid的所有进程。如果参数sig为0，将不发送信号。该调用执行成功时，返回值为0；错误时，返回-1，并设置相应 的错误代码errno。下面是一些可能返回的错误代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EINVAL：指定的信号sig无效。 
ESRCH：参数pid指定的进程或进程组不存在。注意，在进程表项中存在的进程，可能是一个还没有被wait收回，但已经终止执行的僵死进程。 
EPERM： 进程没有权力将这个信号发送到指定接收信号的进程。因为，一个进程被允许将信号发送到进程pid时，必须拥有root权力，或者是发出调用的进程的UID 或EUID与指定接收的进程的UID或保存用户ID（savedset-user-ID）相同。如果参数pid小于-1，即该信号发送给一个组，则该错误 表示组中有成员进程不能接收该信号。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.pause系统调用&lt;/p&gt;

&lt;p&gt;系统调用pause的作用是等待一个信号。该调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int pause(void); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：
    #include &lt;unistd.h&gt;&lt;/p&gt;

&lt;p&gt;该调用使得发出调用的进程进入睡眠，直到接收到一个信号为止。该调用总是返回-1，并设置错误代码为EINTR（接收到一个信号）。下面是一个简单的范例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;signal.h&amp;gt; 
void sigroutine(int unused) { 
printf(&amp;quot;Catch a signal SIGINT &amp;quot;); 
} 

int main() { 
signal(SIGINT, sigroutine); 
pause(); 
printf(&amp;quot;receive a signal &amp;quot;); 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，程序开始执行，就象进入了死循环一样，这是因为进程正在等待信号，当我们按下Ctrl-C时，信号被捕捉，并且使得pause退出等待状态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;alarm和 setitimer系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统调用alarm的功能是设置一个定时器，当定时器计时到达时，将发出一个信号给进程。该调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned int alarm(unsigned int seconds); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用该调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;系统调用alarm安排内核为调用进程在指定的seconds秒后发出一个SIGALRM的信号。如果指定的参数seconds为0，则不再发送 SIGALRM信号。后一次设定将取消前一次的设定。该调用返回值为上次定时调用到发送之间剩余的时间，或者因为没有前一次定时调用而返回0。&lt;/p&gt;

&lt;p&gt;注意，在使用时，alarm只设定为发送一次信号，如果要多次发送，就要多次使用alarm调用。&lt;/p&gt;

&lt;p&gt;对于alarm，这里不再举例。现在的系统中很多程序不再使用alarm调用，而是使用setitimer调用来设置定时器，用getitimer来得到定时器的状态，这两个调用的声明格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int getitimer(int which, struct itimerval *value); 
int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用这两个调用的进程中加入以下头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/time.h&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该系统调用给进程提供了三个定时器，它们各自有其独有的计时域，当其中任何一个到达，就发送一个相应的信号给进程，并使得计时器重新开始。三个计时器由参数which指定，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TIMER_REAL：按实际时间计时，计时到达将给进程发送SIGALRM信号。 
ITIMER_VIRTUAL：仅当进程执行时才进行计时。计时到达将发送SIGVTALRM信号给进程。 
ITIMER_PROF：当进程执行时和系统为该进程执行动作时都计时。与ITIMER_VIR-TUAL是一对，该定时器经常用来统计进程在用户态和内核态花费的时间。计时到达将发送SIGPROF信号给进程。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定时器中的参数value用来指明定时器的时间，其结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct itimerval { 
struct timeval it_interval; /* 下一次的取值 */ 
struct timeval it_value; /* 本次的设定值 */ 
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该结构中timeval结构定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct timeval { 
long tv_sec; /* 秒 */ 
long tv_usec; /* 微秒，1秒 = 1000000 微秒*/ 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在setitimer 调用中，参数ovalue如果不为空，则其中保留的是上次调用设定的值。定时器将it_value递减到0时，产生一个信号，并将it_value的值设 定为it_interval的值，然后重新开始计时，如此往复。当it_value设定为0时，计时器停止，或者当它计时到期，而it_interval 为0时停止。调用成功时，返回0；错误时，返回-1，并设置相应的错误代码errno：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EFAULT：参数value或ovalue是无效的指针。 
EINVAL：参数which不是ITIMER_REAL、ITIMER_VIRT或ITIMER_PROF中的一个。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是关于setitimer调用的一个简单示范，在该例子中，每隔一秒发出一个SIGALRM，每隔0.5秒发出一个SIGVTALRM信号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt; 
#include &amp;lt;unistd.h&amp;gt; 
#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;sys/time.h&amp;gt; 
int sec; 

void sigroutine(int signo) { 
switch (signo) { 
case SIGALRM: 
printf(&amp;quot;Catch a signal -- SIGALRM &amp;quot;); 
break; 
case SIGVTALRM: 
printf(&amp;quot;Catch a signal -- SIGVTALRM &amp;quot;); 
break; 
} 
return; 
} 

int main() { 
struct itimerval value,ovalue,value2; 
sec = 5; 

printf(&amp;quot;process id is %d &amp;quot;,getpid()); 
signal(SIGALRM, sigroutine); 
signal(SIGVTALRM, sigroutine); 

value.it_value.tv_sec = 1; 
value.it_value.tv_usec = 0; 
value.it_interval.tv_sec = 1; 
value.it_interval.tv_usec = 0; 
setitimer(ITIMER_REAL, &amp;amp;value, &amp;amp;ovalue); 

value2.it_value.tv_sec = 0; 
value2.it_value.tv_usec = 500000; 
value2.it_interval.tv_sec = 0; 
value2.it_interval.tv_usec = 500000; 
setitimer(ITIMER_VIRTUAL, &amp;amp;value2, &amp;amp;ovalue); 

for (;;) ; 
} 

该例子的屏幕拷贝如下： 

localhost:~$ ./timer_test 
process id is 579 
Catch a signal – SIGVTALRM 
Catch a signal – SIGALRM 
Catch a signal – SIGVTALRM 
Catch a signal – SIGVTALRM 
Catch a signal – SIGALRM 
Catch a signal –GVTALRM 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Objective-C&#43;Runtime 浅析</title>
            <link>http://www.flywithme.top/2016/03/24/OCRuntime/</link>
            <pubDate>Thu, 24 Mar 2016 10:58:29 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://www.flywithme.top/2016/03/24/OCRuntime/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;http://wiki.sankuai.com/display/zhso/objective-c+Runtime&#34;&gt;From&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;一-什么是objective-c-runtime:f56a9e9e73a618e80c7099e7e8ebe510&#34;&gt;一、什么是Objective-C Runtime?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Objective-C是动态语言, 而Runtime可以说是Objective-C的灵魂。简单来说，Objective-C Runtime是一个实现Objective-C语言的C库。对象可以用C语言中的结构体表示，而方法（methods）可以用C函数实现。事实上，他们差不多也是这么干了，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，Objective-C程序员可以在程序运行时创建，检查，修改类，对象和它们的方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先可以考虑一个问题：如果让我们设计、实现一门计算机语言，要如何下手？可能我们平时很少这么思考过，但是这么一问，就会强迫我们从更高层次思考问题了。编译优化先忽略，语言的优雅性也可以暂时放一边，我们可以从实现来看下面三个层次：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;传统的面向过程的语言开发，例如c语言。实现c语言编译器只要按照语法规则实现一个LALR语法分析器就可以了，忽略编译器的优化问题，我们可以先实现编译器中最最基础和原始的目标：把一份代码里的函数名称，转化成一个相对内存地址，把调用这个函数的语句转换成一个jmp跳转指令。在程序开始运行时候，调用语句可以正确跳转到对应的函数地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fly(char *name)
    {
            printf(&amp;quot;%s fly&amp;quot;, name);
    }
    void run(char *name)
    {
            printf(&amp;quot;%s run&amp;quot;, name);
    }


    fly(&amp;quot;Pig&amp;quot;);
    run(&amp;quot;Pig&amp;quot;);
    fly(&amp;quot;Dog&amp;quot;);
    run(&amp;quot;Dog&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们希望灵活，于是需要开发面向对象的语言，例如c++。 c++在c的基础上增加了类的部分。但这到底意味着什么呢？我们在写它的编译器要如何考虑呢？其实，就是让编译器多绕个弯，在严格的c编译器上增加一层类处理的机制，把一个函数限制在它处在的class环境里，每次请求一个函数调用，先找到它的对象, 其类型,返回值，参数等等，确定了这些后再jmp跳转到需要的函数。这样很多程序增加了灵活性同样一个函数调用会根据请求参数和类的环境返回完全不同的结果。增加类机制后，就模拟了现实世界的抽象模式，不同的对象有不同的属性和方法。同样的方法，不同的类有不同的行为!&lt;br /&gt;
下面就可以开始尝试开发一种新的面向对象语言，先暂定这种语言叫DP-C吧！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class Animal 
    {
            char *name;
            Animal(char *name)
           {
                 this.name = name;
           }
          void fly()
          {
               printf(&amp;quot;%s fly&amp;quot;, this.name);
          }
          void run()
          {
               printf(&amp;quot;%s run&amp;quot;, this.name);
          }
    }
    Animal *pig = new Animal(&amp;quot;pig&amp;quot;);
    Animal *dog = new Animal(&amp;quot;dog&amp;quot;);
    pig.fly();
    pig.run();
    dog.fly();
    dog.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码看上去应该挺熟悉，接下来将DP-C语言编成C代码。什么，还没写编译器？好吧，虽然现在强大的AlphaGO战胜伟大的韩国围棋小甜菜李世石，但是我还是相信我们人类的大脑永远是机器无法取代的，那么我们前端技术组临时成立个部门，就叫DP-C语言编译部，由部门的小伙伴用他们强大的大脑和灵活的小手指将DP-C翻译成C语言，然后剩下的编译工作就交给C语言编译器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct dp_class_animal *Animal;
    void fly(Animal this)
    {
            printf(&amp;quot;%s fly&amp;quot;, this-&amp;gt;name);
    }
    void run(Animal this)
    {
            printf(&amp;quot;%s run&amp;quot;, this-&amp;gt;name);
    }


    struct dp_class_animal
    {
            char *name;
            void (*fly)(Animal this);
            void (*run)(Animal this);
    }


    Animal pig = {
            .name = &amp;quot;pig&amp;quot;;
            .fly = &amp;amp;fly;
            .run = &amp;amp;run;
    }
    Animal dog = {
           .name = &amp;quot;dog&amp;quot;;
            .fly = &amp;amp;fly;
            .run = &amp;amp;run;
    }
    pig-&amp;gt;fly(pig);
    pig-&amp;gt;run(pig);
    dog-&amp;gt;fly(dog);
    dog-&amp;gt;run(dog);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;希望更加灵活！ 于是完全把上面Animal类的实现部分抽象出来，做成一套完整运行阶段的检测环境。这次再写编译器甚至保留部分代码里的sytax名称，名称错误检测，runtime环境注册所有全局的类，函数，变量等等信息等等，我们可以无限的为这个层增加必要的功能。调用函数时候，会先从这个运行时环境里检测所以可能的参数再做jmp跳转，这就是runtime。编译器开发起来比上面更加弯弯绕。但是这个层极大增加了程序的灵活性。 例如当调用一个函数时候，上面的编译方法很有可能一个jmp到了一个非法地址导致程序crash, 但是在这个层次里面，runtime就过滤掉了这些可能性。 这就是为什么dynamic langauge更加强壮。 因为编译器和runtime环境开发人员已经帮你处理了这些问题，而Objecitve-C是C的超集加上一个小巧的runtime环境。我们可以继续完善我们的DP-C，为她增加一个小小的Runtime，可能暂时没有头绪，但是他山之石可以攻玉，我们现在请出我们的主角Objective-C，看看她的Runtime是如何实现的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;二-runtime相关的主要类型:f56a9e9e73a618e80c7099e7e8ebe510&#34;&gt;二、Runtime相关的主要类型&lt;/h4&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SEL&lt;/strong&gt;：Objective-C在编译的时候，会根据方法的名字（包括参数序列），生成一个用 来区分这个方法的唯一的一个ID，这个ID就是SEL类型的。我们需要注意的是，只要方法的名字（包括参数序列）相同，那么它们的ID都是相同的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IMP&lt;/strong&gt;：函数指针，指向函数（方法）的具体实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Class&lt;/strong&gt;：objc_class*&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_class *Class;

struct objc_class {

    Class isa; // 指向metaClass

    Class super_class; // 指向该类的父类, 如果该类已经是最顶层的根类(如 NSObject 或 NSProxy),那么 super_class 就为 NULL.

    const char *name; // 类名

    long version; // 类的版本信息,默认为0,可以通过runtime函数class_setVersion和class_getVersion进行修改、读取  

    long info; // 供运行期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;

    long instance_size; // 该类的实例变量大小

    struct objc_ivar_list *ivars; // 成员变量的数组

    struct objc_method_list **methodLists; // 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;

    struct objc_cache *cache; // 指向最近使用的方法.用于方法调用的优化

    struct objc_protocol_list *protocols; // 存储遵守的协议的数组
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;objc_ivar_list&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct objc_ivar_list {
        int ivar_count;   // 变量数
        int space ;  // 64位时可用，在objc-runtime-old中没有发现其使用，作用未知，估计是寻址用
        struct objc_ivar ivar_list[1]; // 变量列表，暂时声明长度为1，在添加变量时会动态分配内存，增加列表长度
    }   
    Ivar：objc_ivar*
    struct objc_ivar {
        char *ivar_name ; // 变量名
        char *ivar_type ; // 变量类型
        int ivar_offset ; // 变量在对象内存中的偏移量，用于获取对象中成员变量的首地址
        int space; // 64位时可用，作用未知，估计是寻址用
    }  


    objc_method_list
    struct objc_method_list {
        struct objc_method_list *obsolete; // 过时的方法列表
        int method_count; // 方法数
        int space; // 64位时可用，作用未知，估计是寻址用
        struct objc_method method_list[1]; // 方法列表，暂时声明长度为1，在添加方法时会动态分配内存，增加列表长度
    }  
    Method：objc_method *
    struct objc_method {
        SEL method_name; // 方法名，SEL类型，用于快速查找方法
        char *method_types; // 方法参数类型字符串，包括返参和入参
        IMP method_imp; /// 方法具体实现，指向方法在内存的首地址
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;method_types释义&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1&#34;&gt;（点击传送到苹果官方文档）&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{name=type&amp;hellip;}&lt;/td&gt;
&lt;td&gt;A structure&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Code&lt;/td&gt;
&lt;td&gt;Meaning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;MA char&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;MAn int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;MA short&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;MA long &lt;br/&gt;l is treated as a 32-bit quantity on 64-bit programs.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;MA long long&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;MAn unsigned char&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;MAn unsigned int&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;MAn unsigned short&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;MAn unsigned long&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;MAn unsigned long long&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;MA float&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;MA double&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;MA C++ bool or a C99 _Bool&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;MA void&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;A character string (char *)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;An object (whether statically typed or typed id)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;A class object (Class)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;:&lt;/td&gt;
&lt;td&gt;A method selector (SEL)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[array type]&lt;/td&gt;
&lt;td&gt;An array&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name=type&amp;hellip;}&lt;/td&gt;
&lt;td&gt;A structure&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(name=type&amp;hellip;)&lt;/td&gt;
&lt;td&gt;A union&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bnum&lt;/td&gt;
&lt;td&gt;A bit field of num bits&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^type&lt;/td&gt;
&lt;td&gt;A pointer to type&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;An unknown type (among other things, this code is used for function pointers)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;objc_protocol_list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct objc_protocol_list {
    struct objc_protocol_list *next; // 下一个objc_protocol_list，链表的实现，比如当新增一个Category时，会将Category的objc_protocol_list加到当前链表之前，见objc-runtime-old.mm第3008-3010行
    long count; // 协议数
    Protocol *list[1]; // 协议列表，初始声明长度为1，在添加协议时会动态分配内存，增加列表长度
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Protocol： objc_object*&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct objc_object{
     Class isa;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Category: objc_category&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct objc_category {
    char *category_name;
    char *class_name;
    struct objc_method_list *instance_methods ;
    struct objc_method_list *class_methods;
    struct objc_protocol_list *protocols ;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;三-关系及消息机制:f56a9e9e73a618e80c7099e7e8ebe510&#34;&gt;三、关系及消息机制&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt; 中类和对象&lt;br /&gt;
下面一幅图比较经典，描述了Objective-C中类和对象的关系&lt;br /&gt;
&lt;img src=&#34;sources/runtime/superclassRelation.png&#34; alt=&#34;superClass&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息机制&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单的方法调用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以方法&lt;strong&gt;makeText&lt;/strong&gt;为例，&lt;strong&gt;@selector (makeText)&lt;/strong&gt;是一个SEL方法选择器。上文在描述SEL提到过，SEL其主要作用是快速的通过方法名字（makeText）查找到对应方法的函数指针，然后调用其函 数。SEL其本身是一个Int类型的一个地址，地址中存放着方法的名字。对于一个类中。每一个方法对应着一个SEL。所以iOS类中不能存在2个名称相同 的方法，即使参数类型不同，因为SEL是根据方法名字生成的，相同的方法名称只能对应一个SEL。&lt;/p&gt;

&lt;p&gt;首先，编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中。首先通过obj的isa指针找到obj对应的class。在Class中先去cache中 通过SEL查找对应函数method（猜测cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若 cache中未找到。再去methodList中查找，若methodlist中未找到，则去superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/runtime/methodListGet.jpg&#34; alt=&#34;methodList&#34; /&gt;&lt;/p&gt;

&lt;p&gt;objc_msgSend的定义：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;id objc_msgSend ( id self, SEL op, ... ); 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;self&lt;/strong&gt;和&lt;strong&gt;super&lt;/strong&gt;&lt;br /&gt;
先看一段代码，看看Som在init时控制台输出什么&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Son : Father
@end
@implementation Son 
- (id)init 
{ 
        self = [super init]; 
        if (self) 
        { 
                NSLog(@&amp;quot;%@&amp;quot;, NSStringFromClass([self class])); 
                NSLog(@&amp;quot;%@&amp;quot;, NSStringFromClass([super class])); 
        } 
        return self; 
} 
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;self表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。在本例中，无论是[self class]还是[super class]，接受消息者都是Son对象，但super与self不同的是，self调用class方法时，是在子类Son中查找方法，而super调用class方法时，是在父类Father中查找方法。&lt;/p&gt;

&lt;p&gt;当调用[self class]方法时，会转化为objc_msgSend函数。这时会从当前Son类的方法列表中查找，如果没有，就到Father类查找，还是没有，最后在NSObject类查找到。我们可以从NSObject.mm文件中看到- (Class)class的实现：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;- (Class)class { 
        return object_getClass(self); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;所以NSLog(@&amp;ldquo;%@&amp;rdquo;, NSStringFromClass([self class]));会输出Son。
  当调用[super class]方法时，会转化为objc_msgSendSuper，这个函数定义如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;id objc_msgSendSuper(struct objc_super *super, SEL op, ...)  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;objc_msgSendSuper函数第一个参数super的数据类型是一个指向objc_super的结构体，从message.h文件中查看它的定义：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;/// Specifies the superclass of an instance. 
struct objc_super { 
        /// Specifies an instance of a class. 
        __unsafe_unretained id receiver; 


        /// Specifies the particular superclass of the instance to message. 
        #if !defined(__cplusplus) &amp;amp;&amp;amp; !__OBJC2__ 
        /* For compatibility with old objc-runtime.h header */ 
        __unsafe_unretained Class class; 
        #else 
        __unsafe_unretained Class super_class; 
        #endif 
        /* super_class is the first class to search */ 
}; 
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;结构体包含两个成员，第一个是receiver，表示某个类的实例。第二个是super_class表示当前类的父类。这时首先会构造出objc_super结构体，这个结构体第一个成员是self，第二个成员是(id)class_getSuperclass(objc_getClass(&amp;ldquo;Son&amp;rdquo;))，实际上该函数会输出Father。然后在Father类查找class方法，查找不到，最后在NSObject查到。此时，内部使用objc_msgSend(objc_super-&amp;gt;receiver, @selector(class))去调用，与[self class]调用相同，所以结果还是Son。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;隐藏参数_cmd&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self我们知道是什么，_cmd表示当前调用方法，其实它就是一个方法选择器SEL。一般用于判断方法名或在Associated Objects中唯一标识键名。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法解析与消息转发&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[obj doSomething]调用方法时，如果在doSomething方法在obj对象的类继承体系中没有找到方法时，一般情况下，程序在运行时就会Crash掉，抛出unrecognized selector sent to…类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;阶段一、&lt;strong&gt;Method Resolution&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当找不到方法时，首先Objective-C在运行时调用+ resolveInstanceMethod:或+ resolveClassMethod:方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程，如果返回NO，怎进入阶段二：消息转发。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;阶段二、&lt;strong&gt;Fast Forwarding&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果目标对象实现- forwardingTargetForSelector:方法，系统就会在运行时调用这个方法，只要这个方法返回的不是nil或self，也会重启消息发送的过程，把这消息转发给其他对象来处理，之所以叫Fast，是因为这一阶段不会创建NSInvocation对象，但Normal Forwarding会创建它，所以相对于更快点。如果返回nil或self，就会继续Normal Fowarding。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;阶段三、&lt;strong&gt;Normal Forwarding&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Normal Forwarding阶段首先调用methodSignatureForSelector:方法来获取函数的参数和返回值，如果返回为nil，程序会Crash掉，并抛出unrecognized selector sent to instance异常信息。如果返回一个函数签名，系统就会创建一个NSInvocation对象并调用-forwardInvocation:方法。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;三种消息转发机制总结：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Method Resolution&lt;/strong&gt;：由于Method Resolution不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fast Forwarding&lt;/strong&gt;：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Normal Forwarding&lt;/strong&gt;：它跟Fast Forwarding一样可以消息转发，但它能通过NSInvocation对象获取更多消息发送的信息，例如：target、selector、arguments和返回值等信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;四-associated-objects:f56a9e9e73a618e80c7099e7e8ebe510&#34;&gt;四、Associated Objects&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;当使用Category对某个类进行扩展时，有时需要存储属性，Category是不支持的，这时需要使用Associated Objects来给已存在的类Category添加自定义的属性。Associated Objects提供三个API来向对象添加、获取和删除关联值：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )
    id objc_getAssociatedObject (id object, const void *key )
    void objc_removeAssociatedObjects (id object )
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;其中objc_AssociationPolicy是个枚举类型，它可以指定Objc内存管理的引用计数机制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { 
            OBJC_ASSOCIATION_ASSIGN = 0, /**&amp;lt; Specifies a weak reference to the associated object. */ 
            OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&amp;lt; Specifies a strong reference to the associated object. 
            /* The association is not made atomically. */ 
            OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&amp;lt; Specifies that the associated object is copied. 
            /* The association is not made atomically. */ 
            OBJC_ASSOCIATION_RETAIN = 01401, /**&amp;lt; Specifies a strong reference to the associated object. 
           / * The association is made atomically. */ 
            OBJC_ASSOCIATION_COPY = 01403 /**&amp;lt; Specifies that the associated object is copied. 
            /* The association is made atomically. */ 
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Associated Objects的key要求是唯一并且是常量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;五-method-swizzling:f56a9e9e73a618e80c7099e7e8ebe510&#34;&gt;五、 &lt;strong&gt;Method Swizzling&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Method Swizzling就是在运行时将一个方法的实现代替为另一个方法的实现。如果能够利用好这个技巧，可以写出简洁、有效且维护性更好的代码，比如实现AOP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;     void method_exchangeImplementations(Method m1, Method m2) 

     void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)
     {
         Method originalMethod = class_getInstanceMethod(class, originalSelector);
         Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

         BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));

         if (didAddMethod) {
             class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
         }
         else {
             method_exchangeImplementations(originalMethod, swizzledMethod);
         }
     }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
