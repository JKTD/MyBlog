<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术文章 on Fly With Me</title>
        <link>http://blog.flywithme.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>无线真机调试-Xcode9 -iOS</title>
            <link>http://blog.flywithme.top/2017/11/16/wirelessdebug/</link>
            <pubDate>Thu, 16 Nov 2017 11:15:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/16/wirelessdebug/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;首先你需要 Mac系统电脑 安装Xcode9 iPhone设备需要iOS11的系统&lt;/li&gt;
&lt;li&gt;其次你的手机必须和电脑处于同一个无线局域网中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首次安装连接需要先连接数据线至同一个局域网的Mac上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开-&amp;gt;windows里的Device and Simulators选项，勾选 Connect Via network&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设你的开发证书和描述文件都是齐全完整的，开始编译，会自动提示。真机调试选择刚才连接到 机器名字&lt;/p&gt;

&lt;p&gt;数据线链接手机 打开device and simulators面板，勾选connect via network&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/wireless/002.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;选择你的设备开始编译 （就算断开数据线，这个设备依然会留在这里）
  &lt;img src=&#34;sources/wireless/005.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/wireless/003.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;开始编译结束-可以查看手机的device日志，然后手机名字右边的网球 表示无线连接正常
  &lt;img src=&#34;sources/wireless/004.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Shell 小记，imageMagick 和 PlistBuddy合体生成图标</title>
            <link>http://blog.flywithme.top/2017/11/15/PlistBuddy/</link>
            <pubDate>Wed, 15 Nov 2017 19:06:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/15/PlistBuddy/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://github.com/flywithbug/Shell_Demo&#34;&gt;demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图片内容处理文件 (merchant-icon-generator.sh)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#获取参数 文件源
SRC_FILE=&amp;quot;$1&amp;quot; 
#版本号
shortVersion=&amp;quot;$2&amp;quot;
#标签number
bundlerNum=&amp;quot;$3&amp;quot;

#转换      文件         绘制    坐标           填充       颜色          透明度             填充      坐标          填充      颜色           透明度            生成目标图片
convert &amp;quot;$SRC_FILE&amp;quot; -region 1024x244+0+780 -fill &amp;quot;rgb(0,159,250)&amp;quot; -colorize 100%   -region 1024x244+650+780 -fill &amp;quot;rgb(102,230,32)&amp;quot; -colorize 100%  target-new.png  

#转换       文件         重置坐标  地图坐标西南角  写入 白色字体，文字尺寸     绘制文字   offset    内容                    
convert target-new.png -gravity southwest -fill white -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$shortVersion&#39;&amp;quot;  -gravity southeast -fill white -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$bundlerNum&#39;&amp;quot; target-new.png
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令&lt;br /&gt;
&lt;img src=&#34;sources/shell/01.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原图&lt;br /&gt;
&lt;img src=&#34;sources/shell/1024-origin.png&#34; width = &#34;20%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目标图&lt;br /&gt;
&lt;img src=&#34;sources/shell/target-new.png&#34; width = &#34;20%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plist处理文件（merchant_plist_generator.sh）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
appInfoPlistPath=&amp;quot;Jovi/Jovi/Info-AdHoc.plist&amp;quot;
bundleShortVersion=$(/usr/libexec/PlistBuddy -c &amp;quot;print CFBundleShortVersionString&amp;quot; ${appInfoPlistPath})
bundleVersion=$(/usr/libexec/PlistBuddy -c &amp;quot;print CFBundleVersion&amp;quot; ${appInfoPlistPath})

# url=&amp;quot;$1&amp;quot;
# if [ &amp;quot;$1&amp;quot;  = &amp;quot;&amp;quot; ]
# then 
#   url=&amp;quot;http://app.dp:8080/view/Merchant/job/dpmerchant_adhocMCI/lastBuild/buildNumber&amp;quot;
# fi
result=&amp;quot;23232&amp;quot;
while [ &amp;quot;$result&amp;quot; == &amp;quot;&amp;quot; ]
do 
    result=$(curl -s &amp;quot;$url&amp;quot;)
done

newBundleVersion=&amp;quot;&amp;quot;$bundleShortVersion&amp;quot;.&amp;quot;$result&amp;quot;&amp;quot;
/usr/libexec/PlistBuddy -c &amp;quot;Set CFBundleVersion ${newBundleVersion}&amp;quot;  ${appInfoPlistPath}

sh merchant-icon-generator.sh &amp;quot;1024-origin.png&amp;quot; &amp;quot;$bundleShortVersion&amp;quot; &amp;quot;$result&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/shell/02.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/shell/03.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>golang web Send Email</title>
            <link>http://blog.flywithme.top/2017/11/13/mail/</link>
            <pubDate>Mon, 13 Nov 2017 17:20:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/13/mail/</guid>
            <description>&lt;p&gt;//注意邮件格式，以免被当垃圾邮件&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>ubuntu ssh免密登陆</title>
            <link>http://blog.flywithme.top/2017/11/13/sshnopass/</link>
            <pubDate>Mon, 13 Nov 2017 11:40:09 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/13/sshnopass/</guid>
            <description>

&lt;h3 id=&#34;前置条件&#34;&gt;前置条件：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一台主流的Linux服务器，如CentOS,Ubuntu,Fedora,redhat等&lt;/li&gt;
&lt;li&gt;一台能连上以上服务器的客户机，我用的mac，系统是osx&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;预备动作&#34;&gt;预备动作：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开终端 Terminal&lt;/li&gt;
&lt;li&gt;生成ca证书私钥与公钥
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;执行&#34;&gt;执行：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;执行代码    ssh-copy-id -i (id_rsa路径) name@ip -p
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;sources/ubuntu/001.png&#34; alt=&#34;001.png&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提示错误 需要登录服务器修改文件权限
&lt;img src=&#34;sources/ubuntu/002.png&#34; alt=&#34;002.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再次执行图1 内容
&lt;img src=&#34;sources/ubuntu/003.png&#34; alt=&#34;003.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这样的结果即可免密登陆
&lt;img src=&#34;sources/ubuntu/004.png&#34; alt=&#34;004.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>web01-配置Mysql</title>
            <link>http://blog.flywithme.top/2017/11/11/gin-mysql-Web/</link>
            <pubDate>Sat, 11 Nov 2017 19:57:02 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/11/gin-mysql-Web/</guid>
            <description>&lt;p&gt;安装Mysql 创建userInfo表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `userinfo` (
  `uid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(16) DEFAULT &#39;&#39;,
  `departname` varchar(20) DEFAULT &#39;&#39;,
  `password` varchar(32) DEFAULT &#39;&#39;,
  `sex` tinyint(1) unsigned zerofill DEFAULT &#39;0&#39;,
  `userid` varchar(32) DEFAULT &#39;&#39;,
  `phone` varchar(13) DEFAULT &#39;&#39;,
  `phoneprefix` varchar(6) DEFAULT &#39;&#39;,
  `createtime` int(10) unsigned NOT NULL,
  `updatetime` int(10) unsigned NOT NULL,
  `state` tinyint(1) DEFAULT &#39;-1&#39;,
  `authtoken` char(32) DEFAULT &#39;&#39;,
  `mail` varchar(40) DEFAULT &#39;&#39;,
  `oldpassword` varchar(100) DEFAULT &#39;&#39;,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=1000039 DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;db 控制器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//所有的db操作全部使用同一个db实例
var db *sql.DB
var err error

func DBConf()*sql.DB  {
    if db == nil {
        InitMysql()
    }
    return db
}

func InitMysql()  {
    db, err = sql.Open(config.TomlConf().Mysql().DBtype, config.TomlConf().Mysql().Url)
    db.SetMaxIdleConns(200)
    db.SetMaxOpenConns(100)
    checkErr(err)
}


func checkErr(err error) {
    if err != nil {
        panic(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;userModel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UserInfoModel struct {
    Uid         int64       `json:&amp;quot;uid,omitempty&amp;quot; form:&amp;quot;uid,omitempty&amp;quot;`
    UserName    string      `json:&amp;quot;username,omitempty&amp;quot; form:&amp;quot;username,omitempty&amp;quot;`
    Password    string      `json:&amp;quot;password,omitempty&amp;quot; form:&amp;quot;password,omitempty&amp;quot;`
    CreateTime  int64       `json:&amp;quot;createtime,omitempty&amp;quot; form:&amp;quot;createtime,omitempty&amp;quot;`
    UpdateTime  int64       `json:&amp;quot;updatetime,omitempty&amp;quot; form:&amp;quot;updatetime,omitempty&amp;quot;`
    Sex         int         `json:&amp;quot;sex,omitempty&amp;quot; form:&amp;quot;sex,omitempty&amp;quot;`     //0默认未设置 1男，2女
    UserId      string      `json:&amp;quot;userid,omitempty&amp;quot; form:&amp;quot;userid,omitempty&amp;quot;`
    DepartName  string      `json:&amp;quot;departname,omitempty&amp;quot; form:&amp;quot;departname,omitempty&amp;quot;`
    Phone       string      `json:&amp;quot;phone,omitempty&amp;quot; form:&amp;quot;phone,omitempty&amp;quot;`
    PhonePrefix     string      `json:&amp;quot;phoneprefix,omitempty&amp;quot; form:&amp;quot;phoneprefix,omitempty&amp;quot;`
    Mail        string      `json:&amp;quot;mail,omitempty&amp;quot; form:&amp;quot;mail,omitempty&amp;quot;`
    OldPassword     string      `json:&amp;quot;oldpassword,omitempty&amp;quot; form:&amp;quot;oldpassword,omitempty&amp;quot;`
    Authtoken   string      `json:&amp;quot;authtoken,omitempty&amp;quot; form:&amp;quot;authtoken,omitempty&amp;quot;`
    State       int         `json:&amp;quot;state,omitempty&amp;quot; form:&amp;quot;state,omitempty&amp;quot;`
}

//初始化一个uer
func NewUser() UserInfoModel {
    return UserInfoModel{}
}

func (user *UserInfoModel)ToString()(desc string)  {
    desc = &amp;quot;name:&amp;quot;+user.UserName
    return desc
}

//插入到数据库
func (user *UserInfoModel)InsertUser()(error){
    if CheckUserNameValid(user.UserName) == false{
        err := errors.New(&amp;quot;username already exists&amp;quot;)
        return err
    }

    if CheckPhoneValid(user.Phone) == false{
        err := errors.New(&amp;quot;phone number already exists&amp;quot;)
        return err
    }

    db := db.DBConf()
    stmt, err := db.Prepare(&amp;quot;INSERT userinfo SET username=?,departname=?,createtime=?,updatetime=?,password=?,sex=?,mail=?,phone=?,phoneprefix=?&amp;quot;)
    checkErr(err)
    _, err = stmt.Exec(user.UserName, user.DepartName,user.CreateTime,user.UpdateTime,user.Password,user.Sex,user.Mail,user.Phone,user.PhonePrefix)
    checkErr(err)
    return err
}

//更新用户信息到数据库
func (user *UserInfoModel)UpdateIntoDB()(error)  {
    if user.Uid == 0 {
        log.Error(&amp;quot;update faild，Pri key Uid not found&amp;quot;)
        return errors.New(&amp;quot;update faild，Pri key Uid not found&amp;quot;)
    }
    db := db.DBConf()
    stmt, err := db.Prepare(&amp;quot;UPDATE userinfo set username=?,departname=?,createtime=?,password=?,sex=? where uid=?&amp;quot;)
    checkErr(err)
    _, err = stmt.Exec(user.UserName, user.DepartName,user.CreateTime,user.Password,user.Sex, user.Uid)
    checkErr(err)
    return err
}

//判断次用户名有没有被注册
func CheckUserNameValid(name string)(bool)  {
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT  username FROM userinfo WHERE username=?&amp;quot;, name).Scan(&amp;amp;name)
    if err != nil {
        return true
    }
    log.Warn(&amp;quot;username already exist&amp;quot;,name)
    return false
}

//判断手机号是否被注册
func CheckPhoneValid(phone string)(bool)  {
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT  username FROM userinfo WHERE phone=?&amp;quot;, phone).Scan(&amp;amp;phone)
    if err != nil {
        return true
    }
    log.Warn(&amp;quot;phone number already exists&amp;quot;,phone)
    return false
}
//判断email是否被注册
func CheckEmailValid(mail string)(bool)  {
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT  username FROM userinfo WHERE mail=?&amp;quot;, mail).Scan(&amp;amp;mail)
    if err != nil {
        return true
    }
    log.Warn(&amp;quot;mail already exists&amp;quot;,mail)
    return false
}

//判断userid是否已存在
func CheckUserIdValid(userId string)(bool)  {
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT  username FROM userinfo WHERE userid=?&amp;quot;, userId).Scan(&amp;amp;userId)
    if err != nil {
        return true
    }
    log.Warn(&amp;quot;CheckUserIdValid：userid already exists&amp;quot;,userId)
    return false
}
//通过uid查找用户
func FindUserFromDB(uid int64)(UserInfoModel,error)  {
    var user UserInfoModel
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT uid, username, departname, password, sex, userid, phone, phoneprefix, createtime, updatetime, state, authtoken, mail, oldpassword FROM userinfo WHERE uid=?&amp;quot;, uid).
        Scan(&amp;amp;user.Uid,
         &amp;amp;user.UserName, &amp;amp;user.DepartName, &amp;amp;user.Password, &amp;amp;user.Sex, &amp;amp;user.UserId, &amp;amp;user.Phone, &amp;amp;user.PhonePrefix,
        &amp;amp;user.CreateTime, &amp;amp;user.UpdateTime,&amp;amp;user.State,&amp;amp;user.Authtoken,&amp;amp;user.Mail,&amp;amp;user.OldPassword)
    checkErr(err)
    return user,err
}

//通过用户名查找用户
func FindUserFromDBByName(name string)(UserInfoModel,error)  {
    var user UserInfoModel
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT uid, username, departname, password, sex, userid, phone, phoneprefix, createtime, updatetime, state, authtoken, mail, oldpassword FROM userinfo WHERE username=?&amp;quot;, name).
        Scan(&amp;amp;user.Uid,
        &amp;amp;user.UserName, &amp;amp;user.DepartName, &amp;amp;user.Password, &amp;amp;user.Sex, &amp;amp;user.UserId, &amp;amp;user.Phone, &amp;amp;user.PhonePrefix,
        &amp;amp;user.CreateTime, &amp;amp;user.UpdateTime,&amp;amp;user.State,&amp;amp;user.Authtoken,&amp;amp;user.Mail,&amp;amp;user.OldPassword)
    user.Password = &amp;quot;&amp;quot;
    user.OldPassword = &amp;quot;&amp;quot;
    checkErr(err)
    return user,err
}

//通过用户名和密码查找用户
func CheckUserNameAndPass(name string,pass string)(UserInfoModel,error)  {
    var user UserInfoModel
    db := db.DBConf()
    err := db.QueryRow(&amp;quot;SELECT uid, username, departname, password, sex, userid, phone, phoneprefix, createtime, updatetime, state, authtoken, mail, oldpassword FROM userinfo WHERE username=?&amp;quot;, name).
        Scan(&amp;amp;user.Uid,
        &amp;amp;user.UserName, &amp;amp;user.DepartName, &amp;amp;user.Password, &amp;amp;user.Sex, &amp;amp;user.UserId, &amp;amp;user.Phone, &amp;amp;user.PhonePrefix,
        &amp;amp;user.CreateTime, &amp;amp;user.UpdateTime,&amp;amp;user.State,&amp;amp;user.Authtoken,&amp;amp;user.Mail,&amp;amp;user.OldPassword)

    if user.Password != pass {
        err = errors.New(&amp;quot;password not right&amp;quot;)
        user = NewUser()
    }
    user.Password = &amp;quot;&amp;quot;
    user.OldPassword = &amp;quot;&amp;quot;
    checkErr(err)
    return user,err
}

//通过uid删除用户
func DeleteUserFromDB(uid int64)(error)  {
    db := db.DBConf()
    stmt, err := db.Prepare(&amp;quot;delete from userinfo where uid=?&amp;quot;)
    if err != nil{
        return err
    }
    fmt.Println(uid)
    _,err = stmt.Exec(uid)
    return err
}

//错误日志
func checkErr(err error) {
    if err != nil {
        log.Warn(err.Error())
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>imagemagic</title>
            <link>http://blog.flywithme.top/2017/11/10/imagemagic/</link>
            <pubDate>Fri, 10 Nov 2017 12:11:33 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/10/imagemagic/</guid>
            <description>&lt;p&gt;首先：brew install ImageMagick&lt;/p&gt;

&lt;p&gt;熟悉ImageMagick命令：&lt;/p&gt;

&lt;p&gt;resize当前目录下的图片到100x100f分辨率&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;convert 1024x1024.png -resize 100x100 icon02.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;填充某像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;convert 1024x1024.png -region 1024x224+0+800 -fill &amp;quot;rgb(255,166,48)&amp;quot; -colorize 100% new.png  

convert 1024-origin.png -region 1024x224+0+800 -fill &amp;quot;rgb(0,159,250)&amp;quot; -colorize 100%   -region 1024x224+650+800 -fill &amp;quot;rgb(233,159,250)&amp;quot; -colorize 100%  new.png  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;py&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用gin框架实现一个基于Mysql数据库的用户系统-填坑部分</title>
            <link>http://blog.flywithme.top/2017/11/05/gin-mysql/</link>
            <pubDate>Sun, 05 Nov 2017 20:17:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/05/gin-mysql/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;项目地址：&lt;a href=&#34;https://github.com/flywithbug/darkside&#34;&gt;https://github.com/flywithbug/darkside&lt;/a&gt; 欢迎fork。 TODO 更新更多内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;填坑1- struct to json 时，空值忽略，或者特定值忽略问题&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ethancai.github.io/2016/06/23/bad-parts-about-json-serialization-in-Golang/&#34;&gt;http://ethancai.github.io/2016/06/23/bad-parts-about-json-serialization-in-Golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Golang中，如果指定一个field序列化成JSON的变量名字为-，则序列化的时候自动忽略这个field。这种用法，
才是和上面JsonIgnore的用法的作用是一样的。&lt;/p&gt;

&lt;p&gt;而omitempty的作用是当一个field的值是empty的时候，序列化JSON时候忽略这个field。&lt;br /&gt;
这里需要注意的是关于emtpty的定义：&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>iOS11 ScrollView 页面下移问题</title>
            <link>http://blog.flywithme.top/2017-09-30-iOS11ScrollView20pt</link>
            <pubDate>Sat, 30 Sep 2017 14:58:00 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017-09-30-iOS11ScrollView20pt</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#一-ios-11下app中tableview内容下移20pt或下移64pt的原因分析&#34;&gt;一、iOS 11下APP中tableView内容下移20pt或下移64pt的原因分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#二-adjustcontentinset属性的计算方式&#34;&gt;二、 adjustContentInset属性的计算方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#三-什么情况下的tableview会发生上述问题&#34;&gt;三、什么情况下的tableView会发生上述问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#四-这个问题的解决方法有哪些&#34;&gt;四、这个问题的解决方法有哪些？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#五-遇到的另外一个与安全区域无关的tableview内容下移的问题&#34;&gt;五、遇到的另外一个与安全区域无关的tableView内容下移的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;&lt;strong&gt;scorllView contentOffset变动问题&lt;/strong&gt;&lt;/p&gt;

&lt;h6 id=&#34;一-ios-11下app中tableview内容下移20pt或下移64pt的原因分析&#34;&gt;一、iOS 11下APP中tableView内容下移20pt或下移64pt的原因分析&lt;/h6&gt;

&lt;p&gt;问题如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/scrollview/92.png&#34; alt=&#34;sss&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 原因分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因是iOS 11中&lt;code&gt;UIViweController&lt;/code&gt;的&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性被废弃了，所以当&lt;code&gt;scrollView&lt;/code&gt;超出安全区域时系统自动调整了&lt;code&gt;SafeAreaInsets&lt;/code&gt;值，进而影响&lt;code&gt;adjustedContentInset&lt;/code&gt;值，&lt;br /&gt;
在iOS 11中决定tableView的内容与边缘距离的是&lt;code&gt;adjustedContentInset&lt;/code&gt;属性，而不是&lt;code&gt;contentInset&lt;/code&gt;。&lt;code&gt;adjustedContentInset&lt;/code&gt;的计算方式见本文第二部分内容。因为系统对&lt;code&gt;adjustedContentInset&lt;/code&gt;值进行了调整，所以导致&lt;code&gt;tableView&lt;/code&gt;的内容到边缘的距离发生了变化，导致&lt;code&gt;tableView&lt;/code&gt;下移了20pt（statusbar高度）或64pt（navigationbar高度）。&lt;/p&gt;

&lt;p&gt;如果你的APP中使用的是自定义的navigationbar，隐藏掉系统的navigationbar，并且tableView的frame为(0,0,SCREEN_WIDTH, SCREEN_HEIGHT)开始，那么系统会自动调整SafeAreaInsets值为(20,0,0,0)，如果使用了系统的navigationbar，那么SafeAreaInsets值为(64,0,0,0)，如果也使用了系统的tabbar，那么SafeAreaInsets值为(64,0,49,0)。关于什么情况下会发生内容下移的问题，本文第三部分有介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 安全区域的概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统自动调整tableView内容偏移量，是根据安全区域来调整的。安全区域是iOS 11新提出的，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/scrollview/32.png&#34; alt=&#34;sssa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;安全区域帮助我们将view放置在整个屏幕的可视的部分。即使把navigationbar设置为透明的，系统也认为安全区域是从navigationbar的bottom开始的。
安全区域定义了view中可视区域的部分，保证不被系统的状态栏、或父视图提供的view如导航栏覆盖。可以使用&lt;code&gt;additionalSafeAreaInsets&lt;/code&gt;去扩展安全区域去包括自定义的content在你的界面。每个view都可以改变安全区域嵌入的大小，Controller也可以。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;safeAreaInsets&lt;/code&gt;属性反映了一个view距离该view的安全区域的边距。对于一个Controller的根视图而言，&lt;code&gt;SafeAreaInsets&lt;/code&gt;值包括了被&lt;code&gt;statusbar&lt;/code&gt;和其他可视的bars覆盖的区域和其他通过&lt;code&gt;additionalSafeAreaInsets&lt;/code&gt;自定义的insets值。对于view层次中得其他view，SafeAreaInsets值反映了view被覆盖的部分。如果一个view全部在它父视图的安全区域内，则SafeAreaInsets值为(0,0,0,0)。&lt;/p&gt;

&lt;h6 id=&#34;二-adjustcontentinset属性的计算方式&#34;&gt;二、 adjustContentInset属性的计算方式&lt;/h6&gt;

&lt;p&gt;首先看scrollView在iOS11新增的两个属性：adjustContentInset 和 contentInsetAdjustmentBehavior。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Configure the behavior of adjustedContentInset.
Default is UIScrollViewContentInsetAdjustmentAutomatic.
*/
@property(nonatomic) UIScrollViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior
adjustContentInset表示contentView.frame.origin偏移了scrollview.frame.origin多少；是系统计算得来的，计算方式由contentInsetAdjustmentBehavior决定。有以下几种计算方式：

UIScrollViewContentInsetAdjustmentAutomatic：如果scrollview在一个automaticallyAdjustsScrollViewInsets = YES的controller上，并且这个Controller包含在一个navigation controller中，这种情况下会设置在top &amp;amp; bottom上 adjustedContentInset = safeAreaInset + contentInset不管是否滚动。其他情况下与UIScrollViewContentInsetAdjustmentScrollableAxes相同

UIScrollViewContentInsetAdjustmentScrollableAxes: 在可滚动方向上adjustedContentInset = safeAreaInset + contentInset，在不可滚动方向上adjustedContentInset = contentInset；依赖于scrollEnabled和alwaysBounceHorizontal / vertical = YES，scrollEnabled默认为yes，所以大多数情况下，计算方式还是adjustedContentInset = safeAreaInset + contentInset

UIScrollViewContentInsetAdjustmentNever: adjustedContentInset = contentInset

UIScrollViewContentInsetAdjustmentAlways: adjustedContentInset = safeAreaInset + contentInset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;contentInsetAdjustmentBehavior&lt;/code&gt;设置为&lt;code&gt;UIScrollViewContentInsetAdjustmentNever&lt;/code&gt;的时候，&lt;code&gt;adjustContentInset&lt;/code&gt;值不受&lt;code&gt;SafeAreaInset&lt;/code&gt;值的影响。&lt;/p&gt;

&lt;h6 id=&#34;三-什么情况下的tableview会发生上述问题&#34;&gt;三、什么情况下的tableView会发生上述问题&lt;/h6&gt;

&lt;p&gt;如果设置了automaticallyAdjustsScrollViewInsets = YES，那么不会发生问题，一直都是由系统来调整内容的偏移量。&lt;/p&gt;

&lt;p&gt;接下来排查下自己的项目中哪些页面会发生以上问题。&lt;/p&gt;

&lt;p&gt;当tableView的frame超出安全区域范围时，系统会自动调整内容的位置，SafeAreaInsets值会不为0，于是影响tableView的adjustContentInset值，于是影响tableView的内容展示，导致tableView的content下移了SafeAreaInsets的距离。SafeAreaInsets值为0时，是正常的情况。&lt;/p&gt;

&lt;p&gt;需要了解每个页面的结构，看tableView是否被系统的statusbar或navigationbar覆盖，如果被覆盖的话，则会发生下移。也可以通过tableview.safeAreaInsets的值来确认是因为安全区域的问题导致的内容下移。&lt;/p&gt;

&lt;p&gt;如下代码片段，可以看出系统对tableView向下调整了20pt的距离，因为tableView超出了安全区域范围，被statusbar覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tableview.contentInset: {64, 0, 60, 0}
tableview.safeAreaInsets: {20, 0, 0, 0}
tableview.adjustedContentInset: {84, 0, 60, 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;四-这个问题的解决方法有哪些&#34;&gt;四、这个问题的解决方法有哪些？&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;重新设置tableView的contentInset值，来抵消掉SafeAreaInset值，因为内容下移偏移量 = contentInset + SafeAreaInset；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果之前自己设置了contentInset值为(64,0,0,0),现在系统又设置了SafeAreaInsets值为(64,0,0,0)，那么tableView内容下移了64pt，这种情况下，可以设置contentInset值为(0,0,0,0)，也就是遵从系统的设置了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置tableView的contentInsetAdjustmentBehavior属性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果不需要系统为你设置边缘距离，可以做以下设置：&lt;/p&gt;

&lt;p&gt;//如果iOS的系统是11.0，会有这样一个宏定义“#define __IPHONE_11_0  110000”；如果系统版本低于11.0则没有这个宏定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef __IPHONE_11_0   
if ([tableView respondsToSelector:@selector(setContentInsetAdjustmentBehavior:)]) {
    tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;contentInsetAdjustmentBehavior&lt;/code&gt;属性也是用来取代&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性的，推荐使用这种方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过设置iOS 11新增的属性addtionalSafeAreaInset；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;iOS 11之前，大家是通过将Controller的&lt;code&gt;automaticallyAdjustsScrollViewInsets&lt;/code&gt;属性设置为NO，来禁止系统对tableView调整contentInsets的。如果还是想从Controller级别解决问题，
那么可以通过设置Controller的additionalSafeAreaInsets属性，如果SafeAreaInset值为(20,0,0,0)，那么设置additionalSafeAreaInsets属性值为(-20,0,0,0)，则SafeAreaInsets不会对adjustedContentInset值产生影响，
tableView内容不会显示异常。这里需要注意的是addtionalSafeAreaInset是Controller的属性，要知道SafeAreaInset的值是由哪个Controller引起的，可能是由自己的Controller调整的，可能是navigationController调整的。是由哪个Controller调整的，则设置哪个Controller的addtionalSafeAreaInset值来抵消掉SafeAreaInset值。&lt;/p&gt;

&lt;h6 id=&#34;五-遇到的另外一个与安全区域无关的tableview内容下移的问题&#34;&gt;五、遇到的另外一个与安全区域无关的tableView内容下移的问题&lt;/h6&gt;

&lt;p&gt;我的作品页面的tableView下移了约40pt，这里是否跟安全区域有关呢？&lt;/p&gt;

&lt;p&gt;查了下页面结构，tableView的父视图的frame在navigationbar的bottom之下，tableView在父视图的安全区域内，打印出来tableView的SafeAreaInset值也是(0，0，0，0);所以不是安全区域导致的内容下移。&lt;/p&gt;

&lt;p&gt;经过查看代码，发现tableView的style:UITableViewStyleGrouped类型，默认tableView开头和结尾是有间距的，不需要这个间距的话，可以通过实现heightForHeaderInSection方法（返回一个较小值：0.1）和viewForHeaderInSection（返回一个view）来去除头部的留白，底部同理。&lt;/p&gt;

&lt;p&gt;iOS 11上发生tableView顶部有留白，原因是代码中只实现了heightForHeaderInSection方法，而没有实现viewForHeaderInSection方法。那样写是不规范的，只实现高度，而没有实现view，但代码这样写在iOS 11之前是没有问题的，iOS 11之后应该是由于开启了估算行高机制引起了bug。添加上viewForHeaderInSection方法后，问题就解决了。或者添加以下代码关闭估算行高，问题也得到解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.tableView.estimatedRowHeight = 0;
self.tableView.estimatedSectionHeaderHeight = 0;
self.tableView.estimatedSectionFooterHeight = 0;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>大文件分片上传解决方案</title>
            <link>http://blog.flywithme.top/2017/08/03/bigFileUpload/</link>
            <pubDate>Thu, 03 Aug 2017 13:44:56 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/08/03/bigFileUpload/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分片模型：索引，上传状态，偏移量，大小，文件名，类型，分片数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;md5: 获取文件的md5值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件管理工具：文件路径， 分析文件内容，生成数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;上传任务池中会保持小于等于3个的请求任务
 启动上传任务之后会往任务池中添加上传任务，若分片数大于3个，则会把任务池填满。
 等其中任意一个任务上传结束之后会回调通知任务池，添加一个新的请求任务进入任务池中
 等上传任务全部结束，发送合并片的请求(这个其实是业务方自己做的)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/bigFileUpload/bigfile001.png&#34; alt=&#34;bigfile001&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文件的md5值读取，在文件很大的时候不要使用把数据转换成二进制流的形式获取。因为这样可能会造成内存溢出。使用分片读取md5的形式&lt;br /&gt;
   模型组里可以保存每一个分片的md5值，用于分片的上传状态。&lt;br /&gt;
   管理中心可以保存分片文件的上传状态，上传失败之后可以尝试重新上传，同一个分片数据只上传一次。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>swift3-22</title>
            <link>http://blog.flywithme.top/2017/04/17/swift22/</link>
            <pubDate>Mon, 17 Apr 2017 10:48:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/17/swift22/</guid>
            <description></description>
        </item>
        
        <item>
            <title>swift3-21 析构过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift21/</link>
            <pubDate>Thu, 13 Apr 2017 17:19:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift21/</guid>
            <description>&lt;p&gt;在一个类的实例被释放之前，析构函数就被立即调用，用关键字 deinit 来表示析构函数， 类似与初始化使用 init 来标示。析构函数只适用于类类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;析构过程原理&lt;/strong&gt; Swift会自动释放不在需要的实例以释放资源。通过ARC处理实例的内存管理。通常实例被释放是不需要手动清理的。但是当使用到一些资源的
 时候可能就需要额外的清理了。比如打开另一个文件写入数据，就需要在实例被释放前关闭该文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：在类的定义中，每个类最多只有一个析构函数，析构函数不带任何参数，不带括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deinit{
   //执行析构过程
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;code&gt;deinit&lt;/code&gt;的调用时机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var counter = 0;  
class BaseClass {
    init() {
        counter += 1;
    }
    deinit {
        counter -= 1;
    }
}

var show: BaseClass? = BaseClass()
print(counter) // 1
show = nil  
print(counter) // 0
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-20 构造过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift20/</link>
            <pubDate>Thu, 13 Apr 2017 16:24:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift20/</guid>
            <description>&lt;p&gt;构造过程是为了使用某个类、结构体或者枚举类型实例而进行的准备过程。这个过程包含了为实例的每一个属性设置初始值 的初始化任务&lt;br /&gt;
 swift的构造函数使用的是init()方法。 这个方法没有返回值。主要任务是保证新实例在第一次使用之前完成正确的初始化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造器&lt;/strong&gt; 在创建某特定类型的新实例时调用，它的关键字是init&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init(){
    //执行属性初值设置
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两段式构造&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值  第一段
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善  第二段
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认属性值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age:Int
    init(){
        age = 18
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造参数&lt;/strong&gt;  定义构造器 init() 时提供构造参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选属性类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认构造器&lt;/strong&gt; 所有属性都设置有默认值的实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age = 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;required 构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;必须被子类实现的构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    //子类必须实现
    required init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    private final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //子类实现父类的required
    required convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
son.name
son.age
son.level
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数的继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
   //构造函数的继承
    override convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)    
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-19 多态性</title>
            <link>http://blog.flywithme.top/2017/04/13/swift19/</link>
            <pubDate>Thu, 13 Apr 2017 12:00:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift19/</guid>
            <description>&lt;p&gt;&lt;strong&gt;多态性&lt;/strong&gt; 同样的操作或者方法，不同的对象执行的时候表现出完全不同的行为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用父类指针或者引用指向子类的实例，然后再自雷中覆盖父类的方法，利用父类引用调用相同方法而产生不同的行为。&lt;/li&gt;
&lt;li&gt;多态的条件：a,必须存在继承关系，b,子类对父类的方法进行重写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}

class sonClass2:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    override func testFunc() {
        print(&amp;quot;sonClass2&amp;quot;)
    }
}


final class grandSon1:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}
final class grandSon01:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

final class grandSon02:sonClass2{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

func printBasicInfo(base:baseClass){
    print(&amp;quot;name is \(base.name)&amp;quot;)
}

var grandson1 = grandSon01.init(name: &amp;quot;a&amp;quot;, age: 10)
var grandson2 = grandSon02.init(name: &amp;quot;b&amp;quot;, age: 7)
printBasicInfo(base: grandson1)
printBasicInfo(base: grandson2)
grandson1.testFunc()
grandson2.testFunc()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-18 继承</title>
            <link>http://blog.flywithme.top/2017/04/01/swift18/</link>
            <pubDate>Sat, 01 Apr 2017 22:29:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/01/swift18/</guid>
            <description>&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：我们可以理解为一个类获取了另外一个类的方法和属性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类)，
我们也可以为类中继承来的属性添加属性观察器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基类&lt;/strong&gt; 没有继承其它类的类，称之为基类（Base Class）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类&lt;/strong&gt; 子类指的是在一个已有类的基础上创建一个新的类。为了指明某个类的超类，将超类名写在子类名的后面，用冒号(:)分隔,语法格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
}
sonClass.init(name: &amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重写（Overriding）&lt;/strong&gt; 子类可以通过继承来的实例方法，类方法，实例属性，或下标脚本来实现自己的定制功能，我们把这种行为叫重写（overriding）。我们可以使用 override 关键字来实现重&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
    var levelStr:String
    override init(name: String) {
        self.levelStr = name.appending(&amp;quot;b&amp;quot;)
        super.init(name: name)
    }
}

var son =  sonClass.init(name: &amp;quot;a&amp;quot;)
son.baseName
son.levelStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// &lt;strong&gt;防止重写&lt;/strong&gt;   使用 final 关键字防止它们被重写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //final 关键字
 final class grandSon:sonClass{
     final var grand:String = &amp;quot;&amp;quot;
     override init(name: String) {
         super.init(name: name)
     }
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-17 单例</title>
            <link>http://blog.flywithme.top/2017/03/31/swift17/</link>
            <pubDate>Fri, 31 Mar 2017 19:47:41 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/31/swift17/</guid>
            <description>&lt;p&gt;&lt;strong&gt;单例写法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Manager{
    public var score = 0
    public static let defaultManager = Manager.init()

    private init(){

    }
    public func addScore(){
        score += 10
    }
}




let manager = Manager.defaultManager

manager.addScore()
manager.score

manager.addScore()
manager.score
let manager2 = Manager.defaultManager
manager2.addScore()
manager2.score
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
