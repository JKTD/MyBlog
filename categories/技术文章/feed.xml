<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术文章 on Fly With Me</title>
        <link>http://blog.flywithme.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>Go: 4-1 面向对象</title>
            <link>http://blog.flywithme.top/2018/02/08/note_08/</link>
            <pubDate>Thu, 08 Feb 2018 11:34:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/08/note_08/</guid>
            <description>

&lt;h4 id=&#34;go语言的面向对象&#34;&gt;&lt;strong&gt;Go语言的面向对象&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Go语言仅支持封装，不支持继承和多态&lt;/li&gt;
&lt;li&gt;Go语言没有class，只有struct&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;结构的创建&#34;&gt;结构的创建&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用自定义工厂函数，需要返回局部变量的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; type treeNode struct {
 	value int
 	left,right *treeNode
 }
 
 func CreatNode(value int)*treeNode  {
 	return &amp;amp;treeNode{value:value}
 }
 
 root := treeNode{value:3}
 root.right = CreatNode(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;结构创建位置是在编译阶段由编译器决定，最后由go的GC垃圾回收器回收&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从正确性的角度，用户不用关心内存在哪里分配的就是了。一般来说，如果有地方用到了那个地址，那么变量就会在堆上分配了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量ret的内存会在堆上分配的，Go的编译器会决定在哪(堆or栈)分配内存，保证程序的正确性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;type struct T { xxx}
func f() *T {
    var ret T
    return &amp;amp;ret
}
	
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Go的编译器很聪明(自作聪明)，它还会做逃逸分析(escape analysis)，如果它发现变量的作用域没有跑出太远，它就可以在栈上分配空间而不是堆&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const Width, Height = 640, 480
type Cursor struct {
    X, Y int
}

func Center(c *Cursor) {
    c.X += Width / 2
    c.Y += Height / 2
}

func CenterCursor() {
    c := new(Cursor)
    Center(c)
    fmt.Println(c.X, c.Y)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用指针作为方法的接受者才可以改变结构内容&lt;/li&gt;
&lt;li&gt;nil指针也可以调用方法，但是在使用时一样需要判断是否nill，以免panic&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;值接收者-vs-指针接收者&#34;&gt;值接收者 VS 指针接收者&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;要改变内容必须使用指针接收者&lt;/li&gt;
&lt;li&gt;结构过大也考虑使用指针接收者（）&lt;/li&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;值接收者是go语言特有&lt;/li&gt;
&lt;li&gt;值/指针接收者均可接收值/指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;封装&#34;&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;名字一般使用CamelCase(驼峰命名)&lt;/li&gt;
&lt;li&gt;首字母大写：Public&lt;/li&gt;
&lt;li&gt;首字母小写：private&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Public和private是针对包来说的，包外可以访问Public方法，&lt;/p&gt;

&lt;h6 id=&#34;包&#34;&gt;包&lt;/h6&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个目录一个包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;main包 包含可执行入口只能有一个main方法入口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为结构定义的方法必须放在同一个包内&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以是不同的文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;扩充系统类型或者第三方库类型&#34;&gt;扩充系统类型或者第三方库类型&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;定义别名&lt;/li&gt;
&lt;li&gt;使用组合&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 3-2 Map 和字符串的一些操作</title>
            <link>http://blog.flywithme.top/2018/02/07/note_07/</link>
            <pubDate>Wed, 07 Feb 2018 17:52:33 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/07/note_07/</guid>
            <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#map&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rune-相当于go的char&#34;&gt;rune 相当于go的char&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strings&#34;&gt;strings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;h6 id=&#34;map&#34;&gt;Map&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;Map 是一种无序的键值对的集合。最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。&lt;/li&gt;
&lt;li&gt;Map 是一种集合，可以像迭代数组和切片那样迭代它。Map 是无序的，我们无法决定它的返回顺序，因为 Map 是使用 hash 表来实现的。
```
	m := map[string]string{
		&amp;ldquo;name&amp;rdquo;:    &amp;ldquo;jack&amp;rdquo;,
		&amp;ldquo;course&amp;rdquo;:  &amp;ldquo;golang&amp;rdquo;,
		&amp;ldquo;site&amp;rdquo;:    &amp;ldquo;imooc&amp;rdquo;,
		&amp;ldquo;quality&amp;rdquo;: &amp;ldquo;notbad&amp;rdquo;,
	}
	&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;	m2 := make(map[string]int) // m2 == empty map
    var m3 map[string]int // m3 == nil
	fmt.Println(&amp;ldquo;m, m2, m3:&amp;ldquo;)
    fmt.Println(m, m2, m3)
	fmt.Println(&amp;ldquo;Traversing map m&amp;rdquo;)
	for k, v := range m {
		fmt.Println(k, v)
	}&lt;/p&gt;

&lt;p&gt;	fmt.Println(&amp;ldquo;Getting values&amp;rdquo;)
	courseName := m[&amp;ldquo;course&amp;rdquo;]
	fmt.Println(&lt;code&gt;m[&amp;quot;course&amp;quot;] =&lt;/code&gt;, courseName)
	if causeName, ok := m[&amp;ldquo;cause&amp;rdquo;]; ok {
		fmt.Println(causeName)
	} else {
		fmt.Println(&amp;ldquo;key &amp;lsquo;cause&amp;rsquo; does not exist&amp;rdquo;)
	}&lt;/p&gt;

&lt;p&gt;	fmt.Println(&amp;ldquo;Deleting values&amp;rdquo;)
	name, ok := m[&amp;ldquo;name&amp;rdquo;]
	fmt.Printf(&amp;ldquo;m[%q] before delete: %q, %v\n&amp;rdquo;,
		&amp;ldquo;name&amp;rdquo;, name, ok)&lt;/p&gt;

&lt;p&gt;	delete(m, &amp;ldquo;name&amp;rdquo;)
	name, ok = m[&amp;ldquo;name&amp;rdquo;]
	fmt.Printf(&amp;ldquo;m[%q] after delete: %q, %v\n&amp;rdquo;,
		&amp;ldquo;name&amp;rdquo;, name, ok)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
##### map的key
 - map使用hash表，必须可以比较相等
 - 除了slice，map和fuction的內建类型都可以做key
 - Struct类型不包含上述字段，也可以做key
 - 会在编译时检查
 
 
###### 寻找最长不含有重复字符的子串 (abcabcbb -&amp;gt; abc) rune
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//视频提供的方法 比较繁琐，逻辑复杂，此方法更简洁
func lengthOfNonRepeatingSubStr(s string)int  {
	lastOccured := make(map[rune]rune)
	for _ , ch := range []rune(s) {
		lastOccured[ch] = ch
	}
	return len(lastOccured)
}
```&lt;/p&gt;

&lt;h5 id=&#34;rune-相当于go的char&#34;&gt;rune 相当于go的char&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;使用range遍历pos,rune&lt;/li&gt;
&lt;li&gt;使用utf8.RuneCountInString获得字符数量&lt;/li&gt;
&lt;li&gt;len()获取的是字节长度&lt;/li&gt;
&lt;li&gt;使用[]byte获得字节内容&lt;/li&gt;
&lt;li&gt;[]rune&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;strings&#34;&gt;strings&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;string到int&lt;br /&gt;
&lt;code&gt;int, err := strconv.Atoi(string)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;string到int64&lt;br /&gt;
&lt;code&gt;int64, err := string.ParseInt(string, 10, 64)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int到string&lt;br /&gt;
&lt;code&gt;string := strconv.Itoa(int)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int64到string&lt;br /&gt;
&lt;code&gt;string := strconv.FormatInt(int64, 10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hasprefix判断字符串s是否以prefix开头&lt;br /&gt;
&lt;code&gt;strings.HasPrefix(s, prefix string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HasSuffix判断字符串s是否以suffix结尾&lt;br /&gt;
&lt;code&gt;strings.HasSuffix(s, suffix string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Contains判断字符串s是否包含substr&lt;br /&gt;
&lt;code&gt;strings.Contains(s, substr string) bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Index返回字符串str在字符串s中的索引(str的第一个字符的索引)，-1表示字符串s不包含字符串str&lt;br /&gt;
&lt;code&gt;strings.Index(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LastIndex返回字符串str在字符串s中最后出现的位置&lt;br /&gt;
&lt;code&gt;strings.LastIndex(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非ASCII编码的字符定位&lt;br /&gt;
&lt;code&gt;strings.IndexRune(s string, ch int)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace用于将str中前n个字符串old替换为字符串new，如果为-1则替换所有字符串old为new&lt;br /&gt;
&lt;code&gt;strings.Replace(str, old, new, n) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Count用于计算str在s中出现的非重叠次数&lt;br /&gt;
&lt;code&gt;strings.Count(s, str string) int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Repeat用于重复count次字符串s并返回一个新的字符串&lt;br /&gt;
&lt;code&gt;strings.Repeat(s, count int) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ToLower将字符串中Unicode字符全部转换为小写字符&lt;br /&gt;
&lt;code&gt;strings.ToLower(s) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ToUpper将字符串中Unicode字符全部转换为大写字符&lt;br /&gt;
&lt;code&gt;strings.ToUpper(s) string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TrimSpace剔除字符串开头和结尾的空白符号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Trim剔除开头和结尾的字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;TrimLeft,TrimRight剔除开头或结尾字符串&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Fields利用一个或多个空白符号来作为动态长度的分隔符将字符串分割，返回slice&lt;br /&gt;
&lt;code&gt;strings.Fields(s) slice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Split用自定义分割符号来对指定字符串进行分割&lt;br /&gt;
&lt;code&gt;strings.Split(s, sep) slice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Join用于将元素类型为string的slice使用分割符号来拼接组成一个字符串&lt;br /&gt;
&lt;code&gt;strings.Join(sl []string, sep string)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 3-1 数组、切片和容器</title>
            <link>http://blog.flywithme.top/2018/02/05/note_06/</link>
            <pubDate>Mon, 05 Feb 2018 16:44:58 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/05/note_06/</guid>
            <description>

&lt;h5 id=&#34;数组-值类型&#34;&gt;数组 (值类型)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;[10]int 和 [5]int 是不同的类型&lt;/li&gt;
&lt;li&gt;调用func f(arr [5]int)会&lt;strong&gt;拷贝&lt;/strong&gt;数组&lt;/li&gt;
&lt;li&gt;调用func f1(arr *[5]int)可以在方法里修改arr&lt;/li&gt;
&lt;li&gt;Go中一般不直接使用数组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;   //数组初始化
    var arr1 [5]int
   	arr2 :=[3]int{2,4,6}
   	arr3 :=[...]int{2,4,5,6,78,0}
   
   	fmt.Println(arr1,arr2,arr3)
   
   	var grid[4][2][1]int
   	fmt.Println(grid)
   
   	//元素遍历
   	for i :=0;i &amp;lt; len(arr3) ;i ++  {
   		fmt.Println(arr3[i])
   	}
   	
   	
//指针传递   	
func printArray(arr *[5]int) {
	arr[0] = 100
	for i, v := range arr {
		fmt.Println(i, v)
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;range-关键字-还会有很多其他地方用到&#34;&gt;&lt;code&gt;range&lt;/code&gt; 关键字 (还会有很多其他地方用到)&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;   	for i,v := range arr3  {
   		fmt.Println(i,v)
   	}
   	for _,v := range arr3  {
   		fmt.Println(v)
   	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;切片-slice&#34;&gt;切片 Slice&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}

	fmt.Println(&amp;quot;arr[2:6] =&amp;quot;, arr[2:6])
	fmt.Println(&amp;quot;arr[:6] =&amp;quot;, arr[:6])
	s1 := arr[2:]
	fmt.Println(&amp;quot;s1 =&amp;quot;, s1)
	s2 := arr[:]
	fmt.Println(&amp;quot;s2 =&amp;quot;, s2)

	fmt.Println(&amp;quot;After updateSlice(s1)&amp;quot;)
	updateSlice(s1)
	fmt.Println(s1)
	fmt.Println(arr)

	fmt.Println(&amp;quot;After updateSlice(s2)&amp;quot;)
	updateSlice(s2)
	fmt.Println(s2)
	fmt.Println(arr)

	fmt.Println(&amp;quot;Reslice&amp;quot;)
	fmt.Println(s2)
	s2 = s2[:5]
	fmt.Println(s2)
	s2 = s2[2:]
	fmt.Println(s2)

	fmt.Println(&amp;quot;Extending slice&amp;quot;)
	arr[0], arr[2] = 0, 2
	fmt.Println(&amp;quot;arr =&amp;quot;, arr)
	s1 = arr[2:6]
	fmt.Println(arr[0:1])
	s2 = s1[3:6] // [s1[3], s1[4]]
	fmt.Printf(&amp;quot;s1=%v, len(s1)=%d, cap(s1)=%d\n&amp;quot;,
		s1, len(s1), cap(s1))
		
		
	fmt.Printf(&amp;quot;s2=%v, len(s2)=%d, cap(s2)=%d\n&amp;quot;,
		s2, len(s2), cap(s2))

	s3 := append(s2, 10)
	s4 := append(s3, 11)
	s5 := append(s4, 12)
	fmt.Println(&amp;quot;s3, s4, s5 =&amp;quot;, s3, s4, s5)
	// s4 and s5 no longer view arr.
	fmt.Println(&amp;quot;arr =&amp;quot;, arr)

	// Uncomment to run sliceOps demo.
	// If we see undefined: sliceOps
	// please try go run slices.go sliceops.go
	fmt.Println(&amp;quot;Uncomment to see sliceOps demo&amp;quot;)
	// sliceOps()

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;slice的向后扩展&#34;&gt;Slice的向后扩展&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    s1 = arr[2:6]
	s2 = s1[3:5]

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;s1的值为[2,3,4,5],s2的值为[5,6]&lt;/li&gt;
&lt;li&gt;slice可以向后扩展，不可以向前扩展&lt;/li&gt;
&lt;li&gt;s[i] 不可以超越len(s),向后扩展不可以超越底层数组cap(s)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517845264648.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;向slice添加元素&#34;&gt;向slice添加元素&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;添加元素时如果超越cap长度，系统会重新分配更大的底层数组&lt;/li&gt;
&lt;li&gt;由于值传递的关系，必须接受append的返回值&lt;/li&gt;
&lt;li&gt;s = append(s,val)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-4 指针</title>
            <link>http://blog.flywithme.top/2018/02/05/note_05/</link>
            <pubDate>Mon, 05 Feb 2018 15:29:31 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/05/note_05/</guid>
            <description>

&lt;h5 id=&#34;什么是指针&#34;&gt;什么是指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类似于变量和常量，在使用指针前你需要声明指针
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;如何使用指针&#34;&gt;如何使用指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;定义指针变量。&lt;/li&gt;
&lt;li&gt;为指针变量赋值。&lt;/li&gt;
&lt;li&gt;访问指针变量中指向地址的值。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    var a int = 2
	var pa *int = &amp;amp;a
	*pa = 3
	fmt.Println(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;空指针&#34;&gt;空指针&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;当一个指针被定义后没有分配到任何变量时，它的值为 nil。&lt;/li&gt;
&lt;li&gt;nil 指针也称为空指针。&lt;/li&gt;
&lt;li&gt;nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。&lt;/li&gt;
&lt;li&gt;一个指针变量通常缩写为 ptr&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    var  ptr *int
    fmt.Printf(&amp;quot;ptr 的值为 : %x\n&amp;quot;, ptr  )
    
    if(ptr != nil)     /* ptr 不是空指针 */
    if(ptr == nil)    /* ptr 是空指针 */
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;参数传递的几种形式&#34;&gt;参数传递的几种形式&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818417658.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818442412.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517818481871.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main()  {
	var a int = 2
	var pa *int = &amp;amp;a
	*pa = 3
	fmt.Println(a)

	var  ptr *int
	fmt.Printf(&amp;quot;ptr 的值为 : %x\n&amp;quot;, ptr  )
	a,b := 3,4
	swap(&amp;amp;a,&amp;amp;b)
	fmt.Println(a,b)
	a,b = swap1(a,b)
	fmt.Println(a,b)


}

func swap(a,b *int)  {
	*b,*a = *a,*b
}

func swap1(a,b int)(int,int)  {
	return b,a
}

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-3 函数</title>
            <link>http://blog.flywithme.top/2018/02/04/note_04/</link>
            <pubDate>Sun, 04 Feb 2018 14:37:54 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/04/note_04/</guid>
            <description>

&lt;h5 id=&#34;函数&#34;&gt;函数&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;函数是基本的代码块，用于执行一个任务。&lt;/li&gt;
&lt;li&gt;Go 语言最少有个 main() 函数。&lt;/li&gt;
&lt;li&gt;你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。&lt;/li&gt;
&lt;li&gt;函数声明告诉了编译器函数的名称，返回类型，和参数。&lt;/li&gt;
&lt;li&gt;Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Go 语言函数定义格式如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func function_name( [parameter list] ) [return_types] {
   函数体
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    package main
    
    import (
    	&amp;quot;fmt&amp;quot;
    	&amp;quot;reflect&amp;quot;
    	&amp;quot;runtime&amp;quot;
    	&amp;quot;math&amp;quot;
    )
    
    func eval(a,b int,op string)  (int,error){
    	switch op {
    	case &amp;quot;+&amp;quot;:
    		return a + b,nil
    	case &amp;quot;-&amp;quot;:
    		return a - b,nil
    	case &amp;quot;*&amp;quot;:
    		return a * b,nil
    	case &amp;quot;/&amp;quot;:
    		q,_ := div(a,b)
    		return q,nil
    	default:
    		return 0,fmt.Errorf(&amp;quot;unsupported operation:&amp;quot; +op)
    	}
    }
    
    func apply(op func(int,int)int,a,b int)int  {
    	p := reflect.ValueOf(op).Pointer()
    	opName := runtime.FuncForPC(p).Name()
    	fmt.Printf(&amp;quot;calling function %s with args (%d %d)&amp;quot;,opName,a,b)
    	return op(a,b)
    }
    
    //除法
    
    func div(a,b int)(int ,int)  {
    	return a/b,a%b
    }
    
    func pow(a,b int)int  {
    	return int(math.Pow(float64(a),float64(b)))
    }
    
    func sum(numbers ...int)int  {
    	s := 0
    	//for i := range numbers{
    	//	s +=numbers[i]
    	//}
    	for _,value := range numbers{
    		s += value
    	}
    	return s
    }
    
    func main()  {
    	fmt.Println(eval(3,4,&amp;quot;/-&amp;quot;))
    	q,r := div(13,5)
    	fmt.Println(q,r)
    
    	fmt.Println(apply(pow,3,4))
    	fmt.Println(
    		apply(func(a ,b int)int {
    			return int(math.Pow(float64(a),float64(b)))
    		},3,4))
    
    	fmt.Println(
    		apply(func(a ,b int)int {
    			return int(math.Pow(float64(a),float64(b)))
    		},3,4))
    	fmt.Println(sum(1,2,3,4,5,6,7,8,10))
    }


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;函数语法的要点回顾&#34;&gt;函数语法的要点回顾&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;返回值类型写在后面&lt;/li&gt;
&lt;li&gt;可以返回多个值&lt;/li&gt;
&lt;li&gt;函数可作为参数&lt;/li&gt;
&lt;li&gt;没有默认参数，可选参数 （有可变参数列表）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-2 条件语句和循环语句</title>
            <link>http://blog.flywithme.top/2018/02/04/note_03/</link>
            <pubDate>Sun, 04 Feb 2018 14:05:59 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/04/note_03/</guid>
            <description>

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语句&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;if 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;if 语句 由一个布尔表达式后紧跟一个或多个语句组成&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;if&amp;hellip;else&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;if 嵌套语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;switch 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;switch 语句用于基于不同条件执行不同动作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select 语句&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;    package main
    
    import (
    	&amp;quot;fmt&amp;quot;
    	&amp;quot;io/ioutil&amp;quot;
    )
    
    func grade(score int) string {
    	g := &amp;quot;&amp;quot;
    	switch {
    	case score &amp;lt; 0 || score &amp;gt; 100:
    		panic(fmt.Sprintf(
    			&amp;quot;Wrong score: %d&amp;quot;, score))
    	case score &amp;lt; 60:
    		g = &amp;quot;F&amp;quot;
    	case score &amp;lt; 80:
    		g = &amp;quot;C&amp;quot;
    	case score &amp;lt; 90:
    		g = &amp;quot;B&amp;quot;
    	case score &amp;lt;= 100:
    		g = &amp;quot;A&amp;quot;
    	}
    	return g
    }
    
    func main() {
    	// If &amp;quot;abc.txt&amp;quot; is not found,
    	// please check what current directory is,
    	// and change filename accordingly.
    	const filename = &amp;quot;abc.txt&amp;quot;
    	if contents, err := ioutil.ReadFile(filename); err != nil {
    		fmt.Println(err)
    	} else {
    		fmt.Printf(&amp;quot;%s\n&amp;quot;, contents)
    	}
    
    	fmt.Println(
    		grade(0),
    		grade(59),
    		grade(60),
    		grade(82),
    		grade(99),
    		grade(100),
    		// Uncomment to see it panics.
    		// grade(-3),
    	)
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。&lt;br /&gt;
  select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;select {
    case communication clause  :
       statement(s);      
    case communication clause  :
       statement(s); 
    /* 你可以定义任意数量的 case */
    default : /* 可选 */
       statement(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;以下描述了-select-语句的语法&#34;&gt;以下描述了 select 语句的语法：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;每个case都必须是一个通信&lt;/li&gt;
&lt;li&gt;所有channel表达式都会被求值&lt;/li&gt;
&lt;li&gt;所有被发送的表达式都会被求值&lt;/li&gt;
&lt;li&gt;如果任意某个通信可以进行，它就执行；其他被忽略。&lt;/li&gt;
&lt;li&gt;如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
&lt;strong&gt;否则：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果有default子句，则执行该语句。&lt;/li&gt;
&lt;li&gt;如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;   package main
   import &amp;quot;fmt&amp;quot;
   import &amp;quot;time&amp;quot;
   func f1(ch chan int) {
       time.Sleep(time.Second * 5)
       ch &amp;lt;- 1
   }
   func f2(ch chan int) {
       time.Sleep(time.Second * 10)
       ch &amp;lt;- 1
   }
   func main() {
       var ch1 = make(chan int)
       var ch2 = make(chan int)
       go f1(ch1)
       go f2(ch2)
       select {
       case &amp;lt;-ch1:
           fmt.Println(&amp;quot;The first case is selected.&amp;quot;)
       case &amp;lt;-ch2:
           fmt.Println(&amp;quot;The second case is selected.&amp;quot;)
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;循环语句&#34;&gt;循环语句&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;strconv&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;bufio&amp;quot;
	&amp;quot;strings&amp;quot;
)

func convertToBin(n int) string  {
	result := &amp;quot;&amp;quot;
	for ; n &amp;gt;0; n /=2{
		lsb := n%2
		result = strconv.Itoa(lsb)+result
	}
	return result
}

func printFile(filename string)  {
	file,err :=os.Open(filename)
	if err != nil {
		panic(err)
	}
	printFileContents(file)
}

func printFileContents(reader io.Reader) {
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
}
func forever()  {
	for{
		fmt.Println(&amp;quot;abc&amp;quot;)
	}

}

func main()  {
	fmt.Println(&amp;quot;convertToBin results:&amp;quot;)
	fmt.Println(
		convertToBin(15),
		convertToBin(2),
		convertToBin(5),
	)
	fmt.Println(&amp;quot;abc.txt contents:&amp;quot;)
	printFile(&amp;quot;abc.txt&amp;quot;)


	s := `abc &amp;quot;ad&amp;quot;
	kddd
	123
	p
	22333&#39;`
	printFileContents(strings.NewReader(s))
}



&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Go: 2-1 变量定义</title>
            <link>http://blog.flywithme.top/2018/02/03/note_02/</link>
            <pubDate>Sat, 03 Feb 2018 19:45:12 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/03/note_02/</guid>
            <description>

&lt;h5 id=&#34;变量声明&#34;&gt;变量声明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;指定变量类型，声明后若不赋值，使用默认值。&lt;/li&gt;
&lt;li&gt;根据值编译器自行判定变量类型。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。（函数外部无法省略var关键字）
```
//默认 没有初值
func variableZeroValue()  {
	var a int
	var s string
	fmt.Printf(&amp;ldquo;%d,%q\n&amp;rdquo;,a,s)
}&lt;/p&gt;

&lt;p&gt;//赋予初值和类型
func variableInitialValue()  {
	var a,b int = 3,4
	var s string = &amp;ldquo;abc&amp;rdquo;
	fmt.Println(a,b,s)
}&lt;/p&gt;

&lt;p&gt;//赋予初值
func variableTypeDeduction()  {
	var a,b,c,s = 3,4,true,&amp;ldquo;def&amp;rdquo;
	fmt.Println(a,b,c,s)
}&lt;/p&gt;

&lt;p&gt;func variableShorter()  {
	a,b,c,s := 3,4,true,&amp;ldquo;def&amp;rdquo;
	b = 3
	fmt.Println(a,b,c,s)
}
var(
	ss =&amp;ldquo;string&amp;rdquo;
	aa = 1
	bb = 2
)
func euler()  {
	//c := 3+4i
	//fmt.Println(cmplx.Abs&amp;copy;)
	//cmplx.Pow(math.E,1i*math.Pi)+1&lt;/p&gt;

&lt;p&gt;	fmt.Println(cmplx.Exp(1i*math.Pi)+1)
}
func main(){
	fmt.Println(&amp;ldquo;hello world&amp;rdquo;)
	variableZeroValue()
	variableInitialValue()
	variableTypeDeduction()
	variableShorter()
    fmt.Println(aa,ss,bb)
    euler()
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    
##### 内建变量类型
 - bool, string 
 - (u)int, (u)int8,(u)int16,(u)int32,(u)int64,(u)intptr (指针)
 - byte,rune(Go语言的一个字符型，char类型坑太多，代替char,32位)
 - float32,float64,complex64,complex128（复数）
 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func euler()  {
 	//c := 3+4i
 	//fmt.Println(cmplx.Abs(c))
 	//cmplx.Pow(math.E,1i*math.Pi)+1

 	fmt.Println(cmplx.Exp(1i*math.Pi)+1)
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; 
    
    

##### 强制类型转换
    
    func triangle()  {
        var a,b int = 3,4
        c := math.Sqrt(float64(a*a+b*b))
        fmt.Println(c)
    }

##### 常量的定义
 - 常量是一个简单值的标识符，在程序运行时，不会被修改的量。
 - 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
 - **iota** iota，特殊常量，（iota 可以被用作枚举值）可以认为是一个可以被编译器修改的常量。在每一个const关键字出现时，
 被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const filename = &amp;ldquo;abc.txt&amp;rdquo;
func consts()  {
	const a,b  = 3,4
	//a,b可以不指定类型
	c := math.Sqrt(a*a+b*b)
	fmt.Println(filename,c)&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;//第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：
const (
    a = iota
    b
    c
)&lt;/p&gt;

&lt;p&gt;const (
	b = 1 &amp;lt;&amp;lt;(10*iota)
	kb
	mb
	gb
	tb
	pb
)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h5 id=&#34;变量定义的要点&#34;&gt;变量定义的要点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;变量类型写在变量名之后&lt;/li&gt;
&lt;li&gt;编译器可以推测变量的类型&lt;/li&gt;
&lt;li&gt;没有char,只有rune&lt;/li&gt;
&lt;li&gt;原生支持复数类型&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
        <item>
            <title>Go:记笔：1-1 导读</title>
            <link>http://blog.flywithme.top/2018/02/02/note_01/</link>
            <pubDate>Fri, 02 Feb 2018 17:27:32 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/02/02/note_01/</guid>
            <description>

&lt;h5 id=&#34;go语言很特别&#34;&gt;GO语言很特别&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;没有&amp;rdquo;对象&amp;rdquo;，没有继承多态，没有泛型，么有try/catch&lt;/li&gt;
&lt;li&gt;有接口，函数式变成，CSP并发模型（goroutine+channel）&lt;/li&gt;
&lt;li&gt;学习Go语言很简单，因为语法简单&lt;/li&gt;
&lt;li&gt;用好Go语言不容易，因为要调整三观&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;go知识框架&#34;&gt;Go知识框架&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;基本语法  （遍历，选择，循环，指针，数组，容器）&lt;/li&gt;
&lt;li&gt;面向接口  （结构体，duck typing的概念，组合的思想）&lt;/li&gt;
&lt;li&gt;函数式编程（闭包的概念，例题）&lt;/li&gt;
&lt;li&gt;工程化   （资源管理，错误处理，测试和文档，性能调优）&lt;/li&gt;
&lt;li&gt;并发编程 （goroutine和channel,理解调度器，例题）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;实战项目&#34;&gt;实战项目&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;从零开始，使用Go语言自主搭建简单的分布式爬虫（不使用框架）&lt;/li&gt;
&lt;li&gt;爬取网站资料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517564741602.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;项目的架构图&lt;/strong&gt;
 &lt;img src=&#34;sources/go/1517565353894.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;开发路径：单任务版-&amp;gt;并发版-&amp;gt;分布式&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go 语言总结</title>
            <link>http://blog.flywithme.top/2018/01/30/go/</link>
            <pubDate>Tue, 30 Jan 2018 15:02:26 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2018/01/30/go/</guid>
            <description>

&lt;p&gt;前言：本篇文章整理自 ccmouse 发布的视频（搭建并行管道，感受GO语言魅力）&lt;/p&gt;

&lt;h5 id=&#34;go-归类总结&#34;&gt;Go 归类总结&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;类型检查：编译时&lt;/li&gt;
&lt;li&gt;运行环境：编译成机器代码直接运行&lt;/li&gt;
&lt;li&gt;GO语言的特色：面向接口，函数式编程，并发编程&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;go语言的并发编程&#34;&gt;Go语言的并发编程&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;采用CSP(Communication Sequential Process)模型（有学术论文，比较复杂）&lt;/li&gt;
&lt;li&gt;code层面不需要锁，不需要callback&lt;/li&gt;
&lt;li&gt;并发编程VS并行计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;go语言的安装与开放环境&#34;&gt;Go语言的安装与开放环境&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;下载：&lt;a href=&#34;https://golang.org/dl/&#34;&gt;https://golang.org/dl/&lt;/a&gt; 下载对应系统的go安装包&lt;/li&gt;
&lt;li&gt;开发工具： 我使用的是 WebStrom +go 插件 IDE jetbeans 除了Goland 编译器&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;一个简单的-goroutine&#34;&gt;一个简单的 goroutine&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;package main
import &amp;quot;strconv&amp;quot;
import &amp;quot;fmt&amp;quot;
func main() {
    taskChan := make(chan string, 3)
    doneChan := make(chan int, 1)

    for i := 0; i &amp;lt; 3; i++ {
        taskChan &amp;lt;- strconv.Itoa(i)
        fmt.Println(&amp;quot;send: &amp;quot;, i)
    }

    go func() {
        for i := 0; i &amp;lt; 3; i++ {
            task := &amp;lt;-taskChan
            fmt.Println(&amp;quot;received: &amp;quot;, task)
        }
        doneChan &amp;lt;- 1
    }()

    &amp;lt;-doneChan
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;外部排序-归并排序&#34;&gt;外部排序 - 归并排序&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;将数据分为左右两半，分别归并排序，再把两个有序数据归并&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何归并：
[1,3,5,7],[1,5,8,9] -&amp;gt; 1&lt;br /&gt;
[3,5,7],[1,5,8,9] -&amp;gt; 1&lt;br /&gt;
[3,5,7],[5,8,9] -&amp;gt; 3&lt;br /&gt;
[5,7],[5,8,9] -&amp;gt; 5&lt;br /&gt;
[7],[5,8,9] -&amp;gt; 5&lt;br /&gt;
[7],[8,9] -&amp;gt; 7&lt;br /&gt;
[],[8,9] -&amp;gt; 8&lt;br /&gt;
[],[9] -&amp;gt; 9&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;外部排序 可以把一个数据源使用节点切分成很多部分，然后分别进行排序&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;拆分数据源
&lt;img src=&#34;sources/go/1517300935152.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按节点归并 （k路归并）
&lt;img src=&#34;sources/go/1517302277060.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通道
&lt;img src=&#34;sources/go/1517302401765.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;节点
&lt;img src=&#34;sources/go/1517302488042.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;节点组装
&lt;img src=&#34;sources/go/1517302577852.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;外部排序-单机版-pipeline-搭建&#34;&gt;外部排序 -单机版 Pipeline 搭建&lt;/h5&gt;

&lt;p&gt;示意图
&lt;img src=&#34;sources/go/1517302752446.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ReaderSource 节点-支持分块&lt;/li&gt;
&lt;li&gt;MergeN - 搭建归并节点组&lt;/li&gt;
&lt;li&gt;pipeline的搭建及运行 - 观察CPU及线程数量上的使用情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;外部排序-网络扩展&#34;&gt;外部排序 -网络扩展&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;sources/go/1517468528492.jpg&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>pigeon </title>
            <link>http://blog.flywithme.top/2017/12/13/pigeon/</link>
            <pubDate>Wed, 13 Dec 2017 21:55:46 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/12/13/pigeon/</guid>
            <description>

&lt;h4 id=&#34;小记&#34;&gt;小记&lt;/h4&gt;

&lt;p&gt;最近做持续的自动集成工具，例如数据模型好api接口模型的自动化生产，Code提交自动检查，合并代码到打包分支自动打包等等&lt;br /&gt;
 我们需要实时监控这些自动化的过程是否按预期完成了自己的任务，如果出现一些错误，或者需求要在完成任务之后提醒开发者。
 所以我就开发了一个基于公司内部通信系统的一个小型的消息通知管理中心。
 虽然之前断断续续有学写一些golang的东西，但是一直没有成型的作品，这是继上次做的个人实践项目之后，第一个在公司内部产生实际效益的服务。&lt;/p&gt;

&lt;h5 id=&#34;源码地址在我的github上-关于fork提意见-适合初学者&#34;&gt;源码地址在我的github上  关于fork提意见。适合初学者&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/flywithbug/pigeon&#34;&gt;源码地址&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;主要功能&#34;&gt;主要功能&lt;/h4&gt;

&lt;p&gt;本服务的主要功能是用于 给不同的服务配置不同的消息类型和接收人。最终会根据调用通知群组id发送给不同的接受对象。
简单的实现了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;组员的增删改查&lt;/li&gt;
&lt;li&gt;群组的增删改查&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息应用的增删改查&lt;/li&gt;
&lt;li&gt;组员和群组的关系的增删&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;群组和消息应用直之间的关系增删&lt;/li&gt;
&lt;li&gt;应用版本号的tag自增接口（额外需求，与前面几个接口无关）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;接口-json请求格式-application-json&#34;&gt;接口  json请求格式(application/json)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  1. /adduse               POST

    //添加用户 
    {
     &amp;quot;mail&amp;quot;:&amp;quot;jack@meituan.com&amp;quot;,
     &amp;quot;mobile&amp;quot;:&amp;quot;18792289&amp;quot;,
     &amp;quot;user_name&amp;quot;:&amp;quot;jack&amp;quot;
    }

  2. /deleteuser           POST

    //删除用户 
    {
     &amp;quot;user_name&amp;quot;:&amp;quot;jack&amp;quot;
    }

  3. /users             GET

    //用户列表


  4. /addgroup          POST

    //添加群组
    {
     &amp;quot;group_name&amp;quot;:&amp;quot;商户前端&amp;quot;,
     &amp;quot;type&amp;quot;:1,
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant_mci000011&amp;quot;,
     &amp;quot;app_name&amp;quot;:&amp;quot;点评管家&amp;quot;,
     &amp;quot;app_id&amp;quot;:1
    }

  5. /updategroup       POST

    //更新群组信息
    {
     &amp;quot;group_name&amp;quot;:&amp;quot;商户前端html&amp;quot;,
     &amp;quot;type&amp;quot;:1,
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant_mci000011&amp;quot;,
     &amp;quot;app_name&amp;quot;:&amp;quot;点评管家&amp;quot;,
     &amp;quot;app_id&amp;quot;:&amp;quot;28fa3c968b438fb71c8d7825af609591&amp;quot;
    }

  6. /addgcrow          POST

    //添加群组成员
    {
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant_mci&amp;quot;,
     &amp;quot;user_name&amp;quot;:&amp;quot;erfeng.cheng&amp;quot;
    }

  7. /deletecrow        POST

    //删除群组成员
    {
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant_mci&amp;quot;,
     &amp;quot;user_name&amp;quot;:&amp;quot;erfeng.cheng&amp;quot;
    }

  8. /grcrows           POST

    //批量关联群组成员
    {
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant&amp;quot;,
     &amp;quot;users&amp;quot;:[
     &amp;quot;erfeng.cheng&amp;quot;
     ]
    }

  9.  /grouplist        GET

    //群组列表

  10. /group/:group_id  GET

    //群组信息

  11. /addapp           POST

    //添加消息应用
    {
     &amp;quot;pub_id&amp;quot;:&amp;quot;1372264&amp;quot;,
     &amp;quot;app_key&amp;quot;:&amp;quot;029507&amp;quot;,
     &amp;quot;app_secret&amp;quot;:&amp;quot;232alkalalalalallala&amp;quot;,
     &amp;quot;app_name&amp;quot;:&amp;quot;点评管家-通知&amp;quot;
    }

  12. /apps             GET

    //消息应用列表


  13. /sendmsg          POST

    //发送消息
    {
     &amp;quot;title&amp;quot;:&amp;quot;test&amp;quot;,
     &amp;quot;content&amp;quot;:&amp;quot;1.首页\n2.微海报&amp;quot;,
     &amp;quot;receivers&amp;quot;:[&amp;quot;erfeng.cheng&amp;quot;],
     &amp;quot;group_id&amp;quot;:&amp;quot;merchant&amp;quot;
    }

  14. /getversiontag?app_name=merchant_model&amp;amp;version=7.1.0  GET      

    //获取版本号自增tag 每次调用会自增1  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sql脚本-不同的table之前数据未做同步-可能出现关联过的用户在用户表中已被删除的情况&#34;&gt;SQL脚本 （不同的table之前数据未做同步，可能出现关联过的用户在用户表中已被删除的情况）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# ************************************************************
# Sequel Pro SQL dump
# Version 4096
#
# http://www.sequelpro.com/
# http://code.google.com/p/sequel-pro/
#
# Host: 10.66.3.50 (MySQL 5.7.20)
# Database: pigeon
# Generation Time: 2017-12-13 13:28:43 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table p_app_info
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_app_info`;

CREATE TABLE `p_app_info` (
  `uid` int(3) unsigned NOT NULL AUTO_INCREMENT,
  `pub_id` varchar(12) NOT NULL DEFAULT &#39;&#39;,
  `app_key` varchar(16) NOT NULL DEFAULT &#39;&#39;,
  `app_secret` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  `app_name` varchar(20) NOT NULL DEFAULT &#39;&#39;,
  `app_id` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `pub_id` (`pub_id`),
  UNIQUE KEY `app_key` (`app_key`),
  UNIQUE KEY `app_secret` (`app_secret`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `p_app_info` WRITE;
/*!40000 ALTER TABLE `p_app_info` DISABLE KEYS */;

INSERT INTO `p_app_info` (`uid`, `pub_id`, `app_key`, `app_secret`, `app_name`, `app_id`)
VALUES
    (5,&#39;137441864&#39;,&#39;02210uU17507&#39;,&#39;b13fdda68c0034eefea16cb1&#39;,&#39;点评管家-通知&#39;,&#39;28fa3c968c8d7825af609591&#39;);

/*!40000 ALTER TABLE `p_app_info` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table p_bussiness
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_bussiness`;

CREATE TABLE `p_bussiness` (
  `bid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `bis_type` int(2) NOT NULL,
  `group_id` int(11) NOT NULL,
  `bis_name` varchar(20) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`bid`),
  UNIQUE KEY `bis_type` (`bis_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;



# Dump of table p_group
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_group`;

CREATE TABLE `p_group` (
  `gid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `group_id` varchar(30) NOT NULL DEFAULT &#39;&#39;,
  `group_name` varchar(20) NOT NULL DEFAULT &#39;&#39;,
  `type` int(2) NOT NULL DEFAULT &#39;0&#39;,
  `app_id` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  `app_name` varchar(20) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`gid`),
  UNIQUE KEY `group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `p_group` WRITE;
/*!40000 ALTER TABLE `p_group` DISABLE KEYS */;

INSERT INTO `p_group` (`gid`, `group_id`, `group_name`, `type`, `app_id`, `app_name`)
VALUES
    (23,&#39;merchant&#39;,&#39;点评管家-通知&#39;,0,&#39;28fa3c968b438af609591&#39;,&#39;点评管家-通知&#39;);

/*!40000 ALTER TABLE `p_group` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table p_group_user_relation
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_group_user_relation`;

CREATE TABLE `p_group_user_relation` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `group_id` varchar(30) NOT NULL DEFAULT &#39;&#39;,
  `user_name` varchar(18) NOT NULL DEFAULT &#39;&#39;,
  `unique_key` varchar(40) NOT NULL DEFAULT &#39;&#39;,
  `group_name` varchar(20) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_key` (`unique_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `p_group_user_relation` WRITE;
/*!40000 ALTER TABLE `p_group_user_relation` DISABLE KEYS */;

INSERT INTO `p_group_user_relation` (`id`, `group_id`, `user_name`, `unique_key`, `group_name`)
VALUES
    (76,&#39;merchant&#39;,&#39;Jack&#39;,&#39;Jackmerchant&#39;,&#39;点评管家&#39;);

/*!40000 ALTER TABLE `p_group_user_relation` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table p_message
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_message`;

CREATE TABLE `p_message` (
  `mid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `m_type` int(1) NOT NULL,
  `text` varchar(500) NOT NULL DEFAULT &#39;&#39;,
  `body` varchar(500) DEFAULT &#39;&#39;,
  `status` int(1) NOT NULL DEFAULT &#39;0&#39;,
  PRIMARY KEY (`mid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;



# Dump of table p_user
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_user`;

CREATE TABLE `p_user` (
  `uid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(18) NOT NULL DEFAULT &#39;&#39;,
  `mail` varchar(50) DEFAULT &#39;&#39;,
  `mobile` varchar(13) DEFAULT &#39;&#39;,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `username` (`user_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `p_user` WRITE;
/*!40000 ALTER TABLE `p_user` DISABLE KEYS */;

INSERT INTO `p_user` (`uid`, `user_name`, `mail`, `mobile`)
VALUES
    (1,&#39;Jack&#39;,&#39;Jack@mail.com&#39;,&#39;13223232223&#39;);

/*!40000 ALTER TABLE `p_user` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table p_version_tag
# ------------------------------------------------------------

DROP TABLE IF EXISTS `p_version_tag`;

CREATE TABLE `p_version_tag` (
  `uid` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `tag` int(4) NOT NULL DEFAULT &#39;1&#39;,
  `version` varchar(10) NOT NULL DEFAULT &#39;&#39;,
  `app_name` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  `unique_key` varchar(32) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `unique_key` (`unique_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `p_version_tag` WRITE;
/*!40000 ALTER TABLE `p_version_tag` DISABLE KEYS */;

INSERT INTO `p_version_tag` (`uid`, `tag`, `version`, `app_name`, `unique_key`)
VALUES
    (9,38,&#39;7.1.0&#39;,&#39;MTAStaticModels&#39;,&#39;19b92d56eaa94a58f48e6f58a1498d12&#39;);

/*!40000 ALTER TABLE `p_version_tag` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>Shell 小记，-文本操作</title>
            <link>http://blog.flywithme.top/2017/11/17/shell/</link>
            <pubDate>Fri, 17 Nov 2017 16:26:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/17/shell/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;修改文件的某一行内容
做自动的git提交和PodSpec发布脚本
需要在提交之前使用shell脚本修改podSpec文件的Version版本号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最开始想使用 &lt;code&gt;sed&lt;/code&gt; 这个命令，但是mac上&lt;code&gt;-i&lt;/code&gt;命令无法使用，使用-e &lt;code&gt;sed -e &amp;quot;4d&amp;quot; Pod/Resources/MCICheckTime&lt;/code&gt; 命令可以修改，
但是无法输出修改内容到文件上。一直提示no such file. 无法，只得另找办法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;awk&lt;/code&gt; 更换到使用awk命令的方式&lt;/p&gt;

&lt;p&gt;在文件的当前目录下操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cmms=`date &#39;+%y.%m.%d.%H&#39;`
 export version=&amp;quot;  s.version      = \&amp;quot;$cmms\&amp;quot;&amp;quot;
 awk &#39;NR==4{$0=ENVIRON[&amp;quot;version&amp;quot;]}{print}&#39; MTAForMCICodeInspect_backup.podspec &amp;gt; MTAForMCICodeInspect.podspec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我知道肯定有更简单直接的方法，但是因为不熟悉shell脚本，走了很多弯路，这个是我一个下午折腾出来可以实现的路径，某些路过的同学可以少走些弯路，&lt;/p&gt;

&lt;p&gt;如果知道更方便的方法，好请邮件（flywithme.top@gmail.com）告知下啊。非常感谢&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Jenkins-打包之远程构建</title>
            <link>http://blog.flywithme.top/2017/11/16/Jenkins/</link>
            <pubDate>Thu, 16 Nov 2017 16:59:57 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/16/Jenkins/</guid>
            <description>&lt;p&gt;在大型项目中，经常会有新的业务或者基础库需要更新合并进入测试分支，然后使用Jenkins打包给测试人员进行测试。
但是如果人工去构建打包又会显得不够fashion。每次有新的代码合入测完分支，就自动打一个包给测试人员，会更高效一些。&lt;/p&gt;

&lt;p&gt;Jenkins安装以及完毕的情况下，配置这样的事情也不算麻烦&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/jenkins/01.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图所示的配置 &lt;strong&gt;触发远程构建&lt;/strong&gt;，是使用身份令牌的形式完成的：&lt;a href=&#34;http://host/job/merchant/buildWithParameters?token=token&#34;&gt;http://host/job/merchant/buildWithParameters?token=token&lt;/a&gt;
get请求形式即可完成&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/jenkins/02.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定时构建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举个🌰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * * * *
第一个*表示分钟，取值0~59
第二个*表示小时，取值0~23
第三个*表示一个月的第几天，取值1~31
第四个*表示第几月，取值1~12
第五个*表示一周中的第几天，取值0~7，其中0和7代表的都是周日

H H/3 * * *  
每3小时构建以此

0 9,13,18 * * 1-5
每周一到周五 9点，13点，18点构建，
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>无线真机调试-Xcode9 -iOS</title>
            <link>http://blog.flywithme.top/2017/11/16/wirelessdebug/</link>
            <pubDate>Thu, 16 Nov 2017 11:15:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/16/wirelessdebug/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;首先你需要 Mac系统电脑 安装Xcode9 iPhone设备需要iOS11的系统&lt;/li&gt;
&lt;li&gt;其次你的手机必须和电脑处于同一个无线局域网中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首次安装连接需要先连接数据线至同一个局域网的Mac上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开-&amp;gt;windows里的Device and Simulators选项，勾选 Connect Via network&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设你的开发证书和描述文件都是齐全完整的，开始编译，会自动提示。真机调试选择刚才连接到 机器名字&lt;/p&gt;

&lt;p&gt;数据线链接手机 打开device and simulators面板，勾选connect via network&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/wireless/002.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;选择你的设备开始编译 （就算断开数据线，这个设备依然会留在这里）
  &lt;img src=&#34;sources/wireless/005.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/wireless/003.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;开始编译结束-可以查看手机的device日志，然后手机名字右边的网球 表示无线连接正常
  &lt;img src=&#34;sources/wireless/004.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>imageMagick 和 PlistBuddy合体生成图标</title>
            <link>http://blog.flywithme.top/2017/11/15/PlistBuddy/</link>
            <pubDate>Wed, 15 Nov 2017 19:06:14 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/15/PlistBuddy/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://github.com/flywithbug/Shell_Demo&#34;&gt;demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图片内容处理文件 (merchant-icon-generator.sh)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#获取参数 文件源
SRC_FILE=&amp;quot;$1&amp;quot; 
#版本号
shortVersion=&amp;quot;$2&amp;quot;
#标签number
bundlerNum=&amp;quot;$3&amp;quot;

#转换      文件         绘制    坐标           填充       颜色          透明度             填充      坐标          填充      颜色           透明度            生成目标图片
convert &amp;quot;$SRC_FILE&amp;quot; -region 1024x244+0+780 -fill &amp;quot;rgb(0,159,250)&amp;quot; -colorize 100%   -region 1024x244+650+780 -fill &amp;quot;rgb(102,230,32)&amp;quot; -colorize 100%  target-new.png  

#转换       文件         重置坐标  地图坐标西南角  写入 白色字体，文字尺寸     绘制文字   offset    内容                    
convert target-new.png -gravity southwest -fill white -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$shortVersion&#39;&amp;quot;  -gravity southeast -fill white -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$bundlerNum&#39;&amp;quot; target-new.png
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令&lt;br /&gt;
&lt;img src=&#34;sources/shell/01.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原图&lt;br /&gt;
&lt;img src=&#34;sources/shell/1024-origin.png&#34; width = &#34;20%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目标图&lt;br /&gt;
&lt;img src=&#34;sources/shell/target-new.png&#34; width = &#34;20%&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plist处理文件（merchant_plist_generator.sh）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
appInfoPlistPath=&amp;quot;Jovi/Jovi/Info-AdHoc.plist&amp;quot;
bundleShortVersion=$(/usr/libexec/PlistBuddy -c &amp;quot;print CFBundleShortVersionString&amp;quot; ${appInfoPlistPath})
bundleVersion=$(/usr/libexec/PlistBuddy -c &amp;quot;print CFBundleVersion&amp;quot; ${appInfoPlistPath})

# url=&amp;quot;$1&amp;quot;
# if [ &amp;quot;$1&amp;quot;  = &amp;quot;&amp;quot; ]
# then 
#   url=&amp;quot;http://app.dp:8080/view/Merchant/job/dpmerchant_adhocMCI/lastBuild/buildNumber&amp;quot;
# fi
result=&amp;quot;23232&amp;quot;
while [ &amp;quot;$result&amp;quot; == &amp;quot;&amp;quot; ]
do 
    result=$(curl -s &amp;quot;$url&amp;quot;)
done

newBundleVersion=&amp;quot;&amp;quot;$bundleShortVersion&amp;quot;.&amp;quot;$result&amp;quot;&amp;quot;
/usr/libexec/PlistBuddy -c &amp;quot;Set CFBundleVersion ${newBundleVersion}&amp;quot;  ${appInfoPlistPath}

sh merchant-icon-generator.sh &amp;quot;1024-origin.png&amp;quot; &amp;quot;$bundleShortVersion&amp;quot; &amp;quot;$result&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;sources/shell/02.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;sources/shell/03.png&#34; width = &#34;100%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片生产(merchant-icon-generator.sh)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SRC_FILE=&amp;quot;$1&amp;quot;
shortVersion=&amp;quot;$2&amp;quot;
bundlerNum=&amp;quot;$3&amp;quot;

convert &amp;quot;$SRC_FILE&amp;quot; -region 1024x254+0+770 -fill &amp;quot;rgb(0,159,250)&amp;quot; -colorize 100%   -region 1024x254+650+770 -fill &amp;quot;rgb(102,230,32)&amp;quot; -colorize 100%  target-new.png  
convert target-new.png -gravity southwest -fill white -font DINPro-Bold.otf -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$shortVersion&#39;&amp;quot;  -gravity southeast -fill white -pointsize 230 -draw &amp;quot;text 60,-10 &#39;$bundlerNum&#39;&amp;quot; target-new.png

DST_PATH=&amp;quot;Jovi/Jovi/JVImages.xcassets/AppIcon.appiconset/&amp;quot;

if [ ! -d &amp;quot;$DST_PATH&amp;quot; ];then
    mkdir -p &amp;quot;$DST_PATH&amp;quot;
fi

info() {
     local green=&amp;quot;\033[1;32m&amp;quot;
     local normal=&amp;quot;\033[0m&amp;quot;
     echo -e &amp;quot;[${green}INFO${normal}] $1&amp;quot;
}

error() {
     local red=&amp;quot;\033[1;31m&amp;quot;
     local normal=&amp;quot;\033[0m&amp;quot;
     echo -e &amp;quot;[${red}ERROR${normal}] $1&amp;quot;
}
SRC_FILE=&amp;quot;target-new.png&amp;quot;

info &#39;Generate 1024x1024.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 1024x1024 &amp;quot;$DST_PATH/1024x1024.png&amp;quot;

info &#39;Generate Icon-20.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 40x40 &amp;quot;$DST_PATH/Icon-20@2x.png&amp;quot;
info &#39;Generate Icon-40@2x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 60x60 &amp;quot;$DST_PATH/Icon-20@3x.png&amp;quot;


info &#39;Generate Icon-60@2x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 120x120 &amp;quot;$DST_PATH/Icon-60@2x.png&amp;quot;
info &#39;Generate Icon-60@3x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 180x180 &amp;quot;$DST_PATH/Icon-60@3x.png&amp;quot;



info &#39;Generate Icon-Small.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 29x29 &amp;quot;$DST_PATH/Icon-Small.png&amp;quot;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 58x58 &amp;quot;$DST_PATH/Icon-Small@2x.png&amp;quot;
info &#39;Generate Icon-Small-40@3x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 87x87 &amp;quot;$DST_PATH/Icon-Small@3x.png&amp;quot;



info &#39;Generate Icon-Spotlight-40@2x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 80x80 &amp;quot;$DST_PATH/Icon-Spotlight-40@2x.png&amp;quot;
info &#39;Generate Icon@2x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 120x120 &amp;quot;$DST_PATH/Icon-Spotlight-40@3x.png&amp;quot;


info &#39;Generate Icon.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 57x57 &amp;quot;$DST_PATH/Icon.png&amp;quot;
info &#39;Generate Icon-Small@2x.png ...&#39;
convert &amp;quot;$SRC_FILE&amp;quot; -resize 114x114 &amp;quot;$DST_PATH/Icon@2x.png&amp;quot;


info &#39;Generate Done.&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>golang web Send Email</title>
            <link>http://blog.flywithme.top/2017/11/13/mail/</link>
            <pubDate>Mon, 13 Nov 2017 17:20:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/11/13/mail/</guid>
            <description>&lt;p&gt;//注意邮件格式，以免被当垃圾邮件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package email


import (
    &amp;quot;net/smtp&amp;quot;
    &amp;quot;strings&amp;quot;
)

const (
    HOST        = &amp;quot;smtp.163.com&amp;quot;
    SERVER_ADDR = &amp;quot;smtp.163.com:25&amp;quot;
    USER        = &amp;quot;xxx@163.com&amp;quot; //发送邮件的邮箱
    PASSWORD    = &amp;quot;xxx&amp;quot;         //发送邮件邮箱的客户端授权密码
)

type Email struct {
    to      string &amp;quot;to&amp;quot;
    subject string &amp;quot;subject&amp;quot;
    msg     string &amp;quot;msg&amp;quot;
}

func NewEmail(to, subject, msg string) *Email {
    return &amp;amp;Email{to: to, subject: subject, msg: msg}
}

func SendEmail(email *Email) error {
    auth := smtp.PlainAuth(&amp;quot;&amp;quot;, USER, PASSWORD, HOST)
    sendTo := strings.Split(email.to, &amp;quot;;&amp;quot;)
    done := make(chan error, 1024)

    go func() {
        defer close(done)
        for _, v := range sendTo {

            str := strings.Replace(&amp;quot;From: &amp;quot;+USER+&amp;quot;~To: &amp;quot;+v+&amp;quot;~Subject: &amp;quot;+email.subject+&amp;quot;~~&amp;quot;, &amp;quot;~&amp;quot;, &amp;quot;\r\n&amp;quot;, -1) + email.msg

            err := smtp.SendMail(
                SERVER_ADDR,
                auth,
                USER,
                []string{v},
                []byte(str),
            )
            done &amp;lt;- err
        }
    }()

    for i := 0; i &amp;lt; len(sendTo); i++ {
        &amp;lt;-done
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;testCode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sendMail()  {
    fmt.Println(&amp;quot;发送邮件&amp;quot;)
    mycontent := &amp;quot;请查收验证码：12322&amp;quot;
    mail := email.NewEmail(&amp;quot;xxx@163.com&amp;quot;,&amp;quot;案发现场-注册邮件验证&amp;quot;,mycontent)
    err := email.SendEmail(mail)
    fmt.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
