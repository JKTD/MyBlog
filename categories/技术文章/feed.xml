<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术文章 on Fly With Me</title>
        <link>http://blog.flywithme.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/feed/index.xml</link>
        <language>zh-CN</language>
        <author>Brasbug</author>
        <rights>Copyright (c) 2016, Brasbug; all rights reserved.</rights>
        <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
        
        <item>
            <title>大文件分片上传解决方案</title>
            <link>http://blog.flywithme.top/2017/08/03/bigFileUpload/</link>
            <pubDate>Thu, 03 Aug 2017 13:44:56 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/08/03/bigFileUpload/</guid>
            <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分片模型：索引，上传状态，偏移量，大小，文件名，类型，分片数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;md5: 获取文件的md5值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件管理工具：文件路径， 分析文件内容，生成数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;上传任务池中会保持小于等于3个的请求任务
 启动上传任务之后会往任务池中添加上传任务，若分片数大于3个，则会把任务池填满。
 等其中任意一个任务上传结束之后会回调通知任务池，添加一个新的请求任务进入任务池中
 等上传任务全部结束，发送合并片的请求(这个其实是业务方自己做的)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.flywithme.top/sources/bigFileUpload/bigfile001.png&#34; alt=&#34;bigfile001&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文件的md5值读取，在文件很大的时候不要使用把数据转换成二进制流的形式获取。因为这样可能会造成内存溢出。使用分片读取md5的形式&lt;br /&gt;
   模型组里可以保存每一个分片的md5值，用于分片的上传状态。&lt;br /&gt;
   管理中心可以保存分片文件的上传状态，上传失败之后可以尝试重新上传，同一个分片数据只上传一次。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>swift3-22</title>
            <link>http://blog.flywithme.top/2017/04/17/swift22/</link>
            <pubDate>Mon, 17 Apr 2017 10:48:35 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/17/swift22/</guid>
            <description></description>
        </item>
        
        <item>
            <title>swift3-21 析构过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift21/</link>
            <pubDate>Thu, 13 Apr 2017 17:19:53 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift21/</guid>
            <description>&lt;p&gt;在一个类的实例被释放之前，析构函数就被立即调用，用关键字 deinit 来表示析构函数， 类似与初始化使用 init 来标示。析构函数只适用于类类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;析构过程原理&lt;/strong&gt; Swift会自动释放不在需要的实例以释放资源。通过ARC处理实例的内存管理。通常实例被释放是不需要手动清理的。但是当使用到一些资源的
 时候可能就需要额外的清理了。比如打开另一个文件写入数据，就需要在实例被释放前关闭该文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：在类的定义中，每个类最多只有一个析构函数，析构函数不带任何参数，不带括号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deinit{
   //执行析构过程
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;code&gt;deinit&lt;/code&gt;的调用时机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var counter = 0;  
class BaseClass {
    init() {
        counter += 1;
    }
    deinit {
        counter -= 1;
    }
}

var show: BaseClass? = BaseClass()
print(counter) // 1
show = nil  
print(counter) // 0
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-20 构造过程</title>
            <link>http://blog.flywithme.top/2017/04/13/swift20/</link>
            <pubDate>Thu, 13 Apr 2017 16:24:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift20/</guid>
            <description>&lt;p&gt;构造过程是为了使用某个类、结构体或者枚举类型实例而进行的准备过程。这个过程包含了为实例的每一个属性设置初始值 的初始化任务&lt;br /&gt;
 swift的构造函数使用的是init()方法。 这个方法没有返回值。主要任务是保证新实例在第一次使用之前完成正确的初始化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造器&lt;/strong&gt; 在创建某特定类型的新实例时调用，它的关键字是init&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init(){
    //执行属性初值设置
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两段式构造&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值  第一段
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善  第二段
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认属性值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age:Int
    init(){
        age = 18
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造参数&lt;/strong&gt;  定义构造器 init() 时提供构造参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选属性类型&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认构造器&lt;/strong&gt; 所有属性都设置有默认值的实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class simple{
    var name = &amp;quot;&amp;quot;
    var age = 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;required 构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;必须被子类实现的构造函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    //子类必须实现
    required init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    private final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
    //子类实现父类的required
    required convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)
son.name
son.age
son.level
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数的继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    var level:String?
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String

    init(name:String, age:Int, str1:String){
        //构造初值
        self.str1 = str1
        super.init(name: name, age: age)
        //进一步完善
        self.agefomat(age: age)

    }
    final func agefomat(age:Int){
        if age &amp;lt;= 0 {
            self.age = 1
        }
    }
   //构造函数的继承
    override convenience init(name: String, age: Int) {
        self.init(name: name, age: age, str1: &amp;quot;&amp;quot;)
    }
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}
let son = sonClass1.init(name: &amp;quot;a&amp;quot;, age: 2, str1: &amp;quot;str&amp;quot;)    
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-19 多态性</title>
            <link>http://blog.flywithme.top/2017/04/13/swift19/</link>
            <pubDate>Thu, 13 Apr 2017 12:00:36 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/13/swift19/</guid>
            <description>&lt;p&gt;&lt;strong&gt;多态性&lt;/strong&gt; 同样的操作或者方法，不同的对象执行的时候表现出完全不同的行为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用父类指针或者引用指向子类的实例，然后再自雷中覆盖父类的方法，利用父类引用调用相同方法而产生不同的行为。&lt;/li&gt;
&lt;li&gt;多态的条件：a,必须存在继承关系，b,子类对父类的方法进行重写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var name:String
    var age:Int
    init() {
        self.name = &amp;quot;&amp;quot;
        self.age = 0
    }
    init(name:String,age:Int) {
        self.age = age
        self.name = name
    }
    func testFunc() {
        print(&amp;quot;baseClass&amp;quot;)
    }
}

class sonClass1:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    //重载
    override func testFunc() {
        print(&amp;quot;sonClass1&amp;quot;)
    }
}

class sonClass2:baseClass{
    var str1:String = &amp;quot;str1&amp;quot;
    override func testFunc() {
        print(&amp;quot;sonClass2&amp;quot;)
    }
}


final class grandSon1:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}
final class grandSon01:sonClass1{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

final class grandSon02:sonClass2{
    var strGrand:String = &amp;quot;strGrand&amp;quot;
}

func printBasicInfo(base:baseClass){
    print(&amp;quot;name is \(base.name)&amp;quot;)
}

var grandson1 = grandSon01.init(name: &amp;quot;a&amp;quot;, age: 10)
var grandson2 = grandSon02.init(name: &amp;quot;b&amp;quot;, age: 7)
printBasicInfo(base: grandson1)
printBasicInfo(base: grandson2)
grandson1.testFunc()
grandson2.testFunc()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-18 继承</title>
            <link>http://blog.flywithme.top/2017/04/01/swift18/</link>
            <pubDate>Sat, 01 Apr 2017 22:29:17 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/04/01/swift18/</guid>
            <description>&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：我们可以理解为一个类获取了另外一个类的方法和属性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类)，
我们也可以为类中继承来的属性添加属性观察器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基类&lt;/strong&gt; 没有继承其它类的类，称之为基类（Base Class）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类&lt;/strong&gt; 子类指的是在一个已有类的基础上创建一个新的类。为了指明某个类的超类，将超类名写在子类名的后面，用冒号(:)分隔,语法格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
}
sonClass.init(name: &amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重写（Overriding）&lt;/strong&gt; 子类可以通过继承来的实例方法，类方法，实例属性，或下标脚本来实现自己的定制功能，我们把这种行为叫重写（overriding）。我们可以使用 override 关键字来实现重&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class baseClass{
    var baseName:String
    init(name:String) {
        self.baseName = name
    }
}
class sonClass:baseClass{
    var levelStr:String
    override init(name: String) {
        self.levelStr = name.appending(&amp;quot;b&amp;quot;)
        super.init(name: name)
    }
}

var son =  sonClass.init(name: &amp;quot;a&amp;quot;)
son.baseName
son.levelStr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// &lt;strong&gt;防止重写&lt;/strong&gt;   使用 final 关键字防止它们被重写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //final 关键字
 final class grandSon:sonClass{
     final var grand:String = &amp;quot;&amp;quot;
     override init(name: String) {
         super.init(name: name)
     }
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-17 单例</title>
            <link>http://blog.flywithme.top/2017/03/31/swift17/</link>
            <pubDate>Fri, 31 Mar 2017 19:47:41 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/31/swift17/</guid>
            <description>&lt;p&gt;&lt;strong&gt;单例写法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Manager{
    public var score = 0
    public static let defaultManager = Manager.init()

    private init(){

    }
    public func addScore(){
        score += 10
    }
}




let manager = Manager.defaultManager

manager.addScore()
manager.score

manager.addScore()
manager.score
let manager2 = Manager.defaultManager
manager2.addScore()
manager2.score
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-16 属性</title>
            <link>http://blog.flywithme.top/2017/03/30/swift16/</link>
            <pubDate>Thu, 30 Mar 2017 16:53:45 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/30/swift16/</guid>
            <description>&lt;p&gt;Swift 属性将值跟特定的类、结构或枚举关联&lt;/p&gt;

&lt;p&gt;属性可分为存储属性和计算属性:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;存储属性&lt;/th&gt;
&lt;th&gt;计算属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存储常量或变量作为实例的一部分&lt;/td&gt;
&lt;td&gt;计算（而不是存储）一个值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于类和结构体&lt;/td&gt;
&lt;td&gt;用于类、结构体和枚举&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;存储属性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以在定义存储属性的时候指定默认值&lt;/li&gt;
&lt;li&gt;在构造过程中设置或修改存储值属性的值，身子修改常量存储属性的值
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;延迟存储属性&lt;/strong&gt; lazy property&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;延迟对象的创建&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当属性的值依赖于其他未知类&lt;/p&gt;

&lt;p&gt;class CloseRange{
    var start: Int
    var end:Int
    var width:Int{
        return end - start + 1
    }
    lazy var sum: Int = {
        var res = 0
        for i in self.start&amp;hellip;self.end{
            res += 1
        }
        return res
    }()
    var sum1: Int {
        var res = 0
        for i in start&amp;hellip;end{
            res += 1
        }
        return res
    }
    init?(start:Int, end:Int){
        if start &amp;gt; end{
            return nil
        }
        self.start = start
        self.end = end
    }
}
var range = CloseRange(start: 0, end: 10)!
range.sum
range.sum1
range.start = 1
range.sum  //不变
range.sum1 //每次都重新计算&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;计算属性&lt;/strong&gt; 除存储属性外，类、结构体和枚举可以定义计算属性，计算属性不直接存储值，而是提供一个 getter 来获取值，
一个可选的 setter 来间接设置其他属性或变量的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class sample {
    var no1 = 0.0, no2 = 0.0
    var length = 300.0, breadth = 150.0        
    var middle: (Double, Double) {
        get{
            return (length / 2, breadth / 2)
        }
        set(axis){
            no1 = axis.0 - (length / 2)
            no2 = axis.1 - (breadth / 2)
        }
    }
}
var result = sample()
print(result.middle)
result.middle = (0.0, 10.0)
print(result.no1)
print(result.no2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;只读计算属性&lt;/strong&gt; 只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点(.)运算符访问，但不能设置新的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class film {
    var head = &amp;quot;&amp;quot;
    var duration = 0.0
    var metaInfo: [String:String] {
        return [
            &amp;quot;head&amp;quot;: self.head,
            &amp;quot;duration&amp;quot;:&amp;quot;\(self.duration)&amp;quot;
        ]
    }
}
var movie = film()
movie.head = &amp;quot;肖申克救赎&amp;quot;
movie.duration = 3.09

print(movie.metaInfo[&amp;quot;head&amp;quot;]!)
print(movie.metaInfo[&amp;quot;duration&amp;quot;]!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;属性观察器&lt;/strong&gt;  属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Samplepgm {
    var counter: Int = 0{
        willSet(newTotal){
            print(&amp;quot;计数器: \(newTotal)&amp;quot;)
        }
        didSet{
            if counter &amp;gt; oldValue {
                print(&amp;quot;新增数 \(counter - oldValue)&amp;quot;)
            }
        }
    }
}
let NewCounter = Samplepgm()
NewCounter.counter = 100
NewCounter.counter = 800
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;willSet在设置新的值之前调用&lt;/li&gt;
&lt;li&gt;didSet在新的值被设置之后立即调用&lt;/li&gt;
&lt;li&gt;willSet和didSet观察器在属性初始化过程中不会被调用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;全局变量和局部变量&lt;/strong&gt;  计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;局部变量&lt;/th&gt;
&lt;th&gt;全局变量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在函数、方法或闭包内部定义的变量。&lt;/td&gt;
&lt;td&gt;函数、方法、闭包或任何类型之外定义的变量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用于存储和检索值。  用于存储和检索值。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;td&gt;存储属性用于获取和设置值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;td&gt;也用于计算属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;**类型属性 类型方法 ** 类型属性是作为类型定义的一部分写在类型最外层的花括号（{}）内。使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Player{
    var name:String
    var score = 0
    static var heighestScore = 0
    init(name:String) {
        self.name = name
    }
    func play() {
        let score = arc4random()%100
        print(&amp;quot;\(name) played and got \(score) score&amp;quot;)
        self.score += Int(score)
        Player.heighestScore = Player.heighestScore &amp;gt; self.score ? Player.heighestScore:self.score
        print(&amp;quot;Highest Score is \(Player.heighestScore)&amp;quot;)
    }

     static func heightScore(){
        print(&amp;quot;Highest Score is == \(Player.heighestScore)&amp;quot;)
     }
}
var play1 = Player.init(name: &amp;quot;Player1&amp;quot;)
var play2 = Player.init(name: &amp;quot;Player2&amp;quot;)

play1.play()
play2.play()
Player.heighestScore
Player.heightScore()


play1.play()
play2.play()
Player.heighestScore

play1.play()
play2.play()
Player.heighestScore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问控制&lt;/strong&gt; public internal private&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UI{
    private var fontColor: UIColor!
    var backGroundColor: UIColor!
    var themeMode:Theme = .DayMode{
        didSet{
            self.changetheme(themeModel: themeMode)
        }

    }

    private func changetheme(themeModel:Theme) {
        switch themeModel {
        case .DayMode:
            fontColor = UIColor.black
            backGroundColor = UIColor.orange
        case .NightMode:
            fontColor = UIColor.gray
            backGroundColor = UIColor.lightGray
        }
    }

    init(){
        self.themeMode = .DayMode
        self.changetheme(themeModel: self.themeMode)
    }

    init(themeMode:Theme) {
        self.themeMode = themeMode
        self.changetheme(themeModel: themeMode)
    }
}

let ui = UI()
ui.themeMode
ui.backGroundColor
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-15 类</title>
            <link>http://blog.flywithme.top/2017/03/29/swift15/</link>
            <pubDate>Wed, 29 Mar 2017 14:18:03 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/29/swift15/</guid>
            <description>&lt;p&gt;&lt;strong&gt;类&lt;/strong&gt;：Swift 类是构建代码所用的一种通用且灵活的结构体。我们可以为类定义属性和方法。
    与其他编程语言不同的是,Swift 并不要求你为自定义的类去创建独立的接口和实现文件，
    你要做的是在一个单一文件中定义一个类，系统会自动生产面向其他代码的外部接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
    var firstName:String = &amp;quot;&amp;quot;
    var lastName:String = &amp;quot;&amp;quot;
}

class Person1{
    var firstName:String
    var lastName:String
    init(firstName:String, lastName:String) {
        self.firstName = firstName
        self.lastName = lastName
    }
}
let person1 = Person1.init(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;类和结构体的对比&lt;/strong&gt;&lt;br /&gt;
 共同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义属性用于存储值&lt;/li&gt;
&lt;li&gt;定义方法用于提供功能&lt;/li&gt;
&lt;li&gt;定义附属脚本用于访问值&lt;/li&gt;
&lt;li&gt;定义构造器用于生成初始化值&lt;/li&gt;
&lt;li&gt;通过扩展以增加默认实现的功能&lt;/li&gt;
&lt;li&gt;符合协议以对某类提供标准功能
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比结构体多了如下功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许一个类继承另一个类的特征&lt;/li&gt;
&lt;li&gt;类型转换允许在运行时检查和解释一个类的实例类型&lt;/li&gt;
&lt;li&gt;结构器允许一个实例释放任何其所分配的资源&lt;/li&gt;
&lt;li&gt;引用计数允许对一个类多次引用
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区别：引用类型和值类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//示例：
class Person{
   var firstName:String = &amp;quot;&amp;quot;
   var lastName:String = &amp;quot;&amp;quot;
}

let person1 = Person(firstName: &amp;quot;Bobo&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)
let person2 = person1
person2.firstName = &amp;quot;abc&amp;quot;
person1.firstName  // &amp;quot;abc&amp;quot;  person1 和 person2 是引用关系 指向同一个内存空间
let person3 = Person(firstName: &amp;quot;abc&amp;quot;, lastName: &amp;quot;Stream&amp;quot;)

struct Location{
    var latitude:Double
    var longitude:Double
}

var aLocation = Location.init(latitude: 2.0, longitude: 3.0)
var blocation = aLocation
blocation.latitude = 1.0
aLocation.latitude    // 2.0  aLocation 和 bloaction 是值类型关系，赋值是拷贝，产生一个新的副本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;恒等运算符&lt;/strong&gt;  因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例.
          为了能够判定两个常量或者变量是否引用同一个类实例，Swift 内建了两个恒等运算符：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;===&lt;/code&gt;: 如果两个常量或者变量引用同一个类实例则返回 true&lt;br /&gt;
      &lt;code&gt;!==&lt;/code&gt;: 如果两个常量或者变量引用不同一个类实例则返回 true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; person1 === person2   //true
 person1 === person3   //false
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-14 结构体</title>
            <link>http://blog.flywithme.top/2017/03/23/swift3-14/</link>
            <pubDate>Thu, 23 Mar 2017 16:54:15 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/23/swift3-14/</guid>
            <description>&lt;p&gt;Swift 结构体是构建代码所用的一种通用且灵活的构造体。我们可以为结构体定义属性（常量、变量）和添加方法，从而扩展结构体的功能.&lt;br /&gt;
与 C 和 Objective-C 不同的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体不需要包含实现文件和接口&lt;/li&gt;
&lt;li&gt;结构体允许我们创建一个单一文件,且系统会自动生成面向其他代码的外部接口
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct MarkStruct{
   var mark1: Int
   var mark2: Int
   var mark3: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结构体应用&lt;/strong&gt;  需要注意的以下几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构体的主要目的是用来封装少了相关简单数据&lt;/li&gt;
&lt;li&gt;有理由预计一个结构体实例在赋值和传递时,封装的数据将会被拷贝而不是被引用&lt;/li&gt;
&lt;li&gt;任何在结构体中存储的值类型属性,也将会被拷贝,而不是被引用。&lt;/li&gt;
&lt;li&gt;结构体不需要去继承另一个已存在类型的属性或者行为。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说就是:结构体实例是通过值传递,而不是通过引用传递。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude:Double
    var longitude:Double
}
let aLocation = Location(latitude: 12.0,longitude: 212.0)
var bLoaction = Location.init(latitude: 1.2, longitude: 1.3)
struct Place{
    var location:Location
    var name:String
}

var aPlace = Place.init(location: bLoaction, name: &amp;quot;苹果总部&amp;quot;)
bLoaction.latitude = 37.3230
bLoaction.longitude = -122.0332
print(aPlace)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Location{
    var latitude : Double
    var longitude: Double

    init?(coordinateString:  String) {
         guard
            let commIndex = coordinateString.range(of: &amp;quot;,&amp;quot;),
            let first = Double(coordinateString.substring(to: commIndex.lowerBound)),
            let second = Double(coordinateString.substring(from: commIndex.upperBound))
            else {
                return nil
        }

        self.latitude = first
        self.longitude = second
    }
    init(latitude:Double, longitude:Double) {
        self.latitude = latitude
        self.longitude = longitude

    }
    func printLocation() {
        print(&amp;quot;The Location is \(self.latitude), \(self.longitude)&amp;quot;)
    }
    func isNoth() -&amp;gt; Bool {
         self.printLocation()
         return self.latitude &amp;gt; 0
    }
}
let location = Location(coordinateString: &amp;quot;21,23&amp;quot;)
location?.latitude
location?.longitude
let location2 = Location(latitude: 25.222,longitude: 122.23222)
location2.isNoth()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-13 枚举</title>
            <link>http://blog.flywithme.top/2017/03/21/swift13/</link>
            <pubDate>Tue, 21 Mar 2017 15:30:52 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/03/21/swift13/</guid>
            <description>&lt;p&gt;枚举简单的说也是一种数据类型，只不过是这种数据类型只包含自定义的特定数据，它是一组有共同特性的数据的集合。
Swift 的枚举类似于 Objective C 和 C 的结构&lt;/p&gt;

&lt;p&gt;枚举的功能为&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;它声明在类中,可以通过实例化类来访问它的值.&lt;br /&gt;
  枚举也可以定义构造函数来提供一个初始成员值,可以在原始的实现基础上扩展它功能。&lt;br /&gt;
  可以遵守协议来提供标准的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义枚举
enum DaysofaWeek {
    case Sunday
    case Monday
    case TUESDAY
    case WEDNESDAY
    case THURSDAY
    case FRIDAY
    case Saturday
}
var weekDay = DaysofaWeek.THURSDAY
weekDay = .THURSDAY
switch weekDay
{
case .Sunday:
    print(&amp;quot;星期天&amp;quot;)
case .Monday:
    print(&amp;quot;星期一&amp;quot;)
case .TUESDAY:
    print(&amp;quot;星期二&amp;quot;)
case .WEDNESDAY:
    print(&amp;quot;星期三&amp;quot;)
case .THURSDAY:
    print(&amp;quot;星期四&amp;quot;)
case .FRIDAY:
    print(&amp;quot;星期五&amp;quot;)
case .Saturday:
    print(&amp;quot;星期六&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值与原始值的区别&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;相关值&lt;/th&gt;
&lt;th&gt;原始值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不同数据类型&lt;/td&gt;
&lt;td&gt;相同数据类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;值的创建基于常量或变量&lt;/td&gt;
&lt;td&gt;预先填充的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;相关值是当你在创建一个枚举成员的心常量或变量时才会被设置,并且每次当你这么做的时候,它的值都不同&lt;/td&gt;
&lt;td&gt;原始值试着是相同的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;原始值&lt;/strong&gt; Raw value  原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的.在原始值为整数的枚举时，不需要显式的为每一个成员赋值，Swift会自动为你赋值。&lt;/p&gt;

&lt;p&gt;例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Month: Int {
    case January = 1, February, March, April, May, June, July, August, September, October, November, December
}

let yearMonth = Month.May.rawValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关值&lt;/strong&gt; Associate Value 以下实例中我们定义一个名为 Student 的枚举类型，它可以是 Name 的一个相关值（Int，Int，Int，Int），或者是 Mark 的一个字符串类型（String）相关值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Student{
    case Name(String)
    case Mark(Int,Int,Int)
}
var studDetails = Student.Name(&amp;quot;Runoob&amp;quot;)
var studMarks = Student.Mark(98,97,95)
switch studMarks {
case .Name(let studName):
    print(&amp;quot;学生的名字是: \(studName)。&amp;quot;)
case .Mark(let Mark1, let Mark2, let Mark3):
    print(&amp;quot;学生的成绩是: \(Mark1),\(Mark2),\(Mark3)。&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可选型的实质就是枚举&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//public enum Optional&amp;lt;Wrapped&amp;gt;
var website: Optional&amp;lt;String&amp;gt; = Optional.some(&amp;quot;www.dianping.com&amp;quot;)
website = .none   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;枚举递归&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indirect enum ArithmeticExpression{
indirect enum ArithmeticExpression{
    case Number(Int)
    case Addition(ArithmeticExpression, ArithmeticExpression)
    case Multiplication(ArithmeticExpression, ArithmeticExpression)
}

let five = ArithmeticExpression.Number(5)
let two = ArithmeticExpression.Number(2)
let sum = ArithmeticExpression.Addition(five, two)
let product = ArithmeticExpression.Multiplication(sum, two)

func evaluate(expression:ArithmeticExpression) -&amp;gt; Int{
    switch expression {
    case let .Number(value):
        return value
    case let .Addition(left,right):
        return evaluate(expression: left) + evaluate(expression: right)
    case let .Multiplication(left,right):
        return evaluate(expression: left)*evaluate(expression: right)
    }
} 
evaluate(expression: product)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-12 闭包</title>
            <link>http://blog.flywithme.top/2017/02/28/swift12/</link>
            <pubDate>Tue, 28 Feb 2017 17:43:27 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/28/swift12/</guid>
            <description>&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt;
  闭包(Closures)是自包含的功能代码块,可以在代码中使用或者用来传参传值。
   Swift 的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。
   全局函数和嵌套函数其实就是特殊的闭包。&lt;/p&gt;

&lt;p&gt;闭包的形式有&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;全局函数&lt;/strong&gt;:    有名字但不能捕获任何值&lt;br /&gt;
   &lt;strong&gt;嵌套函数&lt;/strong&gt;:    有名字,可以捕获封闭函数内的值&lt;br /&gt;
   &lt;strong&gt;闭包表达式&lt;/strong&gt;:  无名闭包,使用轻量级语法,可以根据上下文环境捕获值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let clousuer = { print(&amp;quot;Swift 闭包实例。&amp;quot;) }
clousuer()


//加法
let sum = {(val1:Int, val2:Int)-&amp;gt; Int in
        return val1 + val2
}
let result = sum(20,2)

//排序
var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}
arr.sorted(by: {(a: Int, b:Int) -&amp;gt; Bool in

    return a &amp;gt; b
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包的简化&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简化: 根据现场情况,选择适合当前情况的写法。
arr.sort(by:{a, b in return a &amp;gt; b}) //因为只能是 Int 类型的,可以省去声明
arr
arr.sort(by:{a, b in  a &amp;lt; b})  //省去 Return
arr
arr.sort(by: {$0&amp;gt;$1}) //$0, $1(从0开始，表示第i个参数...) 省去参数,直接使用简化参数名
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运算符函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.sort(by: &amp;lt;) //可以这样写的原因是 Swift中,&amp;gt; &amp;lt; = + - 等,本身就是函数
arr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;尾随闭包&lt;/strong&gt;  Trailing closure syntax   尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//把闭包写在()外边
arr.sorted(){a, b in
    return a &amp;gt; b
}
//由于么有参数需要传入,()也可以省略
arr.sorted{a, b in
    return a &amp;gt; b
}
arr.sorted{$0 &amp;gt; $1}


//实现一个小动画
import UIKit
import XCPlayground

let showView = UIView(frame:CGRect(x:0,  y:0, width:300, height:300))
let rectAngle = UIView(frame:CGRect(x:0,  y:0, width:50, height:50))
rectAngle.center = showView.center
showView.backgroundColor = UIColor .white
rectAngle.backgroundColor = UIColor.red
showView.addSubview(rectAngle)
XCPlaygroundPage.currentPage.liveView = showView
UIView.animate(withDuration: 4.0, animations: {
    rectAngle.backgroundColor = UIColor.orange
    rectAngle.frame = CGRect(x:0,  y:0, width:300, height:300)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;内容捕获&lt;/strong&gt;   闭包可以在其定义的上下文中捕获常量或变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

var num = 300
arr.sorted{
    a, b in abs(a - num) &amp;lt; abs(b - num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;闭包是引用类型&lt;/strong&gt;  无论您将函数/闭包赋值给一个常量还是变量，实际上都是将常量/变量的值设置为对应函数/闭包的引用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func makeIncrementor(forIncrement amount: Int) -&amp;gt; () -&amp;gt; Int {
    var runningTotal = 0
    func incrementor() -&amp;gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// 返回的值为10
incrementByTen()

// 返回的值为20
incrementByTen()

// 返回的值为30
incrementByTen()

// 返回的值为40
incrementByTen()

let alsoIncrementByTen = incrementByTen

// 返回的值为50
print(alsoIncrementByTen())
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-11 函数</title>
            <link>http://blog.flywithme.top/2017/02/27/swift11/</link>
            <pubDate>Mon, 27 Feb 2017 13:41:21 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/27/swift11/</guid>
            <description>&lt;p&gt;&lt;strong&gt;函数定义&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Swift 定义函数使用关键字 func。
  定义函数的时候，可以指定一个或多个输入参数和一个返回值类型。
  每个函数都有一个函数名来描述它的功能。通过函数名以及对应类型的参数值来调用这个函数。函数的参数传递的顺序必须与参数列表相同。
  函数的实参传递的顺序必须与形参列表相同，-&amp;gt; 后定义函数的返回值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func hello(name:String)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + name
}

hello(name: &amp;quot;Jack&amp;quot;)    


func hello1(name:String?)-&amp;gt; String{
    return &amp;quot;Hello &amp;quot; + (name != nil  ? name! : &amp;quot;guess&amp;quot;)
}

hello1(name: &amp;quot;Jack&amp;quot;)


func printHello(){
    print(&amp;quot;hello&amp;quot;)
}
printHello()

func printHello1() -&amp;gt; Void{  //Void 是一个类型
    print(&amp;quot;hello&amp;quot;)
}
printHello1()

func printHello2() -&amp;gt; (){
    print(&amp;quot;hello&amp;quot;)
}
printHello2()    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用元组作为返回值&lt;/strong&gt;  函数返回值的类型可以是字符串,整型,浮点型等,元组与数组类似,不同的是,元组中的元素可以是任意类型,使用的是括号,你可以使用元组类型让多个值作为一个复合值从函数中返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findMaxAndMin(numbers:[Int]) -&amp;gt; (max:Int, min:Int)?{ //如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型。
    guard !numbers.isEmpty else {
        return (Int.max,Int.min)
    }
    var minValue = numbers[0]
    var maxValue = numbers[0]
    for num in numbers{
        minValue = minValue &amp;lt; num ? minValue : num
        maxValue =  maxValue &amp;gt; num ? maxValue : num
    }
    return (maxValue ,minValue)
}
var numbers = [1,23,34,2,2,31,23,23,34,45,454545,4,54,5,45,45,45]
var result =  findMaxAndMin(numbers: numbers)
print(result?.max ?? 0,result?.min ?? 0)  
if let result =  findMaxAndMin(numbers: numbers) {
    print( result.max,result.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数的内部参数和外部参数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHelloTo(name:String, msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;)  //sayHelloTo(&amp;quot;a&amp;quot;, msg: &amp;quot;b&amp;quot;) 这种方式已被废弃

//内部参数和外部参数
func sayHelloTo(name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHelloTo(name: &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//修改外部参数名
func sayHello(to name:String, withMessage msg:String)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)

//隐藏调用参数
func mutiply(_ num1:Int, _ num2:Int) -&amp;gt; Int{
    return num1*num2
}
mutiply(2,  4) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认参数值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;) //可以省略后面的一个参数


func sayHello(to name:String, withMessage msg:String = &amp;quot;hello&amp;quot;, punctuation:String = &amp;quot;!&amp;quot;)-&amp;gt; String{
    return &amp;quot;\(msg), \(name) \(punctuation)&amp;quot;
}
sayHello(to : &amp;quot;a&amp;quot;, withMessage: &amp;quot;b&amp;quot;)
sayHello(to: &amp;quot;jack&amp;quot;)
sayHello(to: &amp;quot;Jack&amp;quot;, withMessage: &amp;quot;Hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可变参数值&lt;/strong&gt; 一个函数至多只可以有一个变长的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//常用的变长参数函数
print(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
//求平均值
func mean(numbers:Double ...) -&amp;gt;Double{
    var sum : Double = 0
    for num in numbers{
        sum += num
    }
    return sum / Double(numbers.count)
}
mean(numbers: 1,2,3,4,5,5.0,23,434)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量参数,变量参数和 inout 参数&lt;/strong&gt; 默认的函数参数都是常量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func toBinary(num:Int)-&amp;gt;String{ //直接声明称 var 类型参数已被废弃。
    var num = num  
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
toBinary(num: 1000)

//inout 
func toBinary( num:inout Int)-&amp;gt;String{
    var res = &amp;quot;&amp;quot;
    repeat{
        res = String(num%2) + res
        num /= 2
    }while num != 0
    return res
}
var num = 100
toBinary(num: &amp;amp;num) //传入指针
print(num) 

//交换两个字符串
func swapTwoString(str1:inout String, str2:inout String){
    let tstr = str1
    str1 = str2
    str2 = tstr
}

var str1 = &amp;quot;a&amp;quot;
var str2 = &amp;quot;b&amp;quot;
swapTwoString(str1: &amp;amp;str1, str2:&amp;amp;str2)
str1
str2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数型变量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a:Int, b:Int) -&amp;gt; Int{
    return a + b
}

let add01 = add
add01(3,4)
let add02:(Int, Int) -&amp;gt; Int = add
add02(4,5)


var arr:[Int] = []
for _ in 0...100{
    arr.append(Int(arc4random()%1000))
}

arr.sort { (a, b) -&amp;gt; Bool in
    return a &amp;lt; b
}
arr

func descending (a:Int ,b:Int) -&amp;gt;Bool{
    return a &amp;gt; b
}
arr.sorted(by: descending)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;函数变成初步&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeScores( scors: [Int], by method:(Int)-&amp;gt; Int) -&amp;gt; [Int]{
    var arr = scors
    for (index , score) in scors.enumerated(){
        arr[index] = method(score)
    }
    return arr
}
func changeScore01 (score : Int) -&amp;gt; Int{
    return score + 3
}

func changeScore02 (score : Int) -&amp;gt; Int{
    return Int(Double(score)/150.0*100.0)
}

var arr:[Int] = []
for _ in 0..&amp;lt;10{
    arr.append(Int(arc4random())%150)
}
arr
changeScores(scors: arr, by: changeScore01)
changeScores(scors: arr, by: changeScore02)
//map 
arr.map(changeScore01)
func isPassOrFail(score:Int)-&amp;gt;String{
    return score &amp;lt; 60 ? &amp;quot;Fail&amp;quot;: &amp;quot;Pass&amp;quot;
}
arr.map(isPassOrFail)

//filter 过滤
func fail (score:Int)-&amp;gt; Bool{
    return score &amp;lt; 60
}
arr.filter(fail)

//reduce 聚合
func add(a:Int, b:Int)-&amp;gt; Int{
    return a + b
}
arr.reduce(0, add)

arr.reduce(0, +)

//Swift中,运算符号 本质上就是一个函数 
public func +(lhs: Int, rhs: Int) -&amp;gt; Int
public func *(lhs: Int, rhs: Int) -&amp;gt; Int
public func -(lhs: Int, rhs: Int) -&amp;gt; Int
public func /(lhs: Int, rhs: Int) -&amp;gt; Int
public func %(lhs: Int, rhs: Int) -&amp;gt; Int


func concatenate(str:String , num:Int) -&amp;gt; String{
    return &amp;quot;\(str)\(num) &amp;quot;
}
arr.reduce(&amp;quot;&amp;quot;, concatenate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;返回函数类型和函数嵌套&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//邮递费用
func tilerMailfeeByWight( weight : Int) -&amp;gt; Int{
    return 1*weight
}
func tiler2MailfeeByWight( weight : Int) -&amp;gt; Int{
    return 3*weight
}
//超过10单位，则按三倍计算
func feeBytUnitPrice (price :Int , wight:Int) -&amp;gt; Int{
    py
    func chooseMailFeeCalationByWeight(weight: Int) -&amp;gt; (Int) -&amp;gt; Int{
        return weight &amp;lt;= 10 ? tilerMailfeeByWight : tiler2MailfeeByWight
    }

    let mailFeefuc = chooseMailFeeCalationByWeight(weight: wight)
    return mailFeefuc(wight) + price*wight //邮递费用+商品费用
}
feeBytUnitPrice(price: 2, wight: 11)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>swift3-10 数据集合小节</title>
            <link>http://blog.flywithme.top/2017/02/22/swift10/</link>
            <pubDate>Wed, 22 Feb 2017 16:15:18 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift10/</guid>
            <description>&lt;p&gt;&lt;strong&gt;选择合适的数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;有序,最大的特定就是有序,如果我们操作的元素是有序的话,使用数组是最方便的。如果需要排序,最好也选择数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;集合&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;无序,唯一性,集合特有的操作,快速查找 如果需要做一些特殊的集合计算,就使用集合,比如在做用户特性分析的时候,分组的时候就可以使用
          集合,获取共同喜好,共同兴趣等。快速查找这个是集合的一大优势,数组查找复杂度是 O(n), 而集合的复杂度是 O(log2(n)),
          例如一个100万的数据,如果是数组查找的话,最坏的情况是
             查找100万次,而集合的最大次数是 log2(1000000) 大约是20次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字典&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;键值数据对,这个就不说了,使用的很广泛。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;回顾&lt;/strong&gt; &lt;code&gt;for in&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...10{
    print(index)
}

for c in &amp;quot;hello&amp;quot;.characters{
    print(c)
}

var arr = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
for str in arr{
    print(str)
}

for (index ,str) in arr.enumerated(){
    print(index, str)
}

var dic = [1:&amp;quot;a&amp;quot; , 2:&amp;quot;b&amp;quot;]
for key in dic{
    print(key)
}
for value in dic.values{
    print(value)
}

for (key, value) in dic{
    print(key,value)
}

var setA = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;] as Set
for str in setA{
    print(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;还有很多没有涉及到的方法。这些方法需要我们在开发的过程中,慢慢学习了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
        <item>
            <title>Swift3-09 集合</title>
            <link>http://blog.flywithme.top/2017/02/22/swift09/</link>
            <pubDate>Wed, 22 Feb 2017 15:18:43 CST</pubDate>
            <author>Brasbug</author>
            <guid>http://blog.flywithme.top/2017/02/22/swift09/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;将一些元素放在一起,它们是无序的, 跟数组的不同是,数组是一个有序的列表,而集合是一个有序的数据集&lt;br /&gt;
   为什么需要集合,因为集合是无序的,所以,在做一些查找和判重的时候,效率会有差别。集合会有一些,比数组使用起来方便很多。
   &lt;strong&gt;集合中的每一个元素都是唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//集合的初始化
var arr = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;] //如果不显式的声明,则默认是数组
var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  //必须显式声明才行

var emptySet1:Set&amp;lt;String&amp;gt; = []
var emptySet2 = Set&amp;lt;Int&amp;gt;()

var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;c&amp;quot;]) //将一个数组转换成集合 


setA.count
setA.isEmpty
setA.first //随机的取出一个元素

setA.contains(&amp;quot;a&amp;quot;) //判断是否有这个元素
//遍历    
for str in setA{
    print(str)
}

var str = setA.joined(separator: &amp;quot;d&amp;quot;)

//比较
setA == setB
setA.elementsEqual(setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集合的操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]  
//插入
setA.insert(&amp;quot;D&amp;quot;) //返回一个元组
//更新
setA.update(with: &amp;quot;A&amp;quot;) //若已存在元素,则返回改元素,若没有,则返回nil
//删除
setA.remove(&amp;quot;a&amp;quot;) //返回一个 bool 若是 true 则表示删除成功,返回 false 则表示之前没有这个元素
setA.removeAll() 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;并集: &lt;code&gt;union&lt;/code&gt; (不改变调用者的集合), &lt;code&gt;formUnion&lt;/code&gt;  (改变调用者的集合)  两个集合中的所有元素集合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var setA:Set = [&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;]
var setB = Set([&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]) //将一根数组转换成集合

var setC =  setA.union(setB)  //setC 有 setA和 setB 所有元素,但是setA 不变
setA.union([&amp;quot;a&amp;quot;])

setA
setA.formUnion(setB) //setA 被改变
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;交集: &lt;code&gt;intersect&lt;/code&gt;(不改变调用者的集合),  &lt;code&gt;formIntersection&lt;/code&gt; (改变调用者的集合) 两个集合的公共部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.intersection(setB)
setA

setA.formIntersection(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;补集(差集): 做减法  &lt;code&gt;subtracting&lt;/code&gt; (不改变调用者的集合) &lt;code&gt;subtract&lt;/code&gt; (改变调用者的集合)   调用者不包含在被调用者中的部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.subtracting(setB)  //setA 独有的,而 setB 没有的元素 不改变 setA 值
setA

setA.subtract(setB) //setA 独有的,而 setB 没有的元素 改变 setA 值
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;去重: &lt;code&gt;symmetricDifference&lt;/code&gt;(不改变调用者的集合), &lt;code&gt;formSymmetricDifference&lt;/code&gt; (改变调用者的集合),   去除两个集合中相同的部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.symmetricDifference(setB)
setA
setA.formSymmetricDifference(setB)
setA
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;子集: &lt;code&gt;isSbuset&lt;/code&gt; 子集, &lt;code&gt;isStrictSubset&lt;/code&gt; 真子集  判断是否是另外一个集合的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSubset(of: setB)
setA.isStrictSubset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;超集: &lt;code&gt;isSuperset&lt;/code&gt;超集 ,  &lt;code&gt;isStrictSuperset&lt;/code&gt; 真超集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isSuperset(of: setB)
setA.isStrictSuperset(of: setB)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;相离:  &lt;code&gt;isDisjoint&lt;/code&gt; 没有重叠的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;setA.isDisjoint(with: setB)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
